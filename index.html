<!DOCTYPE html>
<html>
<head>
<title>regl-scatter2d</title>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport" />
<meta charset=utf-8><meta name="application-name" content="regl-scatter2d">
<meta name="subject" content="Scatter2d plot built with regl">
<meta name="abstract" content="Scatter2d plot built with regl">
<meta name="twitter:title" content="regl-scatter2d">
<meta name="description" content="Scatter2d plot built with regl">
<meta name="twitter:description" content="Scatter2d plot built with regl">
<meta name="author" content="Dima Yv &lt;df.creative@gmail.com&gt;">
<meta name="twitter:creator" content="Dima Yv &lt;df.creative@gmail.com&gt;">
<meta name="twitter:card" content="summary">
<meta property="og:title" content="regl-scatter2d">
<meta property="og:description" content="Scatter2d plot built with regl">
<meta property="article:author" content="Dima Yv &lt;df.creative@gmail.com&gt;">
<style type="text/css">.github-corner{display:block;position:absolute;top:0;left:auto;right:0;z-index:10000}.github-corner svg{display:block}.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%{transform:rotate(0)}20%{transform:rotate(-25deg)}40%{transform:rotate(10deg)}60%{transform:rotate(-25deg)}80%{transform:rotate(10deg)}100%{transform:rotate(0)}}@media(max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style></head>
<body><a href="https://github.com/gl-vis/regl-scatter2d" class="github-corner" aria-label="View source on Github"><svg xmlns="http://www.w3.org/2000/svg" width="80" height="80" viewBox="0 0 250 250" fill="#fff">
  <path d="M0 0l115 115h15l12 27 108 108V0z" fill="#333"/>
  <path class="octo-arm" d="M128 109c-15-9-9-19-9-19 3-7 2-11 2-11-1-7 3-2 3-2 4 5 2 11 2 11-3 10 5 15 9 16" style="-webkit-transform-origin: 130px 106px; transform-origin: 130px 106px"/>
  <path class="octo-body" d="M115 115s4 2 5 0l14-14c3-2 6-3 8-3-8-11-15-24 2-41 5-5 10-7 16-7 1-2 3-7 12-11 0 0 5 3 7 16 4 2 8 5 12 9s7 8 9 12c14 3 17 7 17 7-4 8-9 11-11 11 0 6-2 11-7 16-16 16-30 10-41 2 0 3-1 7-5 11l-12 11c-1 1 1 5 1 5z"/>
</svg>
</a></body>
<script>
(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/**
 * Test multiple points
 */
require('enable-mobile');
const setup = require('./setup');
const random = require('gauss-random'

//5e6 is allocation maximum
// var POINT_COUNT = 3e6
);var POINT_COUNT = 1e5;

var positions = new Float32Array(2 * POINT_COUNT);
for (var i = 0; i < 2 * POINT_COUNT; ++i) {
  positions[i] = random();
}

// positions = [0,0, .25,.25, .5,.5, 1,1, 2, 2, 3, 3]

setup({
  positions: positions,
  size: 5,
  color: [0, 0, 0, 1],
  borderSize: 1,
  borderColor: [.5, .5, .5, .5]
});

},{"./setup":2,"enable-mobile":63,"gauss-random":68}],2:[function(require,module,exports){
/**
 * Create gl-scatter2d-fancy test-case
 */

var fit = require('canvas-fit');
var mouseWheel = require('mouse-wheel');
var mouseChange = require('mouse-change');
var createScatter = require('../');
var createSelectBox = require('gl-select-box');
var createSpikes = require('gl-spikes2d');
var createPlot = require('gl-plot2d');
var createFps = require('fps-indicator');

module.exports = setup;

function setup(options) {
  createFps();

  var canvas = document.createElement('canvas');
  document.body.appendChild(canvas);
  window.addEventListener('resize', fit(canvas, null, +window.devicePixelRatio), false);

  var gl = canvas.getContext('webgl', {
    depth: false
    // alpha: true,
    // premultipliedAlpha: true
  });

  var aspect = gl.drawingBufferWidth / gl.drawingBufferHeight;
  var dataBox = [-10, -10 / aspect, 10, 10 / aspect];

  function makeTicks(lo, hi) {
    var result = [];
    for (var i = lo; i <= hi; ++i) {
      result.push({
        x: i,
        text: i + ''
      });
    }
    return result;
  }

  var plot = createPlot({
    gl: gl,
    dataBox: dataBox,
    title: 'gl-scatter2d',
    ticks: [makeTicks(-20, 20), makeTicks(-20, 20)],
    labels: ['x', 'y'],
    pixelRatio: 1,
    tickMarkWidth: [1, 1, 1, 1],
    tickMarkLength: [3, 3, 3, 3]
  });

  var selectBox = createSelectBox(plot, {
    innerFill: false,
    outerFill: true
  });
  selectBox.enabled = false;

  var spikes = createSpikes(plot);

  options.plot = plot;
  var scatter = createScatter(options);

  var lastX = 0,
      lastY = 0;
  var boxStart = [0, 0];
  var boxEnd = [0, 0];
  var boxEnabled = false;
  mouseChange(function (buttons, x, y, mods) {
    y = window.innerHeight - y;
    x *= plot.pixelRatio;
    y *= plot.pixelRatio;

    if (buttons & 1) {
      if (mods.shift) {
        var dataX = (x - plot.viewBox[0]) / (plot.viewBox[2] - plot.viewBox[0]) * (dataBox[2] - dataBox[0]) + dataBox[0];
        var dataY = (y - plot.viewBox[1]) / (plot.viewBox[3] - plot.viewBox[1]) * (dataBox[3] - dataBox[1]) + dataBox[1];
        if (!boxEnabled) {
          boxStart[0] = dataX;
          boxStart[1] = dataY;
        }
        boxEnd[0] = dataX;
        boxEnd[1] = dataY;
        boxEnabled = true;
        spikes.update();
      } else {
        var dx = (lastX - x) * (dataBox[2] - dataBox[0]) / (plot.viewBox[2] - plot.viewBox[0]);
        var dy = (lastY - y) * (dataBox[3] - dataBox[1]) / (plot.viewBox[3] - plot.viewBox[1]);

        dataBox[0] += dx;
        dataBox[1] += dy;
        dataBox[2] += dx;
        dataBox[3] += dy;

        plot.setDataBox(dataBox);
        spikes.update();
      }
    } else {
      var result = plot.pick(x / plot.pixelRatio, y / plot.pixelRatio);
      if (result) {
        spikes.update({ center: result.dataCoord });
      } else {
        spikes.update();
      }
    }

    if (boxEnabled) {
      selectBox.enabled = true;
      selectBox.selectBox = [Math.min(boxStart[0], boxEnd[0]), Math.min(boxStart[1], boxEnd[1]), Math.max(boxStart[0], boxEnd[0]), Math.max(boxStart[1], boxEnd[1])];
      plot.setDirty();
      if (!(buttons & 1 && mods.shift)) {
        selectBox.enabled = false;
        dataBox = [Math.min(boxStart[0], boxEnd[0]), Math.min(boxStart[1], boxEnd[1]), Math.max(boxStart[0], boxEnd[0]), Math.max(boxStart[1], boxEnd[1])];
        plot.setDataBox(dataBox);
        boxEnabled = false;
      }
    }

    lastX = x;
    lastY = y;
  });

  mouseWheel(function (dx, dy, dz) {
    var scale = Math.exp(0.1 * dy / gl.drawingBufferHeight);

    var cx = (lastX - plot.viewBox[0]) / (plot.viewBox[2] - plot.viewBox[0]) * (dataBox[2] - dataBox[0]) + dataBox[0];
    var cy = (-plot.viewBox[1] + lastY) / (plot.viewBox[3] - plot.viewBox[1]) * (dataBox[3] - dataBox[1]) + dataBox[1];

    dataBox[0] = (dataBox[0] - cx) * scale + cx;
    dataBox[1] = (dataBox[1] - cy) * scale + cy;
    dataBox[2] = (dataBox[2] - cx) * scale + cx;
    dataBox[3] = (dataBox[3] - cy) * scale + cy;

    plot.setDataBox(dataBox);

    return true;
  });

  function render() {
    requestAnimationFrame(render);
    plot.draw();
  }

  render();

  return scatter;
}

},{"../":3,"canvas-fit":37,"fps-indicator":65,"gl-plot2d":80,"gl-select-box":82,"gl-spikes2d":91,"mouse-change":109,"mouse-wheel":111}],3:[function(require,module,exports){
'use strict';

const createRegl = require('regl');
const extend = require('object-assign');
const rgba = require('color-rgba');
const getBounds = require('array-bounds');
const clamp = require('clamp');
const atlas = require('font-atlas-sdf');
const colorId = require('color-id');
const snapPoints = require('snap-points-2d');
const normalize = require('array-normalize');

module.exports = Scatter;

function Scatter(options) {
  if (!(this instanceof Scatter)) return new Scatter(options);

  // regl instance
  if (options.regl) this.regl = options.regl;

  // gl-plot2d case
  else if (options.plot) {
      this.plot = options.plot;

      this.regl = createRegl({
        gl: this.plot.gl,
        pixelRatio: this.plot.pixelRatio
      });

      this.plot.addObject(this);
    }

    // container/gl/canvas case
    else {
        this.regl = createRegl({
          pixelRatio: options.pixelRatio || this.pixelRatio,
          gl: options.gl,
          container: options.container,
          canvas: options.canvas
        });
      }

  // refs for compatibility
  this.gl = this.regl._gl;
  this.canvas = this.gl.canvas;
  this.container = this.canvas.parentNode;

  this.init(options);
}

//last positions raw data
Scatter.prototype.positions = [];
Scatter.prototype.pointCount = 0;

//selected point indexes array
Scatter.prototype.selection = null;

//current viewport settings
Scatter.prototype.scale = [1, 1];
Scatter.prototype.translate = [0, 0];

//TODO
Scatter.prototype.viewBox = null;
Scatter.prototype.dataBox = null;

//point style options
Scatter.prototype.size = 12;
Scatter.prototype.color = [1, 0, 0, 1];
Scatter.prototype.borderSize = 1;
Scatter.prototype.borderColor = [0, 0, 0, 1];

//gl settings
Scatter.prototype.pixelRatio = window.devicePixelRatio;
Scatter.prototype.gl = null;
Scatter.prototype.container = null;
Scatter.prototype.canvas = null;

//group points for faster rendering of huge number of them
Scatter.prototype.cluster = false;

//font atlas texture singleton
Scatter.prototype.charCanvas = document.createElement('canvas');
Scatter.prototype.charStep = 400;

//create drawing methods based on initial options
Scatter.prototype.init = function (options) {
  let regl = this.regl;

  this.bounds = [-Infinity, -Infinity, Infinity, Infinity];

  //textures for glyphs and color palette
  this.charTexture = regl.texture(this.charCanvas

  //awesome buffers to reuse
  );this.sizeBuffer = regl.buffer({
    usage: 'dynamic',
    type: 'float',
    data: null
  });
  this.positionBuffer = regl.buffer({
    usage: 'static',
    type: 'float',
    data: null
  });
  this.colorBuffer = regl.buffer({
    usage: 'dynamic',
    type: 'uint8',
    data: null
  });

  this.update(options);

  this.drawPoints = regl({
    vert: `
    precision mediump float;

    attribute vec2 position;
    attribute float size;
    attribute vec4 color;

    uniform vec2 scale, translate;
    uniform float borderSize;

    varying vec4 fragColor;
    varying float centerFraction;

    void main() {
      gl_PointSize = size;
      gl_Position = vec4((position + translate) * scale * 2. - 1., 0, 1);
      // gl_Position.y *= -1.;

      centerFraction = borderSize == 0. ? 2. : size / (size + borderSize + 1.25);
      fragColor = color;
    }`,

    frag: `
    precision mediump float;
    uniform vec4 borderColor;

    const float fragWeight = 1.0;

    varying vec4 fragColor;
    varying float centerFraction;

    float smoothStep(float x, float y) {
      return 1.0 / (1.0 + exp(50.0*(x - y)));
    }

    void main() {
      float radius = length(2.0*gl_PointCoord.xy-1.0);
      if(radius > 1.0) {
        discard;
      }
      vec4 baseColor = mix(borderColor, fragColor, smoothStep(radius, centerFraction));
      float alpha = 1.0 - pow(1.0 - baseColor.a, fragWeight);
      gl_FragColor = vec4(baseColor.rgb * alpha, alpha);
    }`,

    uniforms: {
      scale: regl.this('scale'),
      translate: regl.this('translate'),
      borderColor: regl.this('borderColor'),
      borderSize: regl.this('borderSize')
    },

    attributes: {
      position: this.positionBuffer,
      size: () => {
        if (Array.isArray(this.size)) {
          return this.sizeBuffer;
        }
        return { constant: this.size };
      },
      color: () => {
        if (Array.isArray(this.color[0])) {
          return this.colorBuffer;
        }
        return { constant: this.color };
      }
    },

    blend: {
      enable: true,
      equation: { rgb: 'add', alpha: 'add' },
      func: { src: 'one', dst: 'one minus src alpha' }
    },

    count: regl.this('pointCount'),

    // and same for the selection
    // elements: [0,1],

    primitive: 'points'
  }

  //debug run
  );this.drawTest = regl({
    frag: `
    precision mediump float;

    void main() {
      gl_FragColor = vec4(0, 1, 0, 1);
    }`,

    vert: `
    precision mediump float;
    attribute vec2 position;

    void main() {
      gl_Position = vec4(position, 0, 1);
    }`,

    attributes: {
      position: [[-1, -1], [1, 0], [0, 1]]
    },

    count: 3
  });

  return this;
};

Scatter.prototype.update = function (options) {
  let regl = this.regl,
      w = this.canvas.width,
      h = this.canvas.height;

  if (options.length != null) options = { positions: options };

  let {
    positions,
    selection,
    scale,
    translate,
    size,
    color,
    borderSize,
    borderColor,
    glyph,
    pixelRatio,
    viewBox,
    dataBox,
    cluster
  } = options;

  if (cluster != null) this.cluster = cluster;

  //make sure scale/translate are properly set
  if (translate != null) {
    this.translate = typeof translate === 'number' ? [translate, translate] : translate;
  }
  if (scale != null) {
    this.scale = typeof scale === 'number' ? [scale, scale] : scale;
    this.scale[0] = Math.max(this.scale[0], 1e-10);
    this.scale[1] = Math.max(this.scale[1], 1e-10);
  }

  //update buffer
  if (positions != null) {
    if (this.cluster) {
      //do clustering
      //TODO: send clustering to worker
      this.getPoints = clusterPoints(positions);
    } else {
      this.positionBuffer(positions);
      this.pointCount = Math.floor(positions.length / 2);
    }
    this.positions = positions;

    //update bounds
    this.bounds = getBounds(positions, 2);
  }

  //sizes
  if (size != null) {
    this.size = size;
    if (Array.isArray(this.size)) {
      this.sizeBuffer(this.size);
    }
  }

  if (borderSize != null) this.borderSize = borderSize;

  //reobtain points in case if translate/scale/positions changed
  if (scale != null || positions != null) {
    //recalc bounds for the data
    if (this.cluster) {
      //TODO: read actual point radius/size here
      let radius = Array.isArray(this.size) ? id => this.size : this.size / Math.max(w, h) / this.scale[0];
      let ids = this.getPoints(radius);

      let subpositions = new Float32Array(ids.length * 2);
      for (let i = 0, id; i < ids.length; i++) {
        let id = ids[i];
        subpositions[i * 2] = this.positions[id * 2];
        subpositions[i * 2 + 1] = this.positions[id * 2 + 1];
      }
      this.positionBuffer(subpositions);
      this.pointCount = Math.floor(subpositions.length / 2);
    }
  }

  //process colors
  if (color != null) {
    //ensure colors are arrays
    if (Array.isArray(color) && (Array.isArray(color[0]) || typeof color[0] === 'string')) {
      for (let i = 0, l = this.positions.length / 2; i < l; i++) {
        if (color[i] != null) {
          color[i] = rgba(color[i]);
        } else {
          color[i] = Scatter.prototype.color;
        }
      }
      this.colorBuffer(color);
    } else if (typeof color === 'string') {
      color = rgba(color);
    }
    this.color = color;
  }
  if (borderColor != null) {
    this.borderColor = borderColor;
  }

  //aggregate glyphs
  if (glyph != null) {}
  // var glyphChars = {}
  // for (var i = 0, l = this.pointCount, k = 0; i < l; i++) {
  //   var char = glyphs[i]
  //   if (glyphChars[char] == null) {
  //     glyphChars[char] = k++
  //   }
  // }


  //update atlas
  /*
  var maxSize = 0
  for (var i = 0, l = sizes.length; i < l; ++i) {
    if (sizes[i] > maxSize) maxSize = sizes[i]
  }
  var oldStep = this.charStep
  this.charStep = clamp(Math.ceil(maxSize*4), 128, 768)
    var chars = Object.keys(glyphChars)
  var step = this.charStep
  var charSize = Math.floor(step / 2)
  var maxW = gl.getParameter(gl.MAX_TEXTURE_SIZE)
  var maxChars = (maxW / step) * (maxW / step)
  var atlasW = Math.min(maxW, step*chars.length)
  var atlasH = Math.min(maxW, step*Math.ceil(step*chars.length/maxW))
  var cols = Math.floor(atlasW / step)
  if (chars.length > maxChars) {
    console.warn('gl-scatter2d-fancy: number of characters is more than maximum texture size. Try reducing it.')
  }
    //do not overupdate atlas
  if (!this.chars || (this.chars+'' !== chars+'') || this.charStep != oldStep) {
    this.charCanvas = atlas({
      canvas: this.charCanvas,
      family: 'sans-serif',
      size: charSize,
      shape: [atlasW, atlasH],
      step: [step, step],
      chars: chars,
      align: true
    })
    this.chars = chars
  }
  */

  return this;
};

// Then we assign regl commands directly to the prototype of the class
Scatter.prototype.draw = function () {
  //TODO: make multipass-render here

  //handle gl-plot2d case
  //FIXME: get rid of that once regl-plot2d is available
  if (this.plot) {
    let bounds = this.bounds;
    let dataBox = this.plot.dataBox;
    let viewBox = this.plot.viewBox;

    //hack to support gl-plot2d
    this.regl._refresh();
    this.gl.scissor(viewBox[0], viewBox[1], viewBox[2] - viewBox[0], viewBox[3] - viewBox[1]);
    this.gl.viewport(viewBox[0], viewBox[1], viewBox[2] - viewBox[0], viewBox[3] - viewBox[1]);

    this.scale[0] = 1 / (dataBox[2] - dataBox[0]);
    this.scale[1] = 1 / (dataBox[3] - dataBox[1]);
    this.translate[0] = -dataBox[0];
    this.translate[1] = -dataBox[1];
  }

  this.drawPoints
  // this.drawTest()

  ();return this.pointCount;
};

// adjust scale and transform so to see all the data
Scatter.prototype.autorange = function (positions) {
  if (!positions) positions = this.positions;
  if (!positions || positions.length == 0) return this;

  let bounds = this.bounds;

  let scale = [1 / (bounds[2] - bounds[0]), 1 / (bounds[3] - bounds[1])];

  this.update({
    scale: scale,
    translate: [-bounds[0], -bounds[1]]
  });

  return this;
};

Scatter.prototype.clear = function () {
  this.regl.clear({
    color: [1, 1, 1, 1],
    depth: 1,
    stencil: 0
  });

  return this;
};

Scatter.prototype.pick = function (x, y, value) {
  // return this.draw()
  return null;
};

Scatter.prototype.drawPick = function () {
  return this.pointCount;
};

Scatter.prototype.dispose = function () {
  this.charTexture.destroy();
  this.sizeBuffer.destroy();
  this.positionBuffer.destroy();

  if (this.plot) this.plot.removeObject(this);

  return this;
};

Scatter.prototype.select = function () {
  //TODO: init regl draw here
  return this;
};

//TODO: move to a separate quadtree-based package
function createCluster(points) {
  let scales = snapPoints(points, [], [], []);

  return function getPoints(pixelSize, bounds) {
    for (var scaleNum = scales.length - 1; scaleNum >= 0; scaleNum--) {
      var lod = scales[scaleNum];
      if (lod.pixelSize < pixelSize && scaleNum > 1) continue;

      var range = this.getVisibleRange(lod);
      var startOffset = range[0],
          endOffset = range[1];

      if (endOffset > startOffset) gl.drawArrays(gl.POINTS, startOffset, endOffset - startOffset);

      if (!pick && firstLevel) {
        firstLevel = false;
        shader.uniforms.useWeight = 0;
      }
    }
  };
}

},{"array-bounds":5,"array-normalize":6,"clamp":43,"color-id":46,"color-rgba":49,"font-atlas-sdf":64,"object-assign":116,"regl":133,"snap-points-2d":151}],4:[function(require,module,exports){
var padLeft = require('pad-left');

module.exports = addLineNumbers;
function addLineNumbers(string, start, delim) {
  start = typeof start === 'number' ? start : 1;
  delim = delim || ': ';

  var lines = string.split(/\r?\n/);
  var totalDigits = String(lines.length + start - 1).length;
  return lines.map(function (line, i) {
    var c = i + start;
    var digits = String(c).length;
    var prefix = padLeft(c, totalDigits - digits);
    return prefix + delim + line;
  }).join('\n');
}

},{"pad-left":117}],5:[function(require,module,exports){
'use strict';

module.exports = normalize;

function normalize(arr, dim) {
	if (!arr || arr.length == null) throw Error('Argument should be an array');

	if (dim == null) dim = 1;else dim = Math.floor(dim);

	var bounds = Array(dim * 2);

	for (var offset = 0; offset < dim; offset++) {
		var max = -Infinity,
		    min = Infinity,
		    i = offset,
		    l = arr.length;

		for (; i < l; i += dim) {
			if (arr[i] > max) max = arr[i];
			if (arr[i] < min) min = arr[i];
		}

		bounds[offset] = min;
		bounds[dim + offset] = max;
	}

	return bounds;
}

},{}],6:[function(require,module,exports){
'use strict';

var getBounds = require('array-bounds');

module.exports = normalize;

function normalize(arr, dim, bounds) {
	if (!arr || arr.length == null) throw Error('Argument should be an array');

	if (dim == null) dim = 1;
	if (bounds == null) bounds = getBounds(arr, dim);

	for (var offset = 0; offset < dim; offset++) {
		var max = bounds[dim + offset],
		    min = bounds[offset],
		    i = offset,
		    l = arr.length;

		if (max === Infinity && min === -Infinity) {
			for (i = offset; i < l; i += dim) {
				arr[i] = arr[i] === max ? 1 : arr[i] === min ? 0 : .5;
			}
		} else if (max === Infinity) {
			for (i = offset; i < l; i += dim) {
				arr[i] = arr[i] === max ? 1 : 0;
			}
		} else if (min === -Infinity) {
			for (i = offset; i < l; i += dim) {
				arr[i] = arr[i] === min ? 0 : 1;
			}
		} else {
			var range = max - min;
			for (i = offset; i < l; i += dim) {
				arr[i] = (arr[i] - min) / range;
			}
		}
	}

	return arr;
}

},{"array-bounds":5}],7:[function(require,module,exports){
'use strict';

module.exports = function (val) {
	if (val === null || val === undefined) {
		return [];
	}

	return Array.isArray(val) ? val : [val];
};

},{}],8:[function(require,module,exports){
module.exports = function _atob(str) {
  return atob(str);
};

},{}],9:[function(require,module,exports){
'use strict';

exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;

var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
}

revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;

function placeHoldersCount(b64) {
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;
}

function byteLength(b64) {
  // base64 is 4/3 + up to two characters of the original data
  return b64.length * 3 / 4 - placeHoldersCount(b64);
}

function toByteArray(b64) {
  var i, j, l, tmp, placeHolders, arr;
  var len = b64.length;
  placeHolders = placeHoldersCount(b64);

  arr = new Arr(len * 3 / 4 - placeHolders);

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len;

  var L = 0;

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[L++] = tmp >> 16 & 0xFF;
    arr[L++] = tmp >> 8 & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  if (placeHolders === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[L++] = tmp & 0xFF;
  } else if (placeHolders === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[L++] = tmp >> 8 & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  return arr;
}

function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}

function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
    output.push(tripletToBase64(tmp));
  }
  return output.join('');
}

function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
  var output = '';
  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup[tmp >> 2];
    output += lookup[tmp << 4 & 0x3F];
    output += '==';
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    output += lookup[tmp >> 10];
    output += lookup[tmp >> 4 & 0x3F];
    output += lookup[tmp << 2 & 0x3F];
    output += '=';
  }

  parts.push(output);

  return parts.join('');
}

},{}],10:[function(require,module,exports){
'use strict';

var rationalize = require('./lib/rationalize');

module.exports = add;

function add(a, b) {
  return rationalize(a[0].mul(b[1]).add(b[0].mul(a[1])), a[1].mul(b[1]));
}

},{"./lib/rationalize":20}],11:[function(require,module,exports){
'use strict';

module.exports = cmp;

function cmp(a, b) {
    return a[0].mul(b[1]).cmp(b[0].mul(a[1]));
}

},{}],12:[function(require,module,exports){
'use strict';

var rationalize = require('./lib/rationalize');

module.exports = div;

function div(a, b) {
  return rationalize(a[0].mul(b[1]), a[1].mul(b[0]));
}

},{"./lib/rationalize":20}],13:[function(require,module,exports){
'use strict';

var isRat = require('./is-rat');
var isBN = require('./lib/is-bn');
var num2bn = require('./lib/num-to-bn');
var str2bn = require('./lib/str-to-bn');
var rationalize = require('./lib/rationalize');
var div = require('./div');

module.exports = makeRational;

function makeRational(numer, denom) {
  if (isRat(numer)) {
    if (denom) {
      return div(numer, makeRational(denom));
    }
    return [numer[0].clone(), numer[1].clone()];
  }
  var shift = 0;
  var a, b;
  if (isBN(numer)) {
    a = numer.clone();
  } else if (typeof numer === 'string') {
    a = str2bn(numer);
  } else if (numer === 0) {
    return [num2bn(0), num2bn(1)];
  } else if (numer === Math.floor(numer)) {
    a = num2bn(numer);
  } else {
    while (numer !== Math.floor(numer)) {
      numer = numer * Math.pow(2, 256);
      shift -= 256;
    }
    a = num2bn(numer);
  }
  if (isRat(denom)) {
    a.mul(denom[1]);
    b = denom[0].clone();
  } else if (isBN(denom)) {
    b = denom.clone();
  } else if (typeof denom === 'string') {
    b = str2bn(denom);
  } else if (!denom) {
    b = num2bn(1);
  } else if (denom === Math.floor(denom)) {
    b = num2bn(denom);
  } else {
    while (denom !== Math.floor(denom)) {
      denom = denom * Math.pow(2, 256);
      shift += 256;
    }
    b = num2bn(denom);
  }
  if (shift > 0) {
    a = a.ushln(shift);
  } else if (shift < 0) {
    b = b.ushln(-shift);
  }
  return rationalize(a, b);
}

},{"./div":12,"./is-rat":14,"./lib/is-bn":18,"./lib/num-to-bn":19,"./lib/rationalize":20,"./lib/str-to-bn":21}],14:[function(require,module,exports){
'use strict';

var isBN = require('./lib/is-bn');

module.exports = isRat;

function isRat(x) {
  return Array.isArray(x) && x.length === 2 && isBN(x[0]) && isBN(x[1]);
}

},{"./lib/is-bn":18}],15:[function(require,module,exports){
'use strict';

var BN = require('bn.js');

module.exports = sign;

function sign(x) {
  return x.cmp(new BN(0));
}

},{"bn.js":28}],16:[function(require,module,exports){
'use strict';

var sign = require('./bn-sign');

module.exports = bn2num;

//TODO: Make this better
function bn2num(b) {
  var l = b.length;
  var words = b.words;
  var out = 0;
  if (l === 1) {
    out = words[0];
  } else if (l === 2) {
    out = words[0] + words[1] * 0x4000000;
  } else {
    for (var i = 0; i < l; i++) {
      var w = words[i];
      out += w * Math.pow(0x4000000, i);
    }
  }
  return sign(b) * out;
}

},{"./bn-sign":15}],17:[function(require,module,exports){
'use strict';

var db = require('double-bits');
var ctz = require('bit-twiddle').countTrailingZeros;

module.exports = ctzNumber;

//Counts the number of trailing zeros
function ctzNumber(x) {
  var l = ctz(db.lo(x));
  if (l < 32) {
    return l;
  }
  var h = ctz(db.hi(x));
  if (h > 20) {
    return 52;
  }
  return h + 32;
}

},{"bit-twiddle":27,"double-bits":58}],18:[function(require,module,exports){
'use strict';

var BN = require('bn.js');

module.exports = isBN;

//Test if x is a bignumber
//FIXME: obviously this is the wrong way to do it
function isBN(x) {
  return x && typeof x === 'object' && Boolean(x.words);
}

},{"bn.js":28}],19:[function(require,module,exports){
'use strict';

var BN = require('bn.js');
var db = require('double-bits');

module.exports = num2bn;

function num2bn(x) {
  var e = db.exponent(x);
  if (e < 52) {
    return new BN(x);
  } else {
    return new BN(x * Math.pow(2, 52 - e)).ushln(e - 52);
  }
}

},{"bn.js":28,"double-bits":58}],20:[function(require,module,exports){
'use strict';

var num2bn = require('./num-to-bn');
var sign = require('./bn-sign');

module.exports = rationalize;

function rationalize(numer, denom) {
  var snumer = sign(numer);
  var sdenom = sign(denom);
  if (snumer === 0) {
    return [num2bn(0), num2bn(1)];
  }
  if (sdenom === 0) {
    return [num2bn(0), num2bn(0)];
  }
  if (sdenom < 0) {
    numer = numer.neg();
    denom = denom.neg();
  }
  var d = numer.gcd(denom);
  if (d.cmpn(1)) {
    return [numer.div(d), denom.div(d)];
  }
  return [numer, denom];
}

},{"./bn-sign":15,"./num-to-bn":19}],21:[function(require,module,exports){
'use strict';

var BN = require('bn.js');

module.exports = str2BN;

function str2BN(x) {
  return new BN(x);
}

},{"bn.js":28}],22:[function(require,module,exports){
'use strict';

var rationalize = require('./lib/rationalize');

module.exports = mul;

function mul(a, b) {
  return rationalize(a[0].mul(b[0]), a[1].mul(b[1]));
}

},{"./lib/rationalize":20}],23:[function(require,module,exports){
'use strict';

var bnsign = require('./lib/bn-sign');

module.exports = sign;

function sign(x) {
  return bnsign(x[0]) * bnsign(x[1]);
}

},{"./lib/bn-sign":15}],24:[function(require,module,exports){
'use strict';

var rationalize = require('./lib/rationalize');

module.exports = sub;

function sub(a, b) {
  return rationalize(a[0].mul(b[1]).sub(a[1].mul(b[0])), a[1].mul(b[1]));
}

},{"./lib/rationalize":20}],25:[function(require,module,exports){
'use strict';

var bn2num = require('./lib/bn-to-num');
var ctz = require('./lib/ctz');

module.exports = roundRat;

// Round a rational to the closest float
function roundRat(f) {
  var a = f[0];
  var b = f[1];
  if (a.cmpn(0) === 0) {
    return 0;
  }
  var h = a.abs().divmod(b.abs());
  var iv = h.div;
  var x = bn2num(iv);
  var ir = h.mod;
  var sgn = a.negative !== b.negative ? -1 : 1;
  if (ir.cmpn(0) === 0) {
    return sgn * x;
  }
  if (x) {
    var s = ctz(x) + 4;
    var y = bn2num(ir.ushln(s).divRound(b));
    return sgn * (x + y * Math.pow(2, -s));
  } else {
    var ybits = b.bitLength() - ir.bitLength() + 53;
    var y = bn2num(ir.ushln(ybits).divRound(b));
    if (ybits < 1023) {
      return sgn * y * Math.pow(2, -ybits);
    }
    y *= Math.pow(2, -1023);
    return sgn * y * Math.pow(2, 1023 - ybits);
  }
}

},{"./lib/bn-to-num":16,"./lib/ctz":17}],26:[function(require,module,exports){
"use strict";

function compileSearch(funcName, predicate, reversed, extraArgs, earlyOut) {
  var code = ["function ", funcName, "(a,l,h,", extraArgs.join(","), "){", earlyOut ? "" : "var i=", reversed ? "l-1" : "h+1", ";while(l<=h){\
var m=(l+h)>>>1,x=a[m]"];
  if (earlyOut) {
    if (predicate.indexOf("c") < 0) {
      code.push(";if(x===y){return m}else if(x<=y){");
    } else {
      code.push(";var p=c(x,y);if(p===0){return m}else if(p<=0){");
    }
  } else {
    code.push(";if(", predicate, "){i=m;");
  }
  if (reversed) {
    code.push("l=m+1}else{h=m-1}");
  } else {
    code.push("h=m-1}else{l=m+1}");
  }
  code.push("}");
  if (earlyOut) {
    code.push("return -1};");
  } else {
    code.push("return i};");
  }
  return code.join("");
}

function compileBoundsSearch(predicate, reversed, suffix, earlyOut) {
  var result = new Function([compileSearch("A", "x" + predicate + "y", reversed, ["y"], earlyOut), compileSearch("P", "c(x,y)" + predicate + "0", reversed, ["y", "c"], earlyOut), "function dispatchBsearch", suffix, "(a,y,c,l,h){\
if(typeof(c)==='function'){\
return P(a,(l===void 0)?0:l|0,(h===void 0)?a.length-1:h|0,y,c)\
}else{\
return A(a,(c===void 0)?0:c|0,(l===void 0)?a.length-1:l|0,y)\
}}\
return dispatchBsearch", suffix].join(""));
  return result();
}

module.exports = {
  ge: compileBoundsSearch(">=", false, "GE"),
  gt: compileBoundsSearch(">", false, "GT"),
  lt: compileBoundsSearch("<", true, "LT"),
  le: compileBoundsSearch("<=", true, "LE"),
  eq: compileBoundsSearch("-", true, "EQ", true)
};

},{}],27:[function(require,module,exports){
/**
 * Bit twiddling hacks for JavaScript.
 *
 * Author: Mikola Lysenko
 *
 * Ported from Stanford bit twiddling hack library:
 *    http://graphics.stanford.edu/~seander/bithacks.html
 */

"use strict";"use restrict";

//Number of bits in an integer

var INT_BITS = 32;

//Constants
exports.INT_BITS = INT_BITS;
exports.INT_MAX = 0x7fffffff;
exports.INT_MIN = -1 << INT_BITS - 1;

//Returns -1, 0, +1 depending on sign of x
exports.sign = function (v) {
  return (v > 0) - (v < 0);
};

//Computes absolute value of integer
exports.abs = function (v) {
  var mask = v >> INT_BITS - 1;
  return (v ^ mask) - mask;
};

//Computes minimum of integers x and y
exports.min = function (x, y) {
  return y ^ (x ^ y) & -(x < y);
};

//Computes maximum of integers x and y
exports.max = function (x, y) {
  return x ^ (x ^ y) & -(x < y);
};

//Checks if a number is a power of two
exports.isPow2 = function (v) {
  return !(v & v - 1) && !!v;
};

//Computes log base 2 of v
exports.log2 = function (v) {
  var r, shift;
  r = (v > 0xFFFF) << 4;v >>>= r;
  shift = (v > 0xFF) << 3;v >>>= shift;r |= shift;
  shift = (v > 0xF) << 2;v >>>= shift;r |= shift;
  shift = (v > 0x3) << 1;v >>>= shift;r |= shift;
  return r | v >> 1;
};

//Computes log base 10 of v
exports.log10 = function (v) {
  return v >= 1000000000 ? 9 : v >= 100000000 ? 8 : v >= 10000000 ? 7 : v >= 1000000 ? 6 : v >= 100000 ? 5 : v >= 10000 ? 4 : v >= 1000 ? 3 : v >= 100 ? 2 : v >= 10 ? 1 : 0;
};

//Counts number of bits
exports.popCount = function (v) {
  v = v - (v >>> 1 & 0x55555555);
  v = (v & 0x33333333) + (v >>> 2 & 0x33333333);
  return (v + (v >>> 4) & 0xF0F0F0F) * 0x1010101 >>> 24;
};

//Counts number of trailing zeros
function countTrailingZeros(v) {
  var c = 32;
  v &= -v;
  if (v) c--;
  if (v & 0x0000FFFF) c -= 16;
  if (v & 0x00FF00FF) c -= 8;
  if (v & 0x0F0F0F0F) c -= 4;
  if (v & 0x33333333) c -= 2;
  if (v & 0x55555555) c -= 1;
  return c;
}
exports.countTrailingZeros = countTrailingZeros;

//Rounds to next power of 2
exports.nextPow2 = function (v) {
  v += v === 0;
  --v;
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v + 1;
};

//Rounds down to previous power of 2
exports.prevPow2 = function (v) {
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v - (v >>> 1);
};

//Computes parity of word
exports.parity = function (v) {
  v ^= v >>> 16;
  v ^= v >>> 8;
  v ^= v >>> 4;
  v &= 0xf;
  return 0x6996 >>> v & 1;
};

var REVERSE_TABLE = new Array(256);

(function (tab) {
  for (var i = 0; i < 256; ++i) {
    var v = i,
        r = i,
        s = 7;
    for (v >>>= 1; v; v >>>= 1) {
      r <<= 1;
      r |= v & 1;
      --s;
    }
    tab[i] = r << s & 0xff;
  }
})(REVERSE_TABLE);

//Reverse bits in a 32 bit word
exports.reverse = function (v) {
  return REVERSE_TABLE[v & 0xff] << 24 | REVERSE_TABLE[v >>> 8 & 0xff] << 16 | REVERSE_TABLE[v >>> 16 & 0xff] << 8 | REVERSE_TABLE[v >>> 24 & 0xff];
};

//Interleave bits of 2 coordinates with 16 bits.  Useful for fast quadtree codes
exports.interleave2 = function (x, y) {
  x &= 0xFFFF;
  x = (x | x << 8) & 0x00FF00FF;
  x = (x | x << 4) & 0x0F0F0F0F;
  x = (x | x << 2) & 0x33333333;
  x = (x | x << 1) & 0x55555555;

  y &= 0xFFFF;
  y = (y | y << 8) & 0x00FF00FF;
  y = (y | y << 4) & 0x0F0F0F0F;
  y = (y | y << 2) & 0x33333333;
  y = (y | y << 1) & 0x55555555;

  return x | y << 1;
};

//Extracts the nth interleaved component
exports.deinterleave2 = function (v, n) {
  v = v >>> n & 0x55555555;
  v = (v | v >>> 1) & 0x33333333;
  v = (v | v >>> 2) & 0x0F0F0F0F;
  v = (v | v >>> 4) & 0x00FF00FF;
  v = (v | v >>> 16) & 0x000FFFF;
  return v << 16 >> 16;
};

//Interleave bits of 3 coordinates, each with 10 bits.  Useful for fast octree codes
exports.interleave3 = function (x, y, z) {
  x &= 0x3FF;
  x = (x | x << 16) & 4278190335;
  x = (x | x << 8) & 251719695;
  x = (x | x << 4) & 3272356035;
  x = (x | x << 2) & 1227133513;

  y &= 0x3FF;
  y = (y | y << 16) & 4278190335;
  y = (y | y << 8) & 251719695;
  y = (y | y << 4) & 3272356035;
  y = (y | y << 2) & 1227133513;
  x |= y << 1;

  z &= 0x3FF;
  z = (z | z << 16) & 4278190335;
  z = (z | z << 8) & 251719695;
  z = (z | z << 4) & 3272356035;
  z = (z | z << 2) & 1227133513;

  return x | z << 2;
};

//Extracts nth interleaved component of a 3-tuple
exports.deinterleave3 = function (v, n) {
  v = v >>> n & 1227133513;
  v = (v | v >>> 2) & 3272356035;
  v = (v | v >>> 4) & 251719695;
  v = (v | v >>> 8) & 4278190335;
  v = (v | v >>> 16) & 0x3FF;
  return v << 22 >> 22;
};

//Computes next combination in colexicographic order (this is mistakenly called nextPermutation on the bit twiddling hacks page)
exports.nextCombination = function (v) {
  var t = v | v - 1;
  return t + 1 | (~t & -~t) - 1 >>> countTrailingZeros(v) + 1;
};

},{}],28:[function(require,module,exports){
(function (module, exports) {
  'use strict';

  // Utils

  function assert(val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN(number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    Buffer = require('buf' + 'fer').Buffer;
  } catch (e) {}

  BN.isBN = function isBN(num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max(left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min(left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init(number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
    }

    if (base === 16) {
      this._parseHex(number, start);
    } else {
      this._parseBase(number, base, start);
    }

    if (number[0] === '-') {
      this.negative = 1;
    }

    this.strip();

    if (endian !== 'le') return;

    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initNumber = function _initNumber(number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [number & 0x3ffffff];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [number & 0x3ffffff, number / 0x4000000 & 0x3ffffff];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [number & 0x3ffffff, number / 0x4000000 & 0x3ffffff, 1];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray(number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [0];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
        this.words[j] |= w << off & 0x3ffffff;
        this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
        this.words[j] |= w << off & 0x3ffffff;
        this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this.strip();
  };

  function parseHex(str, start, end) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r <<= 4;

      // 'a' - 'f'
      if (c >= 49 && c <= 54) {
        r |= c - 49 + 0xa;

        // 'A' - 'F'
      } else if (c >= 17 && c <= 22) {
        r |= c - 17 + 0xa;

        // '0' - '9'
      } else {
        r |= c & 0xf;
      }
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex(number, start) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    // Scan 24-bit chunks and add them to the number
    var off = 0;
    for (i = number.length - 6, j = 0; i >= start; i -= 6) {
      w = parseHex(number, i, i + 6);
      this.words[j] |= w << off & 0x3ffffff;
      // NOTE: `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb
      this.words[j + 1] |= w >>> 26 - off & 0x3fffff;
      off += 24;
      if (off >= 26) {
        off -= 26;
        j++;
      }
    }
    if (i + 6 !== start) {
      w = parseHex(number, start, i + 6);
      this.words[j] |= w << off & 0x3ffffff;
      this.words[j + 1] |= w >>> 26 - off & 0x3fffff;
    }
    this.strip();
  };

  function parseBase(str, start, end, mul) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        r += c - 49 + 0xa;

        // 'A'
      } else if (c >= 17) {
        r += c - 17 + 0xa;

        // '0' - '9'
      } else {
        r += c;
      }
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase(number, base, start) {
    // Initialize as zero
    this.words = [0];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = limbPow / base | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }
  };

  BN.prototype.copy = function copy(dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  BN.prototype.clone = function clone() {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand(size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype.strip = function strip() {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign() {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  BN.prototype.inspect = function inspect() {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  };

  /*
   var zeros = [];
  var groupSizes = [];
  var groupBases = [];
   var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }
   */

  var zeros = ['', '0', '00', '000', '0000', '00000', '000000', '0000000', '00000000', '000000000', '0000000000', '00000000000', '000000000000', '0000000000000', '00000000000000', '000000000000000', '0000000000000000', '00000000000000000', '000000000000000000', '0000000000000000000', '00000000000000000000', '000000000000000000000', '0000000000000000000000', '00000000000000000000000', '000000000000000000000000', '0000000000000000000000000'];

  var groupSizes = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5];

  var groupBases = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];

  BN.prototype.toString = function toString(base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = ((w << off | carry) & 0xffffff).toString(16);
        carry = w >>> 24 - off & 0xffffff;
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber() {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + this.words[1] * 0x4000000;
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return this.negative !== 0 ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON() {
    return this.toString(16);
  };

  BN.prototype.toBuffer = function toBuffer(endian, length) {
    assert(typeof Buffer !== 'undefined');
    return this.toArrayLike(Buffer, endian, length);
  };

  BN.prototype.toArray = function toArray(endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    this.strip();
    var littleEndian = endian === 'le';
    var res = new ArrayType(reqLength);

    var b, i;
    var q = this.clone();
    if (!littleEndian) {
      // Assume big-endian
      for (i = 0; i < reqLength - byteLength; i++) {
        res[i] = 0;
      }

      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[reqLength - i - 1] = b;
      }
    } else {
      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[i] = b;
      }

      for (; i < reqLength; i++) {
        res[i] = 0;
      }
    }

    return res;
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits(w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits(w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits(w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength() {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray(num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = bit / 26 | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits() {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength() {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos(width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos(width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg() {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg() {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg() {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor(num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this.strip();
  };

  BN.prototype.ior = function ior(num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or(num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor(num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand(num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this.strip();
  };

  BN.prototype.iand = function iand(num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and(num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand(num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor(num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this.strip();
  };

  BN.prototype.ixor = function ixor(num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor(num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor(num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn(width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & 0x3ffffff >> 26 - bitsLeft;
    }

    // And remove leading zeroes
    return this.strip();
  };

  BN.prototype.notn = function notn(width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn(bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = bit / 26 | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | 1 << wbit;
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this.strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd(num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

      // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
      // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add(num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub(num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

      // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this.strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub(num) {
    return this.clone().isub(num);
  };

  function smallMulTo(self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = self.length + num.length | 0;
    out.length = len;
    len = len - 1 | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = r / 0x4000000 | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += r / 0x4000000 | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out.strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo(self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = mid + Math.imul(ah0, bl0) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = mid + Math.imul(ah1, bl0) | 0;
    hi = Math.imul(ah1, bh0);
    lo = lo + Math.imul(al0, bl1) | 0;
    mid = mid + Math.imul(al0, bh1) | 0;
    mid = mid + Math.imul(ah0, bl1) | 0;
    hi = hi + Math.imul(ah0, bh1) | 0;
    var w1 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = mid + Math.imul(ah2, bl0) | 0;
    hi = Math.imul(ah2, bh0);
    lo = lo + Math.imul(al1, bl1) | 0;
    mid = mid + Math.imul(al1, bh1) | 0;
    mid = mid + Math.imul(ah1, bl1) | 0;
    hi = hi + Math.imul(ah1, bh1) | 0;
    lo = lo + Math.imul(al0, bl2) | 0;
    mid = mid + Math.imul(al0, bh2) | 0;
    mid = mid + Math.imul(ah0, bl2) | 0;
    hi = hi + Math.imul(ah0, bh2) | 0;
    var w2 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = mid + Math.imul(ah3, bl0) | 0;
    hi = Math.imul(ah3, bh0);
    lo = lo + Math.imul(al2, bl1) | 0;
    mid = mid + Math.imul(al2, bh1) | 0;
    mid = mid + Math.imul(ah2, bl1) | 0;
    hi = hi + Math.imul(ah2, bh1) | 0;
    lo = lo + Math.imul(al1, bl2) | 0;
    mid = mid + Math.imul(al1, bh2) | 0;
    mid = mid + Math.imul(ah1, bl2) | 0;
    hi = hi + Math.imul(ah1, bh2) | 0;
    lo = lo + Math.imul(al0, bl3) | 0;
    mid = mid + Math.imul(al0, bh3) | 0;
    mid = mid + Math.imul(ah0, bl3) | 0;
    hi = hi + Math.imul(ah0, bh3) | 0;
    var w3 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = mid + Math.imul(ah4, bl0) | 0;
    hi = Math.imul(ah4, bh0);
    lo = lo + Math.imul(al3, bl1) | 0;
    mid = mid + Math.imul(al3, bh1) | 0;
    mid = mid + Math.imul(ah3, bl1) | 0;
    hi = hi + Math.imul(ah3, bh1) | 0;
    lo = lo + Math.imul(al2, bl2) | 0;
    mid = mid + Math.imul(al2, bh2) | 0;
    mid = mid + Math.imul(ah2, bl2) | 0;
    hi = hi + Math.imul(ah2, bh2) | 0;
    lo = lo + Math.imul(al1, bl3) | 0;
    mid = mid + Math.imul(al1, bh3) | 0;
    mid = mid + Math.imul(ah1, bl3) | 0;
    hi = hi + Math.imul(ah1, bh3) | 0;
    lo = lo + Math.imul(al0, bl4) | 0;
    mid = mid + Math.imul(al0, bh4) | 0;
    mid = mid + Math.imul(ah0, bl4) | 0;
    hi = hi + Math.imul(ah0, bh4) | 0;
    var w4 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = mid + Math.imul(ah5, bl0) | 0;
    hi = Math.imul(ah5, bh0);
    lo = lo + Math.imul(al4, bl1) | 0;
    mid = mid + Math.imul(al4, bh1) | 0;
    mid = mid + Math.imul(ah4, bl1) | 0;
    hi = hi + Math.imul(ah4, bh1) | 0;
    lo = lo + Math.imul(al3, bl2) | 0;
    mid = mid + Math.imul(al3, bh2) | 0;
    mid = mid + Math.imul(ah3, bl2) | 0;
    hi = hi + Math.imul(ah3, bh2) | 0;
    lo = lo + Math.imul(al2, bl3) | 0;
    mid = mid + Math.imul(al2, bh3) | 0;
    mid = mid + Math.imul(ah2, bl3) | 0;
    hi = hi + Math.imul(ah2, bh3) | 0;
    lo = lo + Math.imul(al1, bl4) | 0;
    mid = mid + Math.imul(al1, bh4) | 0;
    mid = mid + Math.imul(ah1, bl4) | 0;
    hi = hi + Math.imul(ah1, bh4) | 0;
    lo = lo + Math.imul(al0, bl5) | 0;
    mid = mid + Math.imul(al0, bh5) | 0;
    mid = mid + Math.imul(ah0, bl5) | 0;
    hi = hi + Math.imul(ah0, bh5) | 0;
    var w5 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = mid + Math.imul(ah6, bl0) | 0;
    hi = Math.imul(ah6, bh0);
    lo = lo + Math.imul(al5, bl1) | 0;
    mid = mid + Math.imul(al5, bh1) | 0;
    mid = mid + Math.imul(ah5, bl1) | 0;
    hi = hi + Math.imul(ah5, bh1) | 0;
    lo = lo + Math.imul(al4, bl2) | 0;
    mid = mid + Math.imul(al4, bh2) | 0;
    mid = mid + Math.imul(ah4, bl2) | 0;
    hi = hi + Math.imul(ah4, bh2) | 0;
    lo = lo + Math.imul(al3, bl3) | 0;
    mid = mid + Math.imul(al3, bh3) | 0;
    mid = mid + Math.imul(ah3, bl3) | 0;
    hi = hi + Math.imul(ah3, bh3) | 0;
    lo = lo + Math.imul(al2, bl4) | 0;
    mid = mid + Math.imul(al2, bh4) | 0;
    mid = mid + Math.imul(ah2, bl4) | 0;
    hi = hi + Math.imul(ah2, bh4) | 0;
    lo = lo + Math.imul(al1, bl5) | 0;
    mid = mid + Math.imul(al1, bh5) | 0;
    mid = mid + Math.imul(ah1, bl5) | 0;
    hi = hi + Math.imul(ah1, bh5) | 0;
    lo = lo + Math.imul(al0, bl6) | 0;
    mid = mid + Math.imul(al0, bh6) | 0;
    mid = mid + Math.imul(ah0, bl6) | 0;
    hi = hi + Math.imul(ah0, bh6) | 0;
    var w6 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = mid + Math.imul(ah7, bl0) | 0;
    hi = Math.imul(ah7, bh0);
    lo = lo + Math.imul(al6, bl1) | 0;
    mid = mid + Math.imul(al6, bh1) | 0;
    mid = mid + Math.imul(ah6, bl1) | 0;
    hi = hi + Math.imul(ah6, bh1) | 0;
    lo = lo + Math.imul(al5, bl2) | 0;
    mid = mid + Math.imul(al5, bh2) | 0;
    mid = mid + Math.imul(ah5, bl2) | 0;
    hi = hi + Math.imul(ah5, bh2) | 0;
    lo = lo + Math.imul(al4, bl3) | 0;
    mid = mid + Math.imul(al4, bh3) | 0;
    mid = mid + Math.imul(ah4, bl3) | 0;
    hi = hi + Math.imul(ah4, bh3) | 0;
    lo = lo + Math.imul(al3, bl4) | 0;
    mid = mid + Math.imul(al3, bh4) | 0;
    mid = mid + Math.imul(ah3, bl4) | 0;
    hi = hi + Math.imul(ah3, bh4) | 0;
    lo = lo + Math.imul(al2, bl5) | 0;
    mid = mid + Math.imul(al2, bh5) | 0;
    mid = mid + Math.imul(ah2, bl5) | 0;
    hi = hi + Math.imul(ah2, bh5) | 0;
    lo = lo + Math.imul(al1, bl6) | 0;
    mid = mid + Math.imul(al1, bh6) | 0;
    mid = mid + Math.imul(ah1, bl6) | 0;
    hi = hi + Math.imul(ah1, bh6) | 0;
    lo = lo + Math.imul(al0, bl7) | 0;
    mid = mid + Math.imul(al0, bh7) | 0;
    mid = mid + Math.imul(ah0, bl7) | 0;
    hi = hi + Math.imul(ah0, bh7) | 0;
    var w7 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = mid + Math.imul(ah8, bl0) | 0;
    hi = Math.imul(ah8, bh0);
    lo = lo + Math.imul(al7, bl1) | 0;
    mid = mid + Math.imul(al7, bh1) | 0;
    mid = mid + Math.imul(ah7, bl1) | 0;
    hi = hi + Math.imul(ah7, bh1) | 0;
    lo = lo + Math.imul(al6, bl2) | 0;
    mid = mid + Math.imul(al6, bh2) | 0;
    mid = mid + Math.imul(ah6, bl2) | 0;
    hi = hi + Math.imul(ah6, bh2) | 0;
    lo = lo + Math.imul(al5, bl3) | 0;
    mid = mid + Math.imul(al5, bh3) | 0;
    mid = mid + Math.imul(ah5, bl3) | 0;
    hi = hi + Math.imul(ah5, bh3) | 0;
    lo = lo + Math.imul(al4, bl4) | 0;
    mid = mid + Math.imul(al4, bh4) | 0;
    mid = mid + Math.imul(ah4, bl4) | 0;
    hi = hi + Math.imul(ah4, bh4) | 0;
    lo = lo + Math.imul(al3, bl5) | 0;
    mid = mid + Math.imul(al3, bh5) | 0;
    mid = mid + Math.imul(ah3, bl5) | 0;
    hi = hi + Math.imul(ah3, bh5) | 0;
    lo = lo + Math.imul(al2, bl6) | 0;
    mid = mid + Math.imul(al2, bh6) | 0;
    mid = mid + Math.imul(ah2, bl6) | 0;
    hi = hi + Math.imul(ah2, bh6) | 0;
    lo = lo + Math.imul(al1, bl7) | 0;
    mid = mid + Math.imul(al1, bh7) | 0;
    mid = mid + Math.imul(ah1, bl7) | 0;
    hi = hi + Math.imul(ah1, bh7) | 0;
    lo = lo + Math.imul(al0, bl8) | 0;
    mid = mid + Math.imul(al0, bh8) | 0;
    mid = mid + Math.imul(ah0, bl8) | 0;
    hi = hi + Math.imul(ah0, bh8) | 0;
    var w8 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = mid + Math.imul(ah9, bl0) | 0;
    hi = Math.imul(ah9, bh0);
    lo = lo + Math.imul(al8, bl1) | 0;
    mid = mid + Math.imul(al8, bh1) | 0;
    mid = mid + Math.imul(ah8, bl1) | 0;
    hi = hi + Math.imul(ah8, bh1) | 0;
    lo = lo + Math.imul(al7, bl2) | 0;
    mid = mid + Math.imul(al7, bh2) | 0;
    mid = mid + Math.imul(ah7, bl2) | 0;
    hi = hi + Math.imul(ah7, bh2) | 0;
    lo = lo + Math.imul(al6, bl3) | 0;
    mid = mid + Math.imul(al6, bh3) | 0;
    mid = mid + Math.imul(ah6, bl3) | 0;
    hi = hi + Math.imul(ah6, bh3) | 0;
    lo = lo + Math.imul(al5, bl4) | 0;
    mid = mid + Math.imul(al5, bh4) | 0;
    mid = mid + Math.imul(ah5, bl4) | 0;
    hi = hi + Math.imul(ah5, bh4) | 0;
    lo = lo + Math.imul(al4, bl5) | 0;
    mid = mid + Math.imul(al4, bh5) | 0;
    mid = mid + Math.imul(ah4, bl5) | 0;
    hi = hi + Math.imul(ah4, bh5) | 0;
    lo = lo + Math.imul(al3, bl6) | 0;
    mid = mid + Math.imul(al3, bh6) | 0;
    mid = mid + Math.imul(ah3, bl6) | 0;
    hi = hi + Math.imul(ah3, bh6) | 0;
    lo = lo + Math.imul(al2, bl7) | 0;
    mid = mid + Math.imul(al2, bh7) | 0;
    mid = mid + Math.imul(ah2, bl7) | 0;
    hi = hi + Math.imul(ah2, bh7) | 0;
    lo = lo + Math.imul(al1, bl8) | 0;
    mid = mid + Math.imul(al1, bh8) | 0;
    mid = mid + Math.imul(ah1, bl8) | 0;
    hi = hi + Math.imul(ah1, bh8) | 0;
    lo = lo + Math.imul(al0, bl9) | 0;
    mid = mid + Math.imul(al0, bh9) | 0;
    mid = mid + Math.imul(ah0, bl9) | 0;
    hi = hi + Math.imul(ah0, bh9) | 0;
    var w9 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = mid + Math.imul(ah9, bl1) | 0;
    hi = Math.imul(ah9, bh1);
    lo = lo + Math.imul(al8, bl2) | 0;
    mid = mid + Math.imul(al8, bh2) | 0;
    mid = mid + Math.imul(ah8, bl2) | 0;
    hi = hi + Math.imul(ah8, bh2) | 0;
    lo = lo + Math.imul(al7, bl3) | 0;
    mid = mid + Math.imul(al7, bh3) | 0;
    mid = mid + Math.imul(ah7, bl3) | 0;
    hi = hi + Math.imul(ah7, bh3) | 0;
    lo = lo + Math.imul(al6, bl4) | 0;
    mid = mid + Math.imul(al6, bh4) | 0;
    mid = mid + Math.imul(ah6, bl4) | 0;
    hi = hi + Math.imul(ah6, bh4) | 0;
    lo = lo + Math.imul(al5, bl5) | 0;
    mid = mid + Math.imul(al5, bh5) | 0;
    mid = mid + Math.imul(ah5, bl5) | 0;
    hi = hi + Math.imul(ah5, bh5) | 0;
    lo = lo + Math.imul(al4, bl6) | 0;
    mid = mid + Math.imul(al4, bh6) | 0;
    mid = mid + Math.imul(ah4, bl6) | 0;
    hi = hi + Math.imul(ah4, bh6) | 0;
    lo = lo + Math.imul(al3, bl7) | 0;
    mid = mid + Math.imul(al3, bh7) | 0;
    mid = mid + Math.imul(ah3, bl7) | 0;
    hi = hi + Math.imul(ah3, bh7) | 0;
    lo = lo + Math.imul(al2, bl8) | 0;
    mid = mid + Math.imul(al2, bh8) | 0;
    mid = mid + Math.imul(ah2, bl8) | 0;
    hi = hi + Math.imul(ah2, bh8) | 0;
    lo = lo + Math.imul(al1, bl9) | 0;
    mid = mid + Math.imul(al1, bh9) | 0;
    mid = mid + Math.imul(ah1, bl9) | 0;
    hi = hi + Math.imul(ah1, bh9) | 0;
    var w10 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = mid + Math.imul(ah9, bl2) | 0;
    hi = Math.imul(ah9, bh2);
    lo = lo + Math.imul(al8, bl3) | 0;
    mid = mid + Math.imul(al8, bh3) | 0;
    mid = mid + Math.imul(ah8, bl3) | 0;
    hi = hi + Math.imul(ah8, bh3) | 0;
    lo = lo + Math.imul(al7, bl4) | 0;
    mid = mid + Math.imul(al7, bh4) | 0;
    mid = mid + Math.imul(ah7, bl4) | 0;
    hi = hi + Math.imul(ah7, bh4) | 0;
    lo = lo + Math.imul(al6, bl5) | 0;
    mid = mid + Math.imul(al6, bh5) | 0;
    mid = mid + Math.imul(ah6, bl5) | 0;
    hi = hi + Math.imul(ah6, bh5) | 0;
    lo = lo + Math.imul(al5, bl6) | 0;
    mid = mid + Math.imul(al5, bh6) | 0;
    mid = mid + Math.imul(ah5, bl6) | 0;
    hi = hi + Math.imul(ah5, bh6) | 0;
    lo = lo + Math.imul(al4, bl7) | 0;
    mid = mid + Math.imul(al4, bh7) | 0;
    mid = mid + Math.imul(ah4, bl7) | 0;
    hi = hi + Math.imul(ah4, bh7) | 0;
    lo = lo + Math.imul(al3, bl8) | 0;
    mid = mid + Math.imul(al3, bh8) | 0;
    mid = mid + Math.imul(ah3, bl8) | 0;
    hi = hi + Math.imul(ah3, bh8) | 0;
    lo = lo + Math.imul(al2, bl9) | 0;
    mid = mid + Math.imul(al2, bh9) | 0;
    mid = mid + Math.imul(ah2, bl9) | 0;
    hi = hi + Math.imul(ah2, bh9) | 0;
    var w11 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = mid + Math.imul(ah9, bl3) | 0;
    hi = Math.imul(ah9, bh3);
    lo = lo + Math.imul(al8, bl4) | 0;
    mid = mid + Math.imul(al8, bh4) | 0;
    mid = mid + Math.imul(ah8, bl4) | 0;
    hi = hi + Math.imul(ah8, bh4) | 0;
    lo = lo + Math.imul(al7, bl5) | 0;
    mid = mid + Math.imul(al7, bh5) | 0;
    mid = mid + Math.imul(ah7, bl5) | 0;
    hi = hi + Math.imul(ah7, bh5) | 0;
    lo = lo + Math.imul(al6, bl6) | 0;
    mid = mid + Math.imul(al6, bh6) | 0;
    mid = mid + Math.imul(ah6, bl6) | 0;
    hi = hi + Math.imul(ah6, bh6) | 0;
    lo = lo + Math.imul(al5, bl7) | 0;
    mid = mid + Math.imul(al5, bh7) | 0;
    mid = mid + Math.imul(ah5, bl7) | 0;
    hi = hi + Math.imul(ah5, bh7) | 0;
    lo = lo + Math.imul(al4, bl8) | 0;
    mid = mid + Math.imul(al4, bh8) | 0;
    mid = mid + Math.imul(ah4, bl8) | 0;
    hi = hi + Math.imul(ah4, bh8) | 0;
    lo = lo + Math.imul(al3, bl9) | 0;
    mid = mid + Math.imul(al3, bh9) | 0;
    mid = mid + Math.imul(ah3, bl9) | 0;
    hi = hi + Math.imul(ah3, bh9) | 0;
    var w12 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = mid + Math.imul(ah9, bl4) | 0;
    hi = Math.imul(ah9, bh4);
    lo = lo + Math.imul(al8, bl5) | 0;
    mid = mid + Math.imul(al8, bh5) | 0;
    mid = mid + Math.imul(ah8, bl5) | 0;
    hi = hi + Math.imul(ah8, bh5) | 0;
    lo = lo + Math.imul(al7, bl6) | 0;
    mid = mid + Math.imul(al7, bh6) | 0;
    mid = mid + Math.imul(ah7, bl6) | 0;
    hi = hi + Math.imul(ah7, bh6) | 0;
    lo = lo + Math.imul(al6, bl7) | 0;
    mid = mid + Math.imul(al6, bh7) | 0;
    mid = mid + Math.imul(ah6, bl7) | 0;
    hi = hi + Math.imul(ah6, bh7) | 0;
    lo = lo + Math.imul(al5, bl8) | 0;
    mid = mid + Math.imul(al5, bh8) | 0;
    mid = mid + Math.imul(ah5, bl8) | 0;
    hi = hi + Math.imul(ah5, bh8) | 0;
    lo = lo + Math.imul(al4, bl9) | 0;
    mid = mid + Math.imul(al4, bh9) | 0;
    mid = mid + Math.imul(ah4, bl9) | 0;
    hi = hi + Math.imul(ah4, bh9) | 0;
    var w13 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = mid + Math.imul(ah9, bl5) | 0;
    hi = Math.imul(ah9, bh5);
    lo = lo + Math.imul(al8, bl6) | 0;
    mid = mid + Math.imul(al8, bh6) | 0;
    mid = mid + Math.imul(ah8, bl6) | 0;
    hi = hi + Math.imul(ah8, bh6) | 0;
    lo = lo + Math.imul(al7, bl7) | 0;
    mid = mid + Math.imul(al7, bh7) | 0;
    mid = mid + Math.imul(ah7, bl7) | 0;
    hi = hi + Math.imul(ah7, bh7) | 0;
    lo = lo + Math.imul(al6, bl8) | 0;
    mid = mid + Math.imul(al6, bh8) | 0;
    mid = mid + Math.imul(ah6, bl8) | 0;
    hi = hi + Math.imul(ah6, bh8) | 0;
    lo = lo + Math.imul(al5, bl9) | 0;
    mid = mid + Math.imul(al5, bh9) | 0;
    mid = mid + Math.imul(ah5, bl9) | 0;
    hi = hi + Math.imul(ah5, bh9) | 0;
    var w14 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = mid + Math.imul(ah9, bl6) | 0;
    hi = Math.imul(ah9, bh6);
    lo = lo + Math.imul(al8, bl7) | 0;
    mid = mid + Math.imul(al8, bh7) | 0;
    mid = mid + Math.imul(ah8, bl7) | 0;
    hi = hi + Math.imul(ah8, bh7) | 0;
    lo = lo + Math.imul(al7, bl8) | 0;
    mid = mid + Math.imul(al7, bh8) | 0;
    mid = mid + Math.imul(ah7, bl8) | 0;
    hi = hi + Math.imul(ah7, bh8) | 0;
    lo = lo + Math.imul(al6, bl9) | 0;
    mid = mid + Math.imul(al6, bh9) | 0;
    mid = mid + Math.imul(ah6, bl9) | 0;
    hi = hi + Math.imul(ah6, bh9) | 0;
    var w15 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = mid + Math.imul(ah9, bl7) | 0;
    hi = Math.imul(ah9, bh7);
    lo = lo + Math.imul(al8, bl8) | 0;
    mid = mid + Math.imul(al8, bh8) | 0;
    mid = mid + Math.imul(ah8, bl8) | 0;
    hi = hi + Math.imul(ah8, bh8) | 0;
    lo = lo + Math.imul(al7, bl9) | 0;
    mid = mid + Math.imul(al7, bh9) | 0;
    mid = mid + Math.imul(ah7, bl9) | 0;
    hi = hi + Math.imul(ah7, bh9) | 0;
    var w16 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = mid + Math.imul(ah9, bl8) | 0;
    hi = Math.imul(ah9, bh8);
    lo = lo + Math.imul(al8, bl9) | 0;
    mid = mid + Math.imul(al8, bh9) | 0;
    mid = mid + Math.imul(ah8, bl9) | 0;
    hi = hi + Math.imul(ah8, bh9) | 0;
    var w17 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = mid + Math.imul(ah9, bl9) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo(self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = ncarry + (r / 0x4000000 | 0) | 0;
        lo = lo + rword | 0;
        rword = lo & 0x3ffffff;
        ncarry = ncarry + (lo >>> 26) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out.strip();
  }

  function jumboMulTo(self, num, out) {
    var fftm = new FFTM();
    return fftm.mulp(self, num, out);
  }

  BN.prototype.mulTo = function mulTo(num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM(x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT(N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin(x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << l - i - 1;
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b(ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 + Math.round(ws[2 * i] / N) + carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff;carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff;carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub(N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp(x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out.strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul(num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf(num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul(num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln(num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += w / 0x4000000 | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return this;
  };

  BN.prototype.muln = function muln(num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr() {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr() {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow(num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln(bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = 0x3ffffff >>> 26 - r << 26 - r;
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = (this.words[i] | 0) - newCarry << r;
        this.words[i] = c | carry;
        carry = newCarry >>> 26 - r;
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this.strip();
  };

  BN.prototype.ishln = function ishln(bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn(bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - hint % 26) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = carry << 26 - r | word >>> r;
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this.strip();
  };

  BN.prototype.ishrn = function ishrn(bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln(bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln(bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn(bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn(bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn(bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn(bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
      this.words[this.length - 1] &= mask;
    }

    return this.strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn(bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn(num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) < num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn(num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn(num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this.strip();
  };

  BN.prototype.addn = function addn(num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn(num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs() {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs() {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - (right / 0x4000000 | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this.strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this.strip();
  };

  BN.prototype._wordDiv = function _wordDiv(num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 + (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min(qj / bhi | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q.strip();
    }
    a.strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod(num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div(num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod(num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod(num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound(num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modn = function modn(num) {
    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return acc;
  };

  // In-place division by number
  BN.prototype.idivn = function idivn(num) {
    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = w / num | 0;
      carry = w % num;
    }

    return this.strip();
  };

  BN.prototype.divn = function divn(num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd(p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp(p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd(num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm(num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven() {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd() {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln(num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn(bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero() {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn(num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this.strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp(num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp(num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn(num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt(num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten(num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte(num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn(num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt(num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten(num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte(num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn(num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq(num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red(num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed(ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed() {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed(ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed(ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd(num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd(num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub(num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub(num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl(num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul(num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul(num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr() {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr() {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt() {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm() {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg() {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow(num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime(name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp() {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce(num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      r.strip();
    }

    return r;
  };

  MPrime.prototype.split = function split(input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK(num) {
    return num.imul(this.k);
  };

  function K256() {
    MPrime.call(this, 'k256', 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split(input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK(num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + (lo / 0x4000000 | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224() {
    MPrime.call(this, 'p224', 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192() {
    MPrime.call(this, 'p192', 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519() {
    // 2 ^ 255 - 19
    MPrime.call(this, '25519', '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK(num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime(name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red(m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1(a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2(a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red, 'red works only with red numbers');
  };

  Red.prototype.imod = function imod(a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    return a.umod(this.m)._forceRed(this);
  };

  Red.prototype.neg = function neg(a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add(a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd(a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub(a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub(a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl(a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul(a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul(a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr(a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr(a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt(a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm(a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow(a, num) {
    if (num.isZero()) return new BN(1);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = word >> j & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo(num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom(num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont(num) {
    return new Mont(num);
  };

  function Mont(m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - this.shift % 26;
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo(num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom(num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul(a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul(a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm(a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})(typeof module === 'undefined' || module, this);

},{}],29:[function(require,module,exports){
'use strict';

module.exports = boxIntersectWrapper;

var pool = require('typedarray-pool');
var sweep = require('./lib/sweep');
var boxIntersectIter = require('./lib/intersect');

function boxEmpty(d, box) {
  for (var j = 0; j < d; ++j) {
    if (!(box[j] <= box[j + d])) {
      return true;
    }
  }
  return false;
}

//Unpack boxes into a flat typed array, remove empty boxes
function convertBoxes(boxes, d, data, ids) {
  var ptr = 0;
  var count = 0;
  for (var i = 0, n = boxes.length; i < n; ++i) {
    var b = boxes[i];
    if (boxEmpty(d, b)) {
      continue;
    }
    for (var j = 0; j < 2 * d; ++j) {
      data[ptr++] = b[j];
    }
    ids[count++] = i;
  }
  return count;
}

//Perform type conversions, check bounds
function boxIntersect(red, blue, visit, full) {
  var n = red.length;
  var m = blue.length;

  //If either array is empty, then we can skip this whole thing
  if (n <= 0 || m <= 0) {
    return;
  }

  //Compute dimension, if it is 0 then we skip
  var d = red[0].length >>> 1;
  if (d <= 0) {
    return;
  }

  var retval;

  //Convert red boxes
  var redList = pool.mallocDouble(2 * d * n);
  var redIds = pool.mallocInt32(n);
  n = convertBoxes(red, d, redList, redIds);

  if (n > 0) {
    if (d === 1 && full) {
      //Special case: 1d complete
      sweep.init(n);
      retval = sweep.sweepComplete(d, visit, 0, n, redList, redIds, 0, n, redList, redIds);
    } else {

      //Convert blue boxes
      var blueList = pool.mallocDouble(2 * d * m);
      var blueIds = pool.mallocInt32(m);
      m = convertBoxes(blue, d, blueList, blueIds);

      if (m > 0) {
        sweep.init(n + m);

        if (d === 1) {
          //Special case: 1d bipartite
          retval = sweep.sweepBipartite(d, visit, 0, n, redList, redIds, 0, m, blueList, blueIds);
        } else {
          //General case:  d>1
          retval = boxIntersectIter(d, visit, full, n, redList, redIds, m, blueList, blueIds);
        }

        pool.free(blueList);
        pool.free(blueIds);
      }
    }

    pool.free(redList);
    pool.free(redIds);
  }

  return retval;
}

var RESULT;

function appendItem(i, j) {
  RESULT.push([i, j]);
}

function intersectFullArray(x) {
  RESULT = [];
  boxIntersect(x, x, appendItem, true);
  return RESULT;
}

function intersectBipartiteArray(x, y) {
  RESULT = [];
  boxIntersect(x, y, appendItem, false);
  return RESULT;
}

//User-friendly wrapper, handle full input and no-visitor cases
function boxIntersectWrapper(arg0, arg1, arg2) {
  var result;
  switch (arguments.length) {
    case 1:
      return intersectFullArray(arg0);
    case 2:
      if (typeof arg1 === 'function') {
        return boxIntersect(arg0, arg0, arg1, true);
      } else {
        return intersectBipartiteArray(arg0, arg1);
      }
    case 3:
      return boxIntersect(arg0, arg1, arg2, false);
    default:
      throw new Error('box-intersect: Invalid arguments');
  }
}

},{"./lib/intersect":31,"./lib/sweep":35,"typedarray-pool":162}],30:[function(require,module,exports){
'use strict';

var DIMENSION = 'd';
var AXIS = 'ax';
var VISIT = 'vv';
var FLIP = 'fp';

var ELEM_SIZE = 'es';

var RED_START = 'rs';
var RED_END = 're';
var RED_BOXES = 'rb';
var RED_INDEX = 'ri';
var RED_PTR = 'rp';

var BLUE_START = 'bs';
var BLUE_END = 'be';
var BLUE_BOXES = 'bb';
var BLUE_INDEX = 'bi';
var BLUE_PTR = 'bp';

var RETVAL = 'rv';

var INNER_LABEL = 'Q';

var ARGS = [DIMENSION, AXIS, VISIT, RED_START, RED_END, RED_BOXES, RED_INDEX, BLUE_START, BLUE_END, BLUE_BOXES, BLUE_INDEX];

function generateBruteForce(redMajor, flip, full) {
  var funcName = 'bruteForce' + (redMajor ? 'Red' : 'Blue') + (flip ? 'Flip' : '') + (full ? 'Full' : '');

  var code = ['function ', funcName, '(', ARGS.join(), '){', 'var ', ELEM_SIZE, '=2*', DIMENSION, ';'];

  var redLoop = 'for(var i=' + RED_START + ',' + RED_PTR + '=' + ELEM_SIZE + '*' + RED_START + ';' + 'i<' + RED_END + ';' + '++i,' + RED_PTR + '+=' + ELEM_SIZE + '){' + 'var x0=' + RED_BOXES + '[' + AXIS + '+' + RED_PTR + '],' + 'x1=' + RED_BOXES + '[' + AXIS + '+' + RED_PTR + '+' + DIMENSION + '],' + 'xi=' + RED_INDEX + '[i];';

  var blueLoop = 'for(var j=' + BLUE_START + ',' + BLUE_PTR + '=' + ELEM_SIZE + '*' + BLUE_START + ';' + 'j<' + BLUE_END + ';' + '++j,' + BLUE_PTR + '+=' + ELEM_SIZE + '){' + 'var y0=' + BLUE_BOXES + '[' + AXIS + '+' + BLUE_PTR + '],' + (full ? 'y1=' + BLUE_BOXES + '[' + AXIS + '+' + BLUE_PTR + '+' + DIMENSION + '],' : '') + 'yi=' + BLUE_INDEX + '[j];';

  if (redMajor) {
    code.push(redLoop, INNER_LABEL, ':', blueLoop);
  } else {
    code.push(blueLoop, INNER_LABEL, ':', redLoop);
  }

  if (full) {
    code.push('if(y1<x0||x1<y0)continue;');
  } else if (flip) {
    code.push('if(y0<=x0||x1<y0)continue;');
  } else {
    code.push('if(y0<x0||x1<y0)continue;');
  }

  code.push('for(var k=' + AXIS + '+1;k<' + DIMENSION + ';++k){' + 'var r0=' + RED_BOXES + '[k+' + RED_PTR + '],' + 'r1=' + RED_BOXES + '[k+' + DIMENSION + '+' + RED_PTR + '],' + 'b0=' + BLUE_BOXES + '[k+' + BLUE_PTR + '],' + 'b1=' + BLUE_BOXES + '[k+' + DIMENSION + '+' + BLUE_PTR + '];' + 'if(r1<b0||b1<r0)continue ' + INNER_LABEL + ';}' + 'var ' + RETVAL + '=' + VISIT + '(');

  if (flip) {
    code.push('yi,xi');
  } else {
    code.push('xi,yi');
  }

  code.push(');if(' + RETVAL + '!==void 0)return ' + RETVAL + ';}}}');

  return {
    name: funcName,
    code: code.join('')
  };
}

function bruteForcePlanner(full) {
  var funcName = 'bruteForce' + (full ? 'Full' : 'Partial');
  var prefix = [];
  var fargs = ARGS.slice();
  if (!full) {
    fargs.splice(3, 0, FLIP);
  }

  var code = ['function ' + funcName + '(' + fargs.join() + '){'];

  function invoke(redMajor, flip) {
    var res = generateBruteForce(redMajor, flip, full);
    prefix.push(res.code);
    code.push('return ' + res.name + '(' + ARGS.join() + ');');
  }

  code.push('if(' + RED_END + '-' + RED_START + '>' + BLUE_END + '-' + BLUE_START + '){');

  if (full) {
    invoke(true, false);
    code.push('}else{');
    invoke(false, false);
  } else {
    code.push('if(' + FLIP + '){');
    invoke(true, true);
    code.push('}else{');
    invoke(true, false);
    code.push('}}else{if(' + FLIP + '){');
    invoke(false, true);
    code.push('}else{');
    invoke(false, false);
    code.push('}');
  }
  code.push('}}return ' + funcName);

  var codeStr = prefix.join('') + code.join('');
  var proc = new Function(codeStr);
  return proc();
}

exports.partial = bruteForcePlanner(false);
exports.full = bruteForcePlanner(true);

},{}],31:[function(require,module,exports){
'use strict';

module.exports = boxIntersectIter;

var pool = require('typedarray-pool');
var bits = require('bit-twiddle');
var bruteForce = require('./brute');
var bruteForcePartial = bruteForce.partial;
var bruteForceFull = bruteForce.full;
var sweep = require('./sweep');
var findMedian = require('./median');
var genPartition = require('./partition'

//Twiddle parameters
);var BRUTE_FORCE_CUTOFF = 128; //Cut off for brute force search
var SCAN_CUTOFF = 1 << 22; //Cut off for two way scan
var SCAN_COMPLETE_CUTOFF = 1 << 22;

//Partition functions
var partitionInteriorContainsInterval = genPartition('!(lo>=p0)&&!(p1>=hi)', ['p0', 'p1']);

var partitionStartEqual = genPartition('lo===p0', ['p0']);

var partitionStartLessThan = genPartition('lo<p0', ['p0']);

var partitionEndLessThanEqual = genPartition('hi<=p0', ['p0']);

var partitionContainsPoint = genPartition('lo<=p0&&p0<=hi', ['p0']);

var partitionContainsPointProper = genPartition('lo<p0&&p0<=hi', ['p0']

//Frame size for iterative loop
);var IFRAME_SIZE = 6;
var DFRAME_SIZE = 2;

//Data for box statck
var INIT_CAPACITY = 1024;
var BOX_ISTACK = pool.mallocInt32(INIT_CAPACITY);
var BOX_DSTACK = pool.mallocDouble(INIT_CAPACITY

//Initialize iterative loop queue
);function iterInit(d, count) {
  var levels = 8 * bits.log2(count + 1) * (d + 1) | 0;
  var maxInts = bits.nextPow2(IFRAME_SIZE * levels);
  if (BOX_ISTACK.length < maxInts) {
    pool.free(BOX_ISTACK);
    BOX_ISTACK = pool.mallocInt32(maxInts);
  }
  var maxDoubles = bits.nextPow2(DFRAME_SIZE * levels);
  if (BOX_DSTACK < maxDoubles) {
    pool.free(BOX_DSTACK);
    BOX_DSTACK = pool.mallocDouble(maxDoubles);
  }
}

//Append item to queue
function iterPush(ptr, axis, redStart, redEnd, blueStart, blueEnd, state, lo, hi) {

  var iptr = IFRAME_SIZE * ptr;
  BOX_ISTACK[iptr] = axis;
  BOX_ISTACK[iptr + 1] = redStart;
  BOX_ISTACK[iptr + 2] = redEnd;
  BOX_ISTACK[iptr + 3] = blueStart;
  BOX_ISTACK[iptr + 4] = blueEnd;
  BOX_ISTACK[iptr + 5] = state;

  var dptr = DFRAME_SIZE * ptr;
  BOX_DSTACK[dptr] = lo;
  BOX_DSTACK[dptr + 1] = hi;
}

//Special case:  Intersect single point with list of intervals
function onePointPartial(d, axis, visit, flip, redStart, redEnd, red, redIndex, blueOffset, blue, blueId) {

  var elemSize = 2 * d;
  var bluePtr = blueOffset * elemSize;
  var blueX = blue[bluePtr + axis];

  red_loop: for (var i = redStart, redPtr = redStart * elemSize; i < redEnd; ++i, redPtr += elemSize) {
    var r0 = red[redPtr + axis];
    var r1 = red[redPtr + axis + d];
    if (blueX < r0 || r1 < blueX) {
      continue;
    }
    if (flip && blueX === r0) {
      continue;
    }
    var redId = redIndex[i];
    for (var j = axis + 1; j < d; ++j) {
      var r0 = red[redPtr + j];
      var r1 = red[redPtr + j + d];
      var b0 = blue[bluePtr + j];
      var b1 = blue[bluePtr + j + d];
      if (r1 < b0 || b1 < r0) {
        continue red_loop;
      }
    }
    var retval;
    if (flip) {
      retval = visit(blueId, redId);
    } else {
      retval = visit(redId, blueId);
    }
    if (retval !== void 0) {
      return retval;
    }
  }
}

//Special case:  Intersect one point with list of intervals
function onePointFull(d, axis, visit, redStart, redEnd, red, redIndex, blueOffset, blue, blueId) {

  var elemSize = 2 * d;
  var bluePtr = blueOffset * elemSize;
  var blueX = blue[bluePtr + axis];

  red_loop: for (var i = redStart, redPtr = redStart * elemSize; i < redEnd; ++i, redPtr += elemSize) {
    var redId = redIndex[i];
    if (redId === blueId) {
      continue;
    }
    var r0 = red[redPtr + axis];
    var r1 = red[redPtr + axis + d];
    if (blueX < r0 || r1 < blueX) {
      continue;
    }
    for (var j = axis + 1; j < d; ++j) {
      var r0 = red[redPtr + j];
      var r1 = red[redPtr + j + d];
      var b0 = blue[bluePtr + j];
      var b1 = blue[bluePtr + j + d];
      if (r1 < b0 || b1 < r0) {
        continue red_loop;
      }
    }
    var retval = visit(redId, blueId);
    if (retval !== void 0) {
      return retval;
    }
  }
}

//The main box intersection routine
function boxIntersectIter(d, visit, initFull, xSize, xBoxes, xIndex, ySize, yBoxes, yIndex) {

  //Reserve memory for stack
  iterInit(d, xSize + ySize);

  var top = 0;
  var elemSize = 2 * d;
  var retval;

  iterPush(top++, 0, 0, xSize, 0, ySize, initFull ? 16 : 0, -Infinity, Infinity);
  if (!initFull) {
    iterPush(top++, 0, 0, ySize, 0, xSize, 1, -Infinity, Infinity);
  }

  while (top > 0) {
    top -= 1;

    var iptr = top * IFRAME_SIZE;
    var axis = BOX_ISTACK[iptr];
    var redStart = BOX_ISTACK[iptr + 1];
    var redEnd = BOX_ISTACK[iptr + 2];
    var blueStart = BOX_ISTACK[iptr + 3];
    var blueEnd = BOX_ISTACK[iptr + 4];
    var state = BOX_ISTACK[iptr + 5];

    var dptr = top * DFRAME_SIZE;
    var lo = BOX_DSTACK[dptr];
    var hi = BOX_DSTACK[dptr + 1];

    //Unpack state info
    var flip = state & 1;
    var full = !!(state & 16);

    //Unpack indices
    var red = xBoxes;
    var redIndex = xIndex;
    var blue = yBoxes;
    var blueIndex = yIndex;
    if (flip) {
      red = yBoxes;
      redIndex = yIndex;
      blue = xBoxes;
      blueIndex = xIndex;
    }

    if (state & 2) {
      redEnd = partitionStartLessThan(d, axis, redStart, redEnd, red, redIndex, hi);
      if (redStart >= redEnd) {
        continue;
      }
    }
    if (state & 4) {
      redStart = partitionEndLessThanEqual(d, axis, redStart, redEnd, red, redIndex, lo);
      if (redStart >= redEnd) {
        continue;
      }
    }

    var redCount = redEnd - redStart;
    var blueCount = blueEnd - blueStart;

    if (full) {
      if (d * redCount * (redCount + blueCount) < SCAN_COMPLETE_CUTOFF) {
        retval = sweep.scanComplete(d, axis, visit, redStart, redEnd, red, redIndex, blueStart, blueEnd, blue, blueIndex);
        if (retval !== void 0) {
          return retval;
        }
        continue;
      }
    } else {
      if (d * Math.min(redCount, blueCount) < BRUTE_FORCE_CUTOFF) {
        //If input small, then use brute force
        retval = bruteForcePartial(d, axis, visit, flip, redStart, redEnd, red, redIndex, blueStart, blueEnd, blue, blueIndex);
        if (retval !== void 0) {
          return retval;
        }
        continue;
      } else if (d * redCount * blueCount < SCAN_CUTOFF) {
        //If input medium sized, then use sweep and prune
        retval = sweep.scanBipartite(d, axis, visit, flip, redStart, redEnd, red, redIndex, blueStart, blueEnd, blue, blueIndex);
        if (retval !== void 0) {
          return retval;
        }
        continue;
      }
    }

    //First, find all red intervals whose interior contains (lo,hi)
    var red0 = partitionInteriorContainsInterval(d, axis, redStart, redEnd, red, redIndex, lo, hi

    //Lower dimensional case
    );if (redStart < red0) {

      if (d * (red0 - redStart) < BRUTE_FORCE_CUTOFF) {
        //Special case for small inputs: use brute force
        retval = bruteForceFull(d, axis + 1, visit, redStart, red0, red, redIndex, blueStart, blueEnd, blue, blueIndex);
        if (retval !== void 0) {
          return retval;
        }
      } else if (axis === d - 2) {
        if (flip) {
          retval = sweep.sweepBipartite(d, visit, blueStart, blueEnd, blue, blueIndex, redStart, red0, red, redIndex);
        } else {
          retval = sweep.sweepBipartite(d, visit, redStart, red0, red, redIndex, blueStart, blueEnd, blue, blueIndex);
        }
        if (retval !== void 0) {
          return retval;
        }
      } else {
        iterPush(top++, axis + 1, redStart, red0, blueStart, blueEnd, flip, -Infinity, Infinity);
        iterPush(top++, axis + 1, blueStart, blueEnd, redStart, red0, flip ^ 1, -Infinity, Infinity);
      }
    }

    //Divide and conquer phase
    if (red0 < redEnd) {

      //Cut blue into 3 parts:
      //
      //  Points < mid point
      //  Points = mid point
      //  Points > mid point
      //
      var blue0 = findMedian(d, axis, blueStart, blueEnd, blue, blueIndex);
      var mid = blue[elemSize * blue0 + axis];
      var blue1 = partitionStartEqual(d, axis, blue0, blueEnd, blue, blueIndex, mid

      //Right case
      );if (blue1 < blueEnd) {
        iterPush(top++, axis, red0, redEnd, blue1, blueEnd, (flip | 4) + (full ? 16 : 0), mid, hi);
      }

      //Left case
      if (blueStart < blue0) {
        iterPush(top++, axis, red0, redEnd, blueStart, blue0, (flip | 2) + (full ? 16 : 0), lo, mid);
      }

      //Center case (the hard part)
      if (blue0 + 1 === blue1) {
        //Optimization: Range with exactly 1 point, use a brute force scan
        if (full) {
          retval = onePointFull(d, axis, visit, red0, redEnd, red, redIndex, blue0, blue, blueIndex[blue0]);
        } else {
          retval = onePointPartial(d, axis, visit, flip, red0, redEnd, red, redIndex, blue0, blue, blueIndex[blue0]);
        }
        if (retval !== void 0) {
          return retval;
        }
      } else if (blue0 < blue1) {
        var red1;
        if (full) {
          //If full intersection, need to handle special case
          red1 = partitionContainsPoint(d, axis, red0, redEnd, red, redIndex, mid);
          if (red0 < red1) {
            var redX = partitionStartEqual(d, axis, red0, red1, red, redIndex, mid);
            if (axis === d - 2) {
              //Degenerate sweep intersection:
              //  [red0, redX] with [blue0, blue1]
              if (red0 < redX) {
                retval = sweep.sweepComplete(d, visit, red0, redX, red, redIndex, blue0, blue1, blue, blueIndex);
                if (retval !== void 0) {
                  return retval;
                }
              }

              //Normal sweep intersection:
              //  [redX, red1] with [blue0, blue1]
              if (redX < red1) {
                retval = sweep.sweepBipartite(d, visit, redX, red1, red, redIndex, blue0, blue1, blue, blueIndex);
                if (retval !== void 0) {
                  return retval;
                }
              }
            } else {
              if (red0 < redX) {
                iterPush(top++, axis + 1, red0, redX, blue0, blue1, 16, -Infinity, Infinity);
              }
              if (redX < red1) {
                iterPush(top++, axis + 1, redX, red1, blue0, blue1, 0, -Infinity, Infinity);
                iterPush(top++, axis + 1, blue0, blue1, redX, red1, 1, -Infinity, Infinity);
              }
            }
          }
        } else {
          if (flip) {
            red1 = partitionContainsPointProper(d, axis, red0, redEnd, red, redIndex, mid);
          } else {
            red1 = partitionContainsPoint(d, axis, red0, redEnd, red, redIndex, mid);
          }
          if (red0 < red1) {
            if (axis === d - 2) {
              if (flip) {
                retval = sweep.sweepBipartite(d, visit, blue0, blue1, blue, blueIndex, red0, red1, red, redIndex);
              } else {
                retval = sweep.sweepBipartite(d, visit, red0, red1, red, redIndex, blue0, blue1, blue, blueIndex);
              }
            } else {
              iterPush(top++, axis + 1, red0, red1, blue0, blue1, flip, -Infinity, Infinity);
              iterPush(top++, axis + 1, blue0, blue1, red0, red1, flip ^ 1, -Infinity, Infinity);
            }
          }
        }
      }
    }
  }
}

},{"./brute":30,"./median":32,"./partition":33,"./sweep":35,"bit-twiddle":27,"typedarray-pool":162}],32:[function(require,module,exports){
'use strict';

module.exports = findMedian;

var genPartition = require('./partition');

var partitionStartLessThan = genPartition('lo<p0', ['p0']);

var PARTITION_THRESHOLD = 8; //Cut off for using insertion sort in findMedian

//Base case for median finding:  Use insertion sort
function insertionSort(d, axis, start, end, boxes, ids) {
  var elemSize = 2 * d;
  var boxPtr = elemSize * (start + 1) + axis;
  for (var i = start + 1; i < end; ++i, boxPtr += elemSize) {
    var x = boxes[boxPtr];
    for (var j = i, ptr = elemSize * (i - 1); j > start && boxes[ptr + axis] > x; --j, ptr -= elemSize) {
      //Swap
      var aPtr = ptr;
      var bPtr = ptr + elemSize;
      for (var k = 0; k < elemSize; ++k, ++aPtr, ++bPtr) {
        var y = boxes[aPtr];
        boxes[aPtr] = boxes[bPtr];
        boxes[bPtr] = y;
      }
      var tmp = ids[j];
      ids[j] = ids[j - 1];
      ids[j - 1] = tmp;
    }
  }
}

//Find median using quick select algorithm
//  takes O(n) time with high probability
function findMedian(d, axis, start, end, boxes, ids) {
  if (end <= start + 1) {
    return start;
  }

  var lo = start;
  var hi = end;
  var mid = end + start >>> 1;
  var elemSize = 2 * d;
  var pivot = mid;
  var value = boxes[elemSize * mid + axis];

  while (lo < hi) {
    if (hi - lo < PARTITION_THRESHOLD) {
      insertionSort(d, axis, lo, hi, boxes, ids);
      value = boxes[elemSize * mid + axis];
      break;
    }

    //Select pivot using median-of-3
    var count = hi - lo;
    var pivot0 = Math.random() * count + lo | 0;
    var value0 = boxes[elemSize * pivot0 + axis];
    var pivot1 = Math.random() * count + lo | 0;
    var value1 = boxes[elemSize * pivot1 + axis];
    var pivot2 = Math.random() * count + lo | 0;
    var value2 = boxes[elemSize * pivot2 + axis];
    if (value0 <= value1) {
      if (value2 >= value1) {
        pivot = pivot1;
        value = value1;
      } else if (value0 >= value2) {
        pivot = pivot0;
        value = value0;
      } else {
        pivot = pivot2;
        value = value2;
      }
    } else {
      if (value1 >= value2) {
        pivot = pivot1;
        value = value1;
      } else if (value2 >= value0) {
        pivot = pivot0;
        value = value0;
      } else {
        pivot = pivot2;
        value = value2;
      }
    }

    //Swap pivot to end of array
    var aPtr = elemSize * (hi - 1);
    var bPtr = elemSize * pivot;
    for (var i = 0; i < elemSize; ++i, ++aPtr, ++bPtr) {
      var x = boxes[aPtr];
      boxes[aPtr] = boxes[bPtr];
      boxes[bPtr] = x;
    }
    var y = ids[hi - 1];
    ids[hi - 1] = ids[pivot];
    ids[pivot] = y;

    //Partition using pivot
    pivot = partitionStartLessThan(d, axis, lo, hi - 1, boxes, ids, value

    //Swap pivot back
    );var aPtr = elemSize * (hi - 1);
    var bPtr = elemSize * pivot;
    for (var i = 0; i < elemSize; ++i, ++aPtr, ++bPtr) {
      var x = boxes[aPtr];
      boxes[aPtr] = boxes[bPtr];
      boxes[bPtr] = x;
    }
    var y = ids[hi - 1];
    ids[hi - 1] = ids[pivot];
    ids[pivot] = y;

    //Swap pivot to last pivot
    if (mid < pivot) {
      hi = pivot - 1;
      while (lo < hi && boxes[elemSize * (hi - 1) + axis] === value) {
        hi -= 1;
      }
      hi += 1;
    } else if (pivot < mid) {
      lo = pivot + 1;
      while (lo < hi && boxes[elemSize * lo + axis] === value) {
        lo += 1;
      }
    } else {
      break;
    }
  }

  //Make sure pivot is at start
  return partitionStartLessThan(d, axis, start, mid, boxes, ids, boxes[elemSize * mid + axis]);
}

},{"./partition":33}],33:[function(require,module,exports){
'use strict';

module.exports = genPartition;

var code = 'for(var j=2*a,k=j*c,l=k,m=c,n=b,o=a+b,p=c;d>p;++p,k+=j){var _;if($)if(m===p)m+=1,l+=j;else{for(var s=0;j>s;++s){var t=e[k+s];e[k+s]=e[l],e[l++]=t}var u=f[p];f[p]=f[m],f[m++]=u}}return m';

function genPartition(predicate, args) {
  var fargs = 'abcdef'.split('').concat(args);
  var reads = [];
  if (predicate.indexOf('lo') >= 0) {
    reads.push('lo=e[k+n]');
  }
  if (predicate.indexOf('hi') >= 0) {
    reads.push('hi=e[k+o]');
  }
  fargs.push(code.replace('_', reads.join()).replace('$', predicate));
  return Function.apply(void 0, fargs);
}

},{}],34:[function(require,module,exports){
'use strict';

//This code is extracted from ndarray-sort
//It is inlined here as a temporary workaround

module.exports = wrapper;

var INSERT_SORT_CUTOFF = 32;

function wrapper(data, n0) {
  if (n0 <= 4 * INSERT_SORT_CUTOFF) {
    insertionSort(0, n0 - 1, data);
  } else {
    quickSort(0, n0 - 1, data);
  }
}

function insertionSort(left, right, data) {
  var ptr = 2 * (left + 1);
  for (var i = left + 1; i <= right; ++i) {
    var a = data[ptr++];
    var b = data[ptr++];
    var j = i;
    var jptr = ptr - 2;
    while (j-- > left) {
      var x = data[jptr - 2];
      var y = data[jptr - 1];
      if (x < a) {
        break;
      } else if (x === a && y < b) {
        break;
      }
      data[jptr] = x;
      data[jptr + 1] = y;
      jptr -= 2;
    }
    data[jptr] = a;
    data[jptr + 1] = b;
  }
}

function swap(i, j, data) {
  i *= 2;
  j *= 2;
  var x = data[i];
  var y = data[i + 1];
  data[i] = data[j];
  data[i + 1] = data[j + 1];
  data[j] = x;
  data[j + 1] = y;
}

function move(i, j, data) {
  i *= 2;
  j *= 2;
  data[i] = data[j];
  data[i + 1] = data[j + 1];
}

function rotate(i, j, k, data) {
  i *= 2;
  j *= 2;
  k *= 2;
  var x = data[i];
  var y = data[i + 1];
  data[i] = data[j];
  data[i + 1] = data[j + 1];
  data[j] = data[k];
  data[j + 1] = data[k + 1];
  data[k] = x;
  data[k + 1] = y;
}

function shufflePivot(i, j, px, py, data) {
  i *= 2;
  j *= 2;
  data[i] = data[j];
  data[j] = px;
  data[i + 1] = data[j + 1];
  data[j + 1] = py;
}

function compare(i, j, data) {
  i *= 2;
  j *= 2;
  var x = data[i],
      y = data[j];
  if (x < y) {
    return false;
  } else if (x === y) {
    return data[i + 1] > data[j + 1];
  }
  return true;
}

function comparePivot(i, y, b, data) {
  i *= 2;
  var x = data[i];
  if (x < y) {
    return true;
  } else if (x === y) {
    return data[i + 1] < b;
  }
  return false;
}

function quickSort(left, right, data) {
  var sixth = (right - left + 1) / 6 | 0,
      index1 = left + sixth,
      index5 = right - sixth,
      index3 = left + right >> 1,
      index2 = index3 - sixth,
      index4 = index3 + sixth,
      el1 = index1,
      el2 = index2,
      el3 = index3,
      el4 = index4,
      el5 = index5,
      less = left + 1,
      great = right - 1,
      tmp = 0;
  if (compare(el1, el2, data)) {
    tmp = el1;
    el1 = el2;
    el2 = tmp;
  }
  if (compare(el4, el5, data)) {
    tmp = el4;
    el4 = el5;
    el5 = tmp;
  }
  if (compare(el1, el3, data)) {
    tmp = el1;
    el1 = el3;
    el3 = tmp;
  }
  if (compare(el2, el3, data)) {
    tmp = el2;
    el2 = el3;
    el3 = tmp;
  }
  if (compare(el1, el4, data)) {
    tmp = el1;
    el1 = el4;
    el4 = tmp;
  }
  if (compare(el3, el4, data)) {
    tmp = el3;
    el3 = el4;
    el4 = tmp;
  }
  if (compare(el2, el5, data)) {
    tmp = el2;
    el2 = el5;
    el5 = tmp;
  }
  if (compare(el2, el3, data)) {
    tmp = el2;
    el2 = el3;
    el3 = tmp;
  }
  if (compare(el4, el5, data)) {
    tmp = el4;
    el4 = el5;
    el5 = tmp;
  }

  var pivot1X = data[2 * el2];
  var pivot1Y = data[2 * el2 + 1];
  var pivot2X = data[2 * el4];
  var pivot2Y = data[2 * el4 + 1];

  var ptr0 = 2 * el1;
  var ptr2 = 2 * el3;
  var ptr4 = 2 * el5;
  var ptr5 = 2 * index1;
  var ptr6 = 2 * index3;
  var ptr7 = 2 * index5;
  for (var i1 = 0; i1 < 2; ++i1) {
    var x = data[ptr0 + i1];
    var y = data[ptr2 + i1];
    var z = data[ptr4 + i1];
    data[ptr5 + i1] = x;
    data[ptr6 + i1] = y;
    data[ptr7 + i1] = z;
  }

  move(index2, left, data);
  move(index4, right, data);
  for (var k = less; k <= great; ++k) {
    if (comparePivot(k, pivot1X, pivot1Y, data)) {
      if (k !== less) {
        swap(k, less, data);
      }
      ++less;
    } else {
      if (!comparePivot(k, pivot2X, pivot2Y, data)) {
        while (true) {
          if (!comparePivot(great, pivot2X, pivot2Y, data)) {
            if (--great < k) {
              break;
            }
            continue;
          } else {
            if (comparePivot(great, pivot1X, pivot1Y, data)) {
              rotate(k, less, great, data);
              ++less;
              --great;
            } else {
              swap(k, great, data);
              --great;
            }
            break;
          }
        }
      }
    }
  }
  shufflePivot(left, less - 1, pivot1X, pivot1Y, data);
  shufflePivot(right, great + 1, pivot2X, pivot2Y, data);
  if (less - 2 - left <= INSERT_SORT_CUTOFF) {
    insertionSort(left, less - 2, data);
  } else {
    quickSort(left, less - 2, data);
  }
  if (right - (great + 2) <= INSERT_SORT_CUTOFF) {
    insertionSort(great + 2, right, data);
  } else {
    quickSort(great + 2, right, data);
  }
  if (great - less <= INSERT_SORT_CUTOFF) {
    insertionSort(less, great, data);
  } else {
    quickSort(less, great, data);
  }
}

},{}],35:[function(require,module,exports){
'use strict';

module.exports = {
  init: sqInit,
  sweepBipartite: sweepBipartite,
  sweepComplete: sweepComplete,
  scanBipartite: scanBipartite,
  scanComplete: scanComplete
};

var pool = require('typedarray-pool');
var bits = require('bit-twiddle');
var isort = require('./sort'

//Flag for blue
);var BLUE_FLAG = 1 << 28;

//1D sweep event queue stuff (use pool to save space)
var INIT_CAPACITY = 1024;
var RED_SWEEP_QUEUE = pool.mallocInt32(INIT_CAPACITY);
var RED_SWEEP_INDEX = pool.mallocInt32(INIT_CAPACITY);
var BLUE_SWEEP_QUEUE = pool.mallocInt32(INIT_CAPACITY);
var BLUE_SWEEP_INDEX = pool.mallocInt32(INIT_CAPACITY);
var COMMON_SWEEP_QUEUE = pool.mallocInt32(INIT_CAPACITY);
var COMMON_SWEEP_INDEX = pool.mallocInt32(INIT_CAPACITY);
var SWEEP_EVENTS = pool.mallocDouble(INIT_CAPACITY * 8

//Reserves memory for the 1D sweep data structures
);function sqInit(count) {
  var rcount = bits.nextPow2(count);
  if (RED_SWEEP_QUEUE.length < rcount) {
    pool.free(RED_SWEEP_QUEUE);
    RED_SWEEP_QUEUE = pool.mallocInt32(rcount);
  }
  if (RED_SWEEP_INDEX.length < rcount) {
    pool.free(RED_SWEEP_INDEX);
    RED_SWEEP_INDEX = pool.mallocInt32(rcount);
  }
  if (BLUE_SWEEP_QUEUE.length < rcount) {
    pool.free(BLUE_SWEEP_QUEUE);
    BLUE_SWEEP_QUEUE = pool.mallocInt32(rcount);
  }
  if (BLUE_SWEEP_INDEX.length < rcount) {
    pool.free(BLUE_SWEEP_INDEX);
    BLUE_SWEEP_INDEX = pool.mallocInt32(rcount);
  }
  if (COMMON_SWEEP_QUEUE.length < rcount) {
    pool.free(COMMON_SWEEP_QUEUE);
    COMMON_SWEEP_QUEUE = pool.mallocInt32(rcount);
  }
  if (COMMON_SWEEP_INDEX.length < rcount) {
    pool.free(COMMON_SWEEP_INDEX);
    COMMON_SWEEP_INDEX = pool.mallocInt32(rcount);
  }
  var eventLength = 8 * rcount;
  if (SWEEP_EVENTS.length < eventLength) {
    pool.free(SWEEP_EVENTS);
    SWEEP_EVENTS = pool.mallocDouble(eventLength);
  }
}

//Remove an item from the active queue in O(1)
function sqPop(queue, index, count, item) {
  var idx = index[item];
  var top = queue[count - 1];
  queue[idx] = top;
  index[top] = idx;
}

//Insert an item into the active queue in O(1)
function sqPush(queue, index, count, item) {
  queue[count] = item;
  index[item] = count;
}

//Recursion base case: use 1D sweep algorithm
function sweepBipartite(d, visit, redStart, redEnd, red, redIndex, blueStart, blueEnd, blue, blueIndex) {

  //store events as pairs [coordinate, idx]
  //
  //  red create:  -(idx+1)
  //  red destroy: idx
  //  blue create: -(idx+BLUE_FLAG)
  //  blue destroy: idx+BLUE_FLAG
  //
  var ptr = 0;
  var elemSize = 2 * d;
  var istart = d - 1;
  var iend = elemSize - 1;

  for (var i = redStart; i < redEnd; ++i) {
    var idx = redIndex[i];
    var redOffset = elemSize * i;
    SWEEP_EVENTS[ptr++] = red[redOffset + istart];
    SWEEP_EVENTS[ptr++] = -(idx + 1);
    SWEEP_EVENTS[ptr++] = red[redOffset + iend];
    SWEEP_EVENTS[ptr++] = idx;
  }

  for (var i = blueStart; i < blueEnd; ++i) {
    var idx = blueIndex[i] + BLUE_FLAG;
    var blueOffset = elemSize * i;
    SWEEP_EVENTS[ptr++] = blue[blueOffset + istart];
    SWEEP_EVENTS[ptr++] = -idx;
    SWEEP_EVENTS[ptr++] = blue[blueOffset + iend];
    SWEEP_EVENTS[ptr++] = idx;
  }

  //process events from left->right
  var n = ptr >>> 1;
  isort(SWEEP_EVENTS, n);

  var redActive = 0;
  var blueActive = 0;
  for (var i = 0; i < n; ++i) {
    var e = SWEEP_EVENTS[2 * i + 1] | 0;
    if (e >= BLUE_FLAG) {
      //blue destroy event
      e = e - BLUE_FLAG | 0;
      sqPop(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive--, e);
    } else if (e >= 0) {
      //red destroy event
      sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, e);
    } else if (e <= -BLUE_FLAG) {
      //blue create event
      e = -e - BLUE_FLAG | 0;
      for (var j = 0; j < redActive; ++j) {
        var retval = visit(RED_SWEEP_QUEUE[j], e);
        if (retval !== void 0) {
          return retval;
        }
      }
      sqPush(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive++, e);
    } else {
      //red create event
      e = -e - 1 | 0;
      for (var j = 0; j < blueActive; ++j) {
        var retval = visit(e, BLUE_SWEEP_QUEUE[j]);
        if (retval !== void 0) {
          return retval;
        }
      }
      sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, e);
    }
  }
}

//Complete sweep
function sweepComplete(d, visit, redStart, redEnd, red, redIndex, blueStart, blueEnd, blue, blueIndex) {

  var ptr = 0;
  var elemSize = 2 * d;
  var istart = d - 1;
  var iend = elemSize - 1;

  for (var i = redStart; i < redEnd; ++i) {
    var idx = redIndex[i] + 1 << 1;
    var redOffset = elemSize * i;
    SWEEP_EVENTS[ptr++] = red[redOffset + istart];
    SWEEP_EVENTS[ptr++] = -idx;
    SWEEP_EVENTS[ptr++] = red[redOffset + iend];
    SWEEP_EVENTS[ptr++] = idx;
  }

  for (var i = blueStart; i < blueEnd; ++i) {
    var idx = blueIndex[i] + 1 << 1;
    var blueOffset = elemSize * i;
    SWEEP_EVENTS[ptr++] = blue[blueOffset + istart];
    SWEEP_EVENTS[ptr++] = -idx | 1;
    SWEEP_EVENTS[ptr++] = blue[blueOffset + iend];
    SWEEP_EVENTS[ptr++] = idx | 1;
  }

  //process events from left->right
  var n = ptr >>> 1;
  isort(SWEEP_EVENTS, n);

  var redActive = 0;
  var blueActive = 0;
  var commonActive = 0;
  for (var i = 0; i < n; ++i) {
    var e = SWEEP_EVENTS[2 * i + 1] | 0;
    var color = e & 1;
    if (i < n - 1 && e >> 1 === SWEEP_EVENTS[2 * i + 3] >> 1) {
      color = 2;
      i += 1;
    }

    if (e < 0) {
      //Create event
      var id = -(e >> 1) - 1;

      //Intersect with common
      for (var j = 0; j < commonActive; ++j) {
        var retval = visit(COMMON_SWEEP_QUEUE[j], id);
        if (retval !== void 0) {
          return retval;
        }
      }

      if (color !== 0) {
        //Intersect with red
        for (var j = 0; j < redActive; ++j) {
          var retval = visit(RED_SWEEP_QUEUE[j], id);
          if (retval !== void 0) {
            return retval;
          }
        }
      }

      if (color !== 1) {
        //Intersect with blue
        for (var j = 0; j < blueActive; ++j) {
          var retval = visit(BLUE_SWEEP_QUEUE[j], id);
          if (retval !== void 0) {
            return retval;
          }
        }
      }

      if (color === 0) {
        //Red
        sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, id);
      } else if (color === 1) {
        //Blue
        sqPush(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive++, id);
      } else if (color === 2) {
        //Both
        sqPush(COMMON_SWEEP_QUEUE, COMMON_SWEEP_INDEX, commonActive++, id);
      }
    } else {
      //Destroy event
      var id = (e >> 1) - 1;
      if (color === 0) {
        //Red
        sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, id);
      } else if (color === 1) {
        //Blue
        sqPop(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive--, id);
      } else if (color === 2) {
        //Both
        sqPop(COMMON_SWEEP_QUEUE, COMMON_SWEEP_INDEX, commonActive--, id);
      }
    }
  }
}

//Sweep and prune/scanline algorithm:
//  Scan along axis, detect intersections
//  Brute force all boxes along axis
function scanBipartite(d, axis, visit, flip, redStart, redEnd, red, redIndex, blueStart, blueEnd, blue, blueIndex) {

  var ptr = 0;
  var elemSize = 2 * d;
  var istart = axis;
  var iend = axis + d;

  var redShift = 1;
  var blueShift = 1;
  if (flip) {
    blueShift = BLUE_FLAG;
  } else {
    redShift = BLUE_FLAG;
  }

  for (var i = redStart; i < redEnd; ++i) {
    var idx = i + redShift;
    var redOffset = elemSize * i;
    SWEEP_EVENTS[ptr++] = red[redOffset + istart];
    SWEEP_EVENTS[ptr++] = -idx;
    SWEEP_EVENTS[ptr++] = red[redOffset + iend];
    SWEEP_EVENTS[ptr++] = idx;
  }
  for (var i = blueStart; i < blueEnd; ++i) {
    var idx = i + blueShift;
    var blueOffset = elemSize * i;
    SWEEP_EVENTS[ptr++] = blue[blueOffset + istart];
    SWEEP_EVENTS[ptr++] = -idx;
  }

  //process events from left->right
  var n = ptr >>> 1;
  isort(SWEEP_EVENTS, n);

  var redActive = 0;
  for (var i = 0; i < n; ++i) {
    var e = SWEEP_EVENTS[2 * i + 1] | 0;
    if (e < 0) {
      var idx = -e;
      var isRed = false;
      if (idx >= BLUE_FLAG) {
        isRed = !flip;
        idx -= BLUE_FLAG;
      } else {
        isRed = !!flip;
        idx -= 1;
      }
      if (isRed) {
        sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, idx);
      } else {
        var blueId = blueIndex[idx];
        var bluePtr = elemSize * idx;

        var b0 = blue[bluePtr + axis + 1];
        var b1 = blue[bluePtr + axis + 1 + d];

        red_loop: for (var j = 0; j < redActive; ++j) {
          var oidx = RED_SWEEP_QUEUE[j];
          var redPtr = elemSize * oidx;

          if (b1 < red[redPtr + axis + 1] || red[redPtr + axis + 1 + d] < b0) {
            continue;
          }

          for (var k = axis + 2; k < d; ++k) {
            if (blue[bluePtr + k + d] < red[redPtr + k] || red[redPtr + k + d] < blue[bluePtr + k]) {
              continue red_loop;
            }
          }

          var redId = redIndex[oidx];
          var retval;
          if (flip) {
            retval = visit(blueId, redId);
          } else {
            retval = visit(redId, blueId);
          }
          if (retval !== void 0) {
            return retval;
          }
        }
      }
    } else {
      sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, e - redShift);
    }
  }
}

function scanComplete(d, axis, visit, redStart, redEnd, red, redIndex, blueStart, blueEnd, blue, blueIndex) {

  var ptr = 0;
  var elemSize = 2 * d;
  var istart = axis;
  var iend = axis + d;

  for (var i = redStart; i < redEnd; ++i) {
    var idx = i + BLUE_FLAG;
    var redOffset = elemSize * i;
    SWEEP_EVENTS[ptr++] = red[redOffset + istart];
    SWEEP_EVENTS[ptr++] = -idx;
    SWEEP_EVENTS[ptr++] = red[redOffset + iend];
    SWEEP_EVENTS[ptr++] = idx;
  }
  for (var i = blueStart; i < blueEnd; ++i) {
    var idx = i + 1;
    var blueOffset = elemSize * i;
    SWEEP_EVENTS[ptr++] = blue[blueOffset + istart];
    SWEEP_EVENTS[ptr++] = -idx;
  }

  //process events from left->right
  var n = ptr >>> 1;
  isort(SWEEP_EVENTS, n);

  var redActive = 0;
  for (var i = 0; i < n; ++i) {
    var e = SWEEP_EVENTS[2 * i + 1] | 0;
    if (e < 0) {
      var idx = -e;
      if (idx >= BLUE_FLAG) {
        RED_SWEEP_QUEUE[redActive++] = idx - BLUE_FLAG;
      } else {
        idx -= 1;
        var blueId = blueIndex[idx];
        var bluePtr = elemSize * idx;

        var b0 = blue[bluePtr + axis + 1];
        var b1 = blue[bluePtr + axis + 1 + d];

        red_loop: for (var j = 0; j < redActive; ++j) {
          var oidx = RED_SWEEP_QUEUE[j];
          var redId = redIndex[oidx];

          if (redId === blueId) {
            break;
          }

          var redPtr = elemSize * oidx;
          if (b1 < red[redPtr + axis + 1] || red[redPtr + axis + 1 + d] < b0) {
            continue;
          }
          for (var k = axis + 2; k < d; ++k) {
            if (blue[bluePtr + k + d] < red[redPtr + k] || red[redPtr + k + d] < blue[bluePtr + k]) {
              continue red_loop;
            }
          }

          var retval = visit(redId, blueId);
          if (retval !== void 0) {
            return retval;
          }
        }
      }
    } else {
      var idx = e - BLUE_FLAG;
      for (var j = redActive - 1; j >= 0; --j) {
        if (RED_SWEEP_QUEUE[j] === idx) {
          for (var k = j + 1; k < redActive; ++k) {
            RED_SWEEP_QUEUE[k - 1] = RED_SWEEP_QUEUE[k];
          }
          break;
        }
      }
      --redActive;
    }
  }
}

},{"./sort":34,"bit-twiddle":27,"typedarray-pool":162}],36:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict';

var base64 = require('base64-js');
var ieee754 = require('ieee754');

exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;

var K_MAX_LENGTH = 0x7fffffff;
exports.kMaxLength = K_MAX_LENGTH;

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') {
  console.error('This browser lacks typed array (Uint8Array) support which is required by ' + '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.');
}

function typedArraySupport() {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1);
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () {
        return 42;
      } };
    return arr.foo() === 42;
  } catch (e) {
    return false;
  }
}

function createBuffer(length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('Invalid typed array length');
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length);
  buf.__proto__ = Buffer.prototype;
  return buf;
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer(arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error('If encoding is specified then the first argument must be a string');
    }
    return allocUnsafe(arg);
  }
  return from(arg, encodingOrOffset, length);
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  });
}

Buffer.poolSize = 8192; // not used by this implementation

function from(value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }

  if (value instanceof ArrayBuffer) {
    return fromArrayBuffer(value, encodingOrOffset, length);
  }

  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset);
  }

  return fromObject(value);
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length);
};

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype;
Buffer.__proto__ = Uint8Array;

function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}

function alloc(size, fill, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(size);
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
  }
  return createBuffer(size);
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding);
};

function allocUnsafe(size) {
  assertSize(size);
  return createBuffer(size < 0 ? 0 : checked(size) | 0);
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size);
};

function fromString(string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }

  var length = byteLength(string, encoding) | 0;
  var buf = createBuffer(length);

  var actual = buf.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual);
  }

  return buf;
}

function fromArrayLike(array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  var buf = createBuffer(length);
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255;
  }
  return buf;
}

function fromArrayBuffer(array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds');
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds');
  }

  var buf;
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array);
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset);
  } else {
    buf = new Uint8Array(array, byteOffset, length);
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype;
  return buf;
}

function fromObject(obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0;
    var buf = createBuffer(len);

    if (buf.length === 0) {
      return buf;
    }

    obj.copy(buf, 0, 0, len);
    return buf;
  }

  if (obj) {
    if (isArrayBufferView(obj) || 'length' in obj) {
      if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }

    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
}

function checked(length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');
  }
  return length | 0;
}

function SlowBuffer(length) {
  if (+length != length) {
    // eslint-disable-line eqeqeq
    length = 0;
  }
  return Buffer.alloc(+length);
}

Buffer.isBuffer = function isBuffer(b) {
  return b != null && b._isBuffer === true;
};

Buffer.compare = function compare(a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers');
  }

  if (a === b) return 0;

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;
    default:
      return false;
  }
};

Buffer.concat = function concat(list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }

  if (list.length === 0) {
    return Buffer.alloc(0);
  }

  var i;
  if (length === undefined) {
    length = 0;
    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

function byteLength(string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length;
  }
  if (isArrayBufferView(string) || string instanceof ArrayBuffer) {
    return string.byteLength;
  }
  if (typeof string !== 'string') {
    string = '' + string;
  }

  var len = string.length;
  if (len === 0) return 0;

  // Use a for loop to avoid recursion
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length;
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;
      case 'hex':
        return len >>> 1;
      case 'base64':
        return base64ToBytes(string).length;
      default:
        if (loweredCase) return utf8ToBytes(string).length; // assume utf8
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer.byteLength = byteLength;

function slowToString(encoding, start, end) {
  var loweredCase = false;

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0;
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return '';
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return '';
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return '';
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);

      case 'ascii':
        return asciiSlice(this, start, end);

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);

      case 'base64':
        return base64Slice(this, start, end);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true;

function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer.prototype.swap16 = function swap16() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }
  return this;
};

Buffer.prototype.swap32 = function swap32() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }
  return this;
};

Buffer.prototype.swap64 = function swap64() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }
  return this;
};

Buffer.prototype.toString = function toString() {
  var length = this.length;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};

Buffer.prototype.equals = function equals(b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
  if (this === b) return true;
  return Buffer.compare(this, b) === 0;
};

Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = exports.INSPECT_MAX_BYTES;
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }
  return '<Buffer ' + str + '>';
};

Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer');
  }

  if (start === undefined) {
    start = 0;
  }
  if (end === undefined) {
    end = target ? target.length : 0;
  }
  if (thisStart === undefined) {
    thisStart = 0;
  }
  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start >= end) {
    return 1;
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;

  if (this === target) return 0;

  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);

  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1;

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }
  byteOffset = +byteOffset; // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }

  throw new TypeError('val must be string, number or Buffer');
}

function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();
    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }

  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }
      if (found) return i;
    }
  }

  return -1;
}

Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};

Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};

Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};

function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (numberIsNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }
  return i;
}

function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}

function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}

function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}

function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}

function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}

Buffer.prototype.write = function write(string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0;
    // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0;
    if (isFinite(length)) {
      length = length >>> 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    }
  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }

  if (!encoding) encoding = 'utf8';

  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);

      case 'ascii':
        return asciiWrite(this, string, offset, length);

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length);

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};

function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf);
  } else {
    return base64.fromByteArray(buf.slice(start, end));
  }
}

function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];

  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res);
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints // avoid extra slice()
    );
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = '';
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}

function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }
  return ret;
}

function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}

function hexSlice(buf, start, end) {
  var len = buf.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }
  return out;
}

function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}

Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;

  var newBuf = this.subarray(start, end
  // Return an augmented `Uint8Array` instance
  );newBuf.__proto__ = Buffer.prototype;
  return newBuf;
};

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}

Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val;
};

Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val;
};

Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};

Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};

Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};

Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};

Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};

Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val;
};

Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val;
};

Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};

Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};

Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};

Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, true, 23, 4);
};

Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, false, 23, 4);
};

Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, true, 52, 8);
};

Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, false, 52, 8);
};

function checkInt(buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}

Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  this[offset] = value & 0xff;
  this[offset + 1] = value >>> 8;
  return offset + 2;
};

Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  this[offset] = value >>> 8;
  this[offset + 1] = value & 0xff;
  return offset + 2;
};

Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  this[offset + 3] = value >>> 24;
  this[offset + 2] = value >>> 16;
  this[offset + 1] = value >>> 8;
  this[offset] = value & 0xff;
  return offset + 4;
};

Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  this[offset] = value >>> 24;
  this[offset + 1] = value >>> 16;
  this[offset + 2] = value >>> 8;
  this[offset + 3] = value & 0xff;
  return offset + 4;
};

Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  this[offset] = value & 0xff;
  this[offset + 1] = value >>> 8;
  return offset + 2;
};

Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  this[offset] = value >>> 8;
  this[offset + 1] = value & 0xff;
  return offset + 2;
};

Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  this[offset] = value & 0xff;
  this[offset + 1] = value >>> 8;
  this[offset + 2] = value >>> 16;
  this[offset + 3] = value >>> 24;
  return offset + 4;
};

Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;
  this[offset] = value >>> 24;
  this[offset + 1] = value >>> 16;
  this[offset + 2] = value >>> 8;
  this[offset + 3] = value & 0xff;
  return offset + 4;
};

function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}

function writeFloat(buf, value, offset, littleEndian, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}

Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};

Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};

function writeDouble(buf, value, offset, littleEndian, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};

Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start;

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0;

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
  if (end < 0) throw new RangeError('sourceEnd out of bounds');

  // Are we oob?
  if (end > this.length) end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;
  var i;

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
  }

  return len;
};

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }

  if (end <= start) {
    return this;
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;

  if (!val) val = 0;

  var i;
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = Buffer.isBuffer(val) ? val : new Buffer(val, encoding);
    var len = bytes.length;
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this;
};

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;

function base64clean(str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, ''
  // Node converts strings with length < 2 to ''
  );if (str.length < 2) return '';
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '=';
  }
  return str;
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i

    // is surrogate component
    );if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        }

        // valid lead
        leadSurrogate = codePoint;

        continue;
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null;

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }

  return bytes;
}

function asciiToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }
  return byteArray;
}

function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;

    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray;
}

function base64ToBytes(str) {
  return base64.toByteArray(base64clean(str));
}

function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }
  return i;
}

// Node 0.10 supports `ArrayBuffer` but lacks `ArrayBuffer.isView`
function isArrayBufferView(obj) {
  return typeof ArrayBuffer.isView === 'function' && ArrayBuffer.isView(obj);
}

function numberIsNaN(obj) {
  return obj !== obj; // eslint-disable-line no-self-compare
}

},{"base64-js":9,"ieee754":101}],37:[function(require,module,exports){
var size = require('element-size');

module.exports = fit;

var scratch = new Float32Array(2);

function fit(canvas, parent, scale) {
  var isSVG = canvas.nodeName.toUpperCase() === 'SVG';

  canvas.style.position = canvas.style.position || 'absolute';
  canvas.style.top = 0;
  canvas.style.left = 0;

  resize.scale = parseFloat(scale || 1);
  resize.parent = parent;

  return resize();

  function resize() {
    var p = resize.parent || canvas.parentNode;
    if (typeof p === 'function') {
      var dims = p(scratch) || scratch;
      var width = dims[0];
      var height = dims[1];
    } else if (p && p !== document.body) {
      var psize = size(p);
      var width = psize[0] | 0;
      var height = psize[1] | 0;
    } else {
      var width = window.innerWidth;
      var height = window.innerHeight;
    }

    if (isSVG) {
      canvas.setAttribute('width', width * resize.scale + 'px');
      canvas.setAttribute('height', height * resize.scale + 'px');
    } else {
      canvas.width = width * resize.scale;
      canvas.height = height * resize.scale;
    }

    canvas.style.width = width + 'px';
    canvas.style.height = height + 'px';

    return resize;
  }
}

},{"element-size":61}],38:[function(require,module,exports){
'use strict';

var monotoneTriangulate = require('./lib/monotone');
var makeIndex = require('./lib/triangulation');
var delaunayFlip = require('./lib/delaunay');
var filterTriangulation = require('./lib/filter');

module.exports = cdt2d;

function canonicalizeEdge(e) {
  return [Math.min(e[0], e[1]), Math.max(e[0], e[1])];
}

function compareEdge(a, b) {
  return a[0] - b[0] || a[1] - b[1];
}

function canonicalizeEdges(edges) {
  return edges.map(canonicalizeEdge).sort(compareEdge);
}

function getDefault(options, property, dflt) {
  if (property in options) {
    return options[property];
  }
  return dflt;
}

function cdt2d(points, edges, options) {

  if (!Array.isArray(edges)) {
    options = edges || {};
    edges = [];
  } else {
    options = options || {};
    edges = edges || [];
  }

  //Parse out options
  var delaunay = !!getDefault(options, 'delaunay', true);
  var interior = !!getDefault(options, 'interior', true);
  var exterior = !!getDefault(options, 'exterior', true);
  var infinity = !!getDefault(options, 'infinity', false

  //Handle trivial case
  );if (!interior && !exterior || points.length === 0) {
    return [];
  }

  //Construct initial triangulation
  var cells = monotoneTriangulate(points, edges

  //If delaunay refinement needed, then improve quality by edge flipping
  );if (delaunay || interior !== exterior || infinity) {

    //Index all of the cells to support fast neighborhood queries
    var triangulation = makeIndex(points.length, canonicalizeEdges(edges));
    for (var i = 0; i < cells.length; ++i) {
      var f = cells[i];
      triangulation.addTriangle(f[0], f[1], f[2]);
    }

    //Run edge flipping
    if (delaunay) {
      delaunayFlip(points, triangulation);
    }

    //Filter points
    if (!exterior) {
      return filterTriangulation(triangulation, -1);
    } else if (!interior) {
      return filterTriangulation(triangulation, 1, infinity);
    } else if (infinity) {
      return filterTriangulation(triangulation, 0, infinity);
    } else {
      return triangulation.cells();
    }
  } else {
    return cells;
  }
}

},{"./lib/delaunay":39,"./lib/filter":40,"./lib/monotone":41,"./lib/triangulation":42}],39:[function(require,module,exports){
'use strict';

var inCircle = require('robust-in-sphere')[4];
var bsearch = require('binary-search-bounds');

module.exports = delaunayRefine;

function testFlip(points, triangulation, stack, a, b, x) {
  var y = triangulation.opposite(a, b

  //Test boundary edge
  );if (y < 0) {
    return;
  }

  //Swap edge if order flipped
  if (b < a) {
    var tmp = a;
    a = b;
    b = tmp;
    tmp = x;
    x = y;
    y = tmp;
  }

  //Test if edge is constrained
  if (triangulation.isConstraint(a, b)) {
    return;
  }

  //Test if edge is delaunay
  if (inCircle(points[a], points[b], points[x], points[y]) < 0) {
    stack.push(a, b);
  }
}

//Assume edges are sorted lexicographically
function delaunayRefine(points, triangulation) {
  var stack = [];

  var numPoints = points.length;
  var stars = triangulation.stars;
  for (var a = 0; a < numPoints; ++a) {
    var star = stars[a];
    for (var j = 1; j < star.length; j += 2) {
      var b = star[j];

      //If order is not consistent, then skip edge
      if (b < a) {
        continue;
      }

      //Check if edge is constrained
      if (triangulation.isConstraint(a, b)) {
        continue;
      }

      //Find opposite edge
      var x = star[j - 1],
          y = -1;
      for (var k = 1; k < star.length; k += 2) {
        if (star[k - 1] === b) {
          y = star[k];
          break;
        }
      }

      //If this is a boundary edge, don't flip it
      if (y < 0) {
        continue;
      }

      //If edge is in circle, flip it
      if (inCircle(points[a], points[b], points[x], points[y]) < 0) {
        stack.push(a, b);
      }
    }
  }

  while (stack.length > 0) {
    var b = stack.pop();
    var a = stack.pop

    //Find opposite pairs
    ();var x = -1,
        y = -1;
    var star = stars[a];
    for (var i = 1; i < star.length; i += 2) {
      var s = star[i - 1];
      var t = star[i];
      if (s === b) {
        y = t;
      } else if (t === b) {
        x = s;
      }
    }

    //If x/y are both valid then skip edge
    if (x < 0 || y < 0) {
      continue;
    }

    //If edge is now delaunay, then don't flip it
    if (inCircle(points[a], points[b], points[x], points[y]) >= 0) {
      continue;
    }

    //Flip the edge
    triangulation.flip(a, b

    //Test flipping neighboring edges
    );testFlip(points, triangulation, stack, x, a, y);
    testFlip(points, triangulation, stack, a, y, x);
    testFlip(points, triangulation, stack, y, b, x);
    testFlip(points, triangulation, stack, b, x, y);
  }
}

},{"binary-search-bounds":26,"robust-in-sphere":136}],40:[function(require,module,exports){
'use strict';

var bsearch = require('binary-search-bounds');

module.exports = classifyFaces;

function FaceIndex(cells, neighbor, constraint, flags, active, next, boundary) {
  this.cells = cells;
  this.neighbor = neighbor;
  this.flags = flags;
  this.constraint = constraint;
  this.active = active;
  this.next = next;
  this.boundary = boundary;
}

var proto = FaceIndex.prototype;

function compareCell(a, b) {
  return a[0] - b[0] || a[1] - b[1] || a[2] - b[2];
}

proto.locate = function () {
  var key = [0, 0, 0];
  return function (a, b, c) {
    var x = a,
        y = b,
        z = c;
    if (b < c) {
      if (b < a) {
        x = b;
        y = c;
        z = a;
      }
    } else if (c < a) {
      x = c;
      y = a;
      z = b;
    }
    if (x < 0) {
      return -1;
    }
    key[0] = x;
    key[1] = y;
    key[2] = z;
    return bsearch.eq(this.cells, key, compareCell);
  };
}();

function indexCells(triangulation, infinity) {
  //First get cells and canonicalize
  var cells = triangulation.cells();
  var nc = cells.length;
  for (var i = 0; i < nc; ++i) {
    var c = cells[i];
    var x = c[0],
        y = c[1],
        z = c[2];
    if (y < z) {
      if (y < x) {
        c[0] = y;
        c[1] = z;
        c[2] = x;
      }
    } else if (z < x) {
      c[0] = z;
      c[1] = x;
      c[2] = y;
    }
  }
  cells.sort(compareCell

  //Initialize flag array
  );var flags = new Array(nc);
  for (var i = 0; i < flags.length; ++i) {
    flags[i] = 0;
  }

  //Build neighbor index, initialize queues
  var active = [];
  var next = [];
  var neighbor = new Array(3 * nc);
  var constraint = new Array(3 * nc);
  var boundary = null;
  if (infinity) {
    boundary = [];
  }
  var index = new FaceIndex(cells, neighbor, constraint, flags, active, next, boundary);
  for (var i = 0; i < nc; ++i) {
    var c = cells[i];
    for (var j = 0; j < 3; ++j) {
      var x = c[j],
          y = c[(j + 1) % 3];
      var a = neighbor[3 * i + j] = index.locate(y, x, triangulation.opposite(y, x));
      var b = constraint[3 * i + j] = triangulation.isConstraint(x, y);
      if (a < 0) {
        if (b) {
          next.push(i);
        } else {
          active.push(i);
          flags[i] = 1;
        }
        if (infinity) {
          boundary.push([y, x, -1]);
        }
      }
    }
  }
  return index;
}

function filterCells(cells, flags, target) {
  var ptr = 0;
  for (var i = 0; i < cells.length; ++i) {
    if (flags[i] === target) {
      cells[ptr++] = cells[i];
    }
  }
  cells.length = ptr;
  return cells;
}

function classifyFaces(triangulation, target, infinity) {
  var index = indexCells(triangulation, infinity);

  if (target === 0) {
    if (infinity) {
      return index.cells.concat(index.boundary);
    } else {
      return index.cells;
    }
  }

  var side = 1;
  var active = index.active;
  var next = index.next;
  var flags = index.flags;
  var cells = index.cells;
  var constraint = index.constraint;
  var neighbor = index.neighbor;

  while (active.length > 0 || next.length > 0) {
    while (active.length > 0) {
      var t = active.pop();
      if (flags[t] === -side) {
        continue;
      }
      flags[t] = side;
      var c = cells[t];
      for (var j = 0; j < 3; ++j) {
        var f = neighbor[3 * t + j];
        if (f >= 0 && flags[f] === 0) {
          if (constraint[3 * t + j]) {
            next.push(f);
          } else {
            active.push(f);
            flags[f] = side;
          }
        }
      }
    }

    //Swap arrays and loop
    var tmp = next;
    next = active;
    active = tmp;
    next.length = 0;
    side = -side;
  }

  var result = filterCells(cells, flags, target);
  if (infinity) {
    return result.concat(index.boundary);
  }
  return result;
}

},{"binary-search-bounds":26}],41:[function(require,module,exports){
'use strict';

var bsearch = require('binary-search-bounds');
var orient = require('robust-orientation')[3];

var EVENT_POINT = 0;
var EVENT_END = 1;
var EVENT_START = 2;

module.exports = monotoneTriangulate;

//A partial convex hull fragment, made of two unimonotone polygons
function PartialHull(a, b, idx, lowerIds, upperIds) {
  this.a = a;
  this.b = b;
  this.idx = idx;
  this.lowerIds = lowerIds;
  this.upperIds = upperIds;
}

//An event in the sweep line procedure
function Event(a, b, type, idx) {
  this.a = a;
  this.b = b;
  this.type = type;
  this.idx = idx;
}

//This is used to compare events for the sweep line procedure
// Points are:
//  1. sorted lexicographically
//  2. sorted by type  (point < end < start)
//  3. segments sorted by winding order
//  4. sorted by index
function compareEvent(a, b) {
  var d = a.a[0] - b.a[0] || a.a[1] - b.a[1] || a.type - b.type;
  if (d) {
    return d;
  }
  if (a.type !== EVENT_POINT) {
    d = orient(a.a, a.b, b.b);
    if (d) {
      return d;
    }
  }
  return a.idx - b.idx;
}

function testPoint(hull, p) {
  return orient(hull.a, hull.b, p);
}

function addPoint(cells, hulls, points, p, idx) {
  var lo = bsearch.lt(hulls, p, testPoint);
  var hi = bsearch.gt(hulls, p, testPoint);
  for (var i = lo; i < hi; ++i) {
    var hull = hulls[i];

    //Insert p into lower hull
    var lowerIds = hull.lowerIds;
    var m = lowerIds.length;
    while (m > 1 && orient(points[lowerIds[m - 2]], points[lowerIds[m - 1]], p) > 0) {
      cells.push([lowerIds[m - 1], lowerIds[m - 2], idx]);
      m -= 1;
    }
    lowerIds.length = m;
    lowerIds.push(idx

    //Insert p into upper hull
    );var upperIds = hull.upperIds;
    var m = upperIds.length;
    while (m > 1 && orient(points[upperIds[m - 2]], points[upperIds[m - 1]], p) < 0) {
      cells.push([upperIds[m - 2], upperIds[m - 1], idx]);
      m -= 1;
    }
    upperIds.length = m;
    upperIds.push(idx);
  }
}

function findSplit(hull, edge) {
  var d;
  if (hull.a[0] < edge.a[0]) {
    d = orient(hull.a, hull.b, edge.a);
  } else {
    d = orient(edge.b, edge.a, hull.a);
  }
  if (d) {
    return d;
  }
  if (edge.b[0] < hull.b[0]) {
    d = orient(hull.a, hull.b, edge.b);
  } else {
    d = orient(edge.b, edge.a, hull.b);
  }
  return d || hull.idx - edge.idx;
}

function splitHulls(hulls, points, event) {
  var splitIdx = bsearch.le(hulls, event, findSplit);
  var hull = hulls[splitIdx];
  var upperIds = hull.upperIds;
  var x = upperIds[upperIds.length - 1];
  hull.upperIds = [x];
  hulls.splice(splitIdx + 1, 0, new PartialHull(event.a, event.b, event.idx, [x], upperIds));
}

function mergeHulls(hulls, points, event) {
  //Swap pointers for merge search
  var tmp = event.a;
  event.a = event.b;
  event.b = tmp;
  var mergeIdx = bsearch.eq(hulls, event, findSplit);
  var upper = hulls[mergeIdx];
  var lower = hulls[mergeIdx - 1];
  lower.upperIds = upper.upperIds;
  hulls.splice(mergeIdx, 1);
}

function monotoneTriangulate(points, edges) {

  var numPoints = points.length;
  var numEdges = edges.length;

  var events = [];

  //Create point events
  for (var i = 0; i < numPoints; ++i) {
    events.push(new Event(points[i], null, EVENT_POINT, i));
  }

  //Create edge events
  for (var i = 0; i < numEdges; ++i) {
    var e = edges[i];
    var a = points[e[0]];
    var b = points[e[1]];
    if (a[0] < b[0]) {
      events.push(new Event(a, b, EVENT_START, i), new Event(b, a, EVENT_END, i));
    } else if (a[0] > b[0]) {
      events.push(new Event(b, a, EVENT_START, i), new Event(a, b, EVENT_END, i));
    }
  }

  //Sort events
  events.sort(compareEvent

  //Initialize hull
  );var minX = events[0].a[0] - (1 + Math.abs(events[0].a[0])) * Math.pow(2, -52);
  var hull = [new PartialHull([minX, 1], [minX, 0], -1, [], [], [], [])];

  //Process events in order
  var cells = [];
  for (var i = 0, numEvents = events.length; i < numEvents; ++i) {
    var event = events[i];
    var type = event.type;
    if (type === EVENT_POINT) {
      addPoint(cells, hull, points, event.a, event.idx);
    } else if (type === EVENT_START) {
      splitHulls(hull, points, event);
    } else {
      mergeHulls(hull, points, event);
    }
  }

  //Return triangulation
  return cells;
}

},{"binary-search-bounds":26,"robust-orientation":137}],42:[function(require,module,exports){
'use strict';

var bsearch = require('binary-search-bounds');

module.exports = createTriangulation;

function Triangulation(stars, edges) {
  this.stars = stars;
  this.edges = edges;
}

var proto = Triangulation.prototype;

function removePair(list, j, k) {
  for (var i = 1, n = list.length; i < n; i += 2) {
    if (list[i - 1] === j && list[i] === k) {
      list[i - 1] = list[n - 2];
      list[i] = list[n - 1];
      list.length = n - 2;
      return;
    }
  }
}

proto.isConstraint = function () {
  var e = [0, 0];
  function compareLex(a, b) {
    return a[0] - b[0] || a[1] - b[1];
  }
  return function (i, j) {
    e[0] = Math.min(i, j);
    e[1] = Math.max(i, j);
    return bsearch.eq(this.edges, e, compareLex) >= 0;
  };
}();

proto.removeTriangle = function (i, j, k) {
  var stars = this.stars;
  removePair(stars[i], j, k);
  removePair(stars[j], k, i);
  removePair(stars[k], i, j);
};

proto.addTriangle = function (i, j, k) {
  var stars = this.stars;
  stars[i].push(j, k);
  stars[j].push(k, i);
  stars[k].push(i, j);
};

proto.opposite = function (j, i) {
  var list = this.stars[i];
  for (var k = 1, n = list.length; k < n; k += 2) {
    if (list[k] === j) {
      return list[k - 1];
    }
  }
  return -1;
};

proto.flip = function (i, j) {
  var a = this.opposite(i, j);
  var b = this.opposite(j, i);
  this.removeTriangle(i, j, a);
  this.removeTriangle(j, i, b);
  this.addTriangle(i, b, a);
  this.addTriangle(j, a, b);
};

proto.edges = function () {
  var stars = this.stars;
  var result = [];
  for (var i = 0, n = stars.length; i < n; ++i) {
    var list = stars[i];
    for (var j = 0, m = list.length; j < m; j += 2) {
      result.push([list[j], list[j + 1]]);
    }
  }
  return result;
};

proto.cells = function () {
  var stars = this.stars;
  var result = [];
  for (var i = 0, n = stars.length; i < n; ++i) {
    var list = stars[i];
    for (var j = 0, m = list.length; j < m; j += 2) {
      var s = list[j];
      var t = list[j + 1];
      if (i < Math.min(s, t)) {
        result.push([i, s, t]);
      }
    }
  }
  return result;
};

function createTriangulation(numVerts, edges) {
  var stars = new Array(numVerts);
  for (var i = 0; i < numVerts; ++i) {
    stars[i] = [];
  }
  return new Triangulation(stars, edges);
}

},{"binary-search-bounds":26}],43:[function(require,module,exports){
module.exports = clamp;

function clamp(value, min, max) {
  return min < max ? value < min ? min : value > max ? max : value : value < max ? max : value > min ? min : value;
}

},{}],44:[function(require,module,exports){
'use strict';

module.exports = cleanPSLG;

var UnionFind = require('union-find');
var boxIntersect = require('box-intersect');
var segseg = require('robust-segment-intersect');
var rat = require('big-rat');
var ratCmp = require('big-rat/cmp');
var ratToFloat = require('big-rat/to-float');
var ratVec = require('rat-vec');
var nextafter = require('nextafter');

var solveIntersection = require('./lib/rat-seg-intersect'

// Bounds on a rational number when rounded to a float
);function boundRat(r) {
  var f = ratToFloat(r);
  return [nextafter(f, -Infinity), nextafter(f, Infinity)];
}

// Convert a list of edges in a pslg to bounding boxes
function boundEdges(points, edges) {
  var bounds = new Array(edges.length);
  for (var i = 0; i < edges.length; ++i) {
    var e = edges[i];
    var a = points[e[0]];
    var b = points[e[1]];
    bounds[i] = [nextafter(Math.min(a[0], b[0]), -Infinity), nextafter(Math.min(a[1], b[1]), -Infinity), nextafter(Math.max(a[0], b[0]), Infinity), nextafter(Math.max(a[1], b[1]), Infinity)];
  }
  return bounds;
}

// Convert a list of points into bounding boxes by duplicating coords
function boundPoints(points) {
  var bounds = new Array(points.length);
  for (var i = 0; i < points.length; ++i) {
    var p = points[i];
    bounds[i] = [nextafter(p[0], -Infinity), nextafter(p[1], -Infinity), nextafter(p[0], Infinity), nextafter(p[1], Infinity)];
  }
  return bounds;
}

// Find all pairs of crossing edges in a pslg (given edge bounds)
function getCrossings(points, edges, edgeBounds) {
  var result = [];
  boxIntersect(edgeBounds, function (i, j) {
    var e = edges[i];
    var f = edges[j];
    if (e[0] === f[0] || e[0] === f[1] || e[1] === f[0] || e[1] === f[1]) {
      return;
    }
    var a = points[e[0]];
    var b = points[e[1]];
    var c = points[f[0]];
    var d = points[f[1]];
    if (segseg(a, b, c, d)) {
      result.push([i, j]);
    }
  });
  return result;
}

// Find all pairs of crossing vertices in a pslg (given edge/vert bounds)
function getTJunctions(points, edges, edgeBounds, vertBounds) {
  var result = [];
  boxIntersect(edgeBounds, vertBounds, function (i, v) {
    var e = edges[i];
    if (e[0] === v || e[1] === v) {
      return;
    }
    var p = points[v];
    var a = points[e[0]];
    var b = points[e[1]];
    if (segseg(a, b, p, p)) {
      result.push([i, v]);
    }
  });
  return result;
}

// Cut edges along crossings/tjunctions
function cutEdges(floatPoints, edges, crossings, junctions, useColor) {
  var i, e;

  // Convert crossings into tjunctions by constructing rational points
  var ratPoints = floatPoints.map(function (p) {
    return [rat(p[0]), rat(p[1])];
  });
  for (i = 0; i < crossings.length; ++i) {
    var crossing = crossings[i];
    e = crossing[0];
    var f = crossing[1];
    var ee = edges[e];
    var ef = edges[f];
    var x = solveIntersection(ratVec(floatPoints[ee[0]]), ratVec(floatPoints[ee[1]]), ratVec(floatPoints[ef[0]]), ratVec(floatPoints[ef[1]]));
    if (!x) {
      // Segments are parallel, should already be handled by t-junctions
      continue;
    }
    var idx = floatPoints.length;
    floatPoints.push([ratToFloat(x[0]), ratToFloat(x[1])]);
    ratPoints.push(x);
    junctions.push([e, idx], [f, idx]);
  }

  // Sort tjunctions
  junctions.sort(function (a, b) {
    if (a[0] !== b[0]) {
      return a[0] - b[0];
    }
    var u = ratPoints[a[1]];
    var v = ratPoints[b[1]];
    return ratCmp(u[0], v[0]) || ratCmp(u[1], v[1]);
  }

  // Split edges along junctions
  );for (i = junctions.length - 1; i >= 0; --i) {
    var junction = junctions[i];
    e = junction[0];

    var edge = edges[e];
    var s = edge[0];
    var t = edge[1];

    // Check if edge is not lexicographically sorted
    var a = floatPoints[s];
    var b = floatPoints[t];
    if ((a[0] - b[0] || a[1] - b[1]) < 0) {
      var tmp = s;
      s = t;
      t = tmp;
    }

    // Split leading edge
    edge[0] = s;
    var last = edge[1] = junction[1];

    // If we are grouping edges by color, remember to track data
    var color;
    if (useColor) {
      color = edge[2];
    }

    // Split other edges
    while (i > 0 && junctions[i - 1][0] === e) {
      var junction = junctions[--i];
      var next = junction[1];
      if (useColor) {
        edges.push([last, next, color]);
      } else {
        edges.push([last, next]);
      }
      last = next;
    }

    // Add final edge
    if (useColor) {
      edges.push([last, t, color]);
    } else {
      edges.push([last, t]);
    }
  }

  // Return constructed rational points
  return ratPoints;
}

// Merge overlapping points
function dedupPoints(floatPoints, ratPoints, floatBounds) {
  var numPoints = ratPoints.length;
  var uf = new UnionFind(numPoints);

  // Compute rational bounds
  var bounds = [];
  for (var i = 0; i < ratPoints.length; ++i) {
    var p = ratPoints[i];
    var xb = boundRat(p[0]);
    var yb = boundRat(p[1]);
    bounds.push([nextafter(xb[0], -Infinity), nextafter(yb[0], -Infinity), nextafter(xb[1], Infinity), nextafter(yb[1], Infinity)]);
  }

  // Link all points with over lapping boxes
  boxIntersect(bounds, function (i, j) {
    uf.link(i, j);
  }

  // Do 1 pass over points to combine points in label sets
  );var noDupes = true;
  var labels = new Array(numPoints);
  for (var i = 0; i < numPoints; ++i) {
    var j = uf.find(i);
    if (j !== i) {
      // Clear no-dupes flag, zero out label
      noDupes = false;
      // Make each point the top-left point from its cell
      floatPoints[j] = [Math.min(floatPoints[i][0], floatPoints[j][0]), Math.min(floatPoints[i][1], floatPoints[j][1])];
    }
  }

  // If no duplicates, return null to signal termination
  if (noDupes) {
    return null;
  }

  var ptr = 0;
  for (var i = 0; i < numPoints; ++i) {
    var j = uf.find(i);
    if (j === i) {
      labels[i] = ptr;
      floatPoints[ptr++] = floatPoints[i];
    } else {
      labels[i] = -1;
    }
  }

  floatPoints.length = ptr;

  // Do a second pass to fix up missing labels
  for (var i = 0; i < numPoints; ++i) {
    if (labels[i] < 0) {
      labels[i] = labels[uf.find(i)];
    }
  }

  // Return resulting union-find data structure
  return labels;
}

function compareLex2(a, b) {
  return a[0] - b[0] || a[1] - b[1];
}
function compareLex3(a, b) {
  var d = a[0] - b[0] || a[1] - b[1];
  if (d) {
    return d;
  }
  if (a[2] < b[2]) {
    return -1;
  } else if (a[2] > b[2]) {
    return 1;
  }
  return 0;
}

// Remove duplicate edge labels
function dedupEdges(edges, labels, useColor) {
  if (edges.length === 0) {
    return;
  }
  if (labels) {
    for (var i = 0; i < edges.length; ++i) {
      var e = edges[i];
      var a = labels[e[0]];
      var b = labels[e[1]];
      e[0] = Math.min(a, b);
      e[1] = Math.max(a, b);
    }
  } else {
    for (var i = 0; i < edges.length; ++i) {
      var e = edges[i];
      var a = e[0];
      var b = e[1];
      e[0] = Math.min(a, b);
      e[1] = Math.max(a, b);
    }
  }
  if (useColor) {
    edges.sort(compareLex3);
  } else {
    edges.sort(compareLex2);
  }
  var ptr = 1;
  for (var i = 1; i < edges.length; ++i) {
    var prev = edges[i - 1];
    var next = edges[i];
    if (next[0] === prev[0] && next[1] === prev[1] && (!useColor || next[2] === prev[2])) {
      continue;
    }
    edges[ptr++] = next;
  }
  edges.length = ptr;
}

function preRound(points, edges, useColor) {
  var labels = dedupPoints(points, [], boundPoints(points));
  dedupEdges(edges, labels, useColor);
  return !!labels;
}

// Repeat until convergence
function snapRound(points, edges, useColor) {
  // 1. find edge crossings
  var edgeBounds = boundEdges(points, edges);
  var crossings = getCrossings(points, edges, edgeBounds

  // 2. find t-junctions
  );var vertBounds = boundPoints(points);
  var tjunctions = getTJunctions(points, edges, edgeBounds, vertBounds

  // 3. cut edges, construct rational points
  );var ratPoints = cutEdges(points, edges, crossings, tjunctions, useColor

  // 4. dedupe verts
  );var labels = dedupPoints(points, ratPoints, vertBounds

  // 5. dedupe edges
  );dedupEdges(edges, labels, useColor

  // 6. check termination
  );if (!labels) {
    return crossings.length > 0 || tjunctions.length > 0;
  }

  // More iterations necessary
  return true;
}

// Main loop, runs PSLG clean up until completion
function cleanPSLG(points, edges, colors) {
  // If using colors, augment edges with color data
  var prevEdges;
  if (colors) {
    prevEdges = edges;
    var augEdges = new Array(edges.length);
    for (var i = 0; i < edges.length; ++i) {
      var e = edges[i];
      augEdges[i] = [e[0], e[1], colors[i]];
    }
    edges = augEdges;
  }

  // First round: remove duplicate edges and points
  var modified = preRound(points, edges, !!colors

  // Run snap rounding until convergence
  );while (snapRound(points, edges, !!colors)) {
    modified = true;
  }

  // Strip color tags
  if (!!colors && modified) {
    prevEdges.length = 0;
    colors.length = 0;
    for (var i = 0; i < edges.length; ++i) {
      var e = edges[i];
      prevEdges.push([e[0], e[1]]);
      colors.push(e[2]);
    }
  }

  return modified;
}

},{"./lib/rat-seg-intersect":45,"big-rat":13,"big-rat/cmp":11,"big-rat/to-float":25,"box-intersect":29,"nextafter":115,"rat-vec":130,"robust-segment-intersect":140,"union-find":163}],45:[function(require,module,exports){
'use strict';

module.exports = solveIntersection;

var ratMul = require('big-rat/mul');
var ratDiv = require('big-rat/div');
var ratSub = require('big-rat/sub');
var ratSign = require('big-rat/sign');
var rvSub = require('rat-vec/sub');
var rvAdd = require('rat-vec/add');
var rvMuls = require('rat-vec/muls');

function ratPerp(a, b) {
  return ratSub(ratMul(a[0], b[1]), ratMul(a[1], b[0]));
}

// Solve for intersection
//  x = a + t (b-a)
//  (x - c) ^ (d-c) = 0
//  (t * (b-a) + (a-c) ) ^ (d-c) = 0
//  t * (b-a)^(d-c) = (d-c)^(a-c)
//  t = (d-c)^(a-c) / (b-a)^(d-c)

function solveIntersection(a, b, c, d) {
  var ba = rvSub(b, a);
  var dc = rvSub(d, c);

  var baXdc = ratPerp(ba, dc);

  if (ratSign(baXdc) === 0) {
    return null;
  }

  var ac = rvSub(a, c);
  var dcXac = ratPerp(dc, ac);

  var t = ratDiv(dcXac, baXdc);
  var s = rvMuls(ba, t);
  var r = rvAdd(a, s);

  return r;
}

},{"big-rat/div":12,"big-rat/mul":22,"big-rat/sign":23,"big-rat/sub":24,"rat-vec/add":129,"rat-vec/muls":131,"rat-vec/sub":132}],46:[function(require,module,exports){
/** @module  color-number */

'use strict';

var clamp = require('clamp');

module.exports = toNumber;

function toNumber(rgba, normalized) {
	if (normalized == null) normalized = true;

	var r = rgba[0],
	    g = rgba[1],
	    b = rgba[2],
	    a = rgba[3];

	if (a == null) a = normalized ? 1 : 255;

	if (normalized) {
		r *= 255;
		g *= 255;
		b *= 255;
		a *= 255;
	}

	r = clamp(r, 0, 255) & 0xFF;
	g = clamp(g, 0, 255) & 0xFF;
	b = clamp(b, 0, 255) & 0xFF;
	a = clamp(a, 0, 255) & 0xFF;

	//hi-order shift converts to -1, so we can't use <<24
	var n = r * 0x01000000 + (g << 16) + (b << 8) + a;

	return n;
}

},{"clamp":43}],47:[function(require,module,exports){
module.exports = {
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
};

},{}],48:[function(require,module,exports){
/**
 * @module color-parse
 */

'use strict';

module.exports = parse;

var names = require('color-name');
var isObject = require('is-plain-obj');

/**
 * Base hues
 * http://dev.w3.org/csswg/css-color/#typedef-named-hue
 */
//FIXME: use external hue detector
var baseHues = {
	red: 0,
	orange: 60,
	yellow: 120,
	green: 180,
	blue: 240,
	purple: 300
};

/**
 * Parse color from the string passed
 *
 * @return {Object} A space indicator `space`, an array `values` and `alpha`
 */
function parse(cstr) {
	var m,
	    parts = [],
	    alpha = 1,
	    space;

	if (typeof cstr === 'string') {
		//keyword
		if (names[cstr]) {
			parts = names[cstr].slice();
			space = 'rgb';
		}

		//reserved words
		else if (cstr === 'transparent') {
				alpha = 0;
				space = 'rgb';
				parts = [0, 0, 0];
			}

			//hex
			else if (/^#[A-Fa-f0-9]+$/.test(cstr)) {
					var base = cstr.slice(1);
					var size = base.length;
					var isShort = size <= 4;
					alpha = 1;

					if (isShort) {
						parts = [parseInt(base[0] + base[0], 16), parseInt(base[1] + base[1], 16), parseInt(base[2] + base[2], 16)];
						if (size === 4) {
							alpha = parseInt(base[3] + base[3], 16) / 255;
						}
					} else {
						parts = [parseInt(base[0] + base[1], 16), parseInt(base[2] + base[3], 16), parseInt(base[4] + base[5], 16)];
						if (size === 8) {
							alpha = parseInt(base[6] + base[7], 16) / 255;
						}
					}

					if (!parts[0]) parts[0] = 0;
					if (!parts[1]) parts[1] = 0;
					if (!parts[2]) parts[2] = 0;

					space = 'rgb';
				}

				//color space
				else if (m = /^((?:rgb|hs[lvb]|hwb|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms)a?)\s*\(([^\)]*)\)/.exec(cstr)) {
						var name = m[1];
						var base = name.replace(/a$/, '');
						space = base;
						var size = base === 'cmyk' ? 4 : base === 'gray' ? 1 : 3;
						parts = m[2].trim().split(/\s*,\s*/).map(function (x, i) {
							//<percentage>
							if (/%$/.test(x)) {
								//alpha
								if (i === size) return parseFloat(x) / 100;
								//rgb
								if (base === 'rgb') return parseFloat(x) * 255 / 100;
								return parseFloat(x);
							}
							//hue
							else if (base[i] === 'h') {
									//<deg>
									if (/deg$/.test(x)) {
										return parseFloat(x);
									}
									//<base-hue>
									else if (baseHues[x] !== undefined) {
											return baseHues[x];
										}
								}
							return parseFloat(x);
						});

						if (name === base) parts.push(1);
						alpha = parts[size] === undefined ? 1 : parts[size];
						parts = parts.slice(0, size);
					}

					//named channels case
					else if (cstr.length > 10 && /[0-9](?:\s|\/)/.test(cstr)) {
							parts = cstr.match(/([0-9]+)/g).map(function (value) {
								return parseFloat(value);
							});

							space = cstr.match(/([a-z])/ig).join('').toLowerCase();
						}
	}

	//numeric case
	else if (typeof cstr === 'number') {
			space = 'rgb';
			parts = [cstr >>> 16, (cstr & 0x00ff00) >>> 8, cstr & 0x0000ff];
		}

		//object case - detects css cases of rgb and hsl
		else if (isObject(cstr)) {
				if (cstr.r != null) {
					parts = [cstr.r, cstr.g, cstr.b];
					space = 'rgb';
				} else if (cstr.red != null) {
					parts = [cstr.red, cstr.green, cstr.blue];
					space = 'rgb';
				} else if (cstr.h != null) {
					parts = [cstr.h, cstr.s, cstr.l];
					space = 'hsl';
				} else if (cstr.hue != null) {
					parts = [cstr.hue, cstr.saturation, cstr.lightness];
					space = 'hsl';
				}

				if (cstr.a != null) alpha = cstr.a;else if (cstr.alpha != null) alpha = cstr.alpha;else if (cstr.opacity != null) alpha = cstr.opacity / 100;
			}

			//array
			else if (Array.isArray(cstr) || ArrayBuffer.isView(cstr)) {
					parts = [cstr[0], cstr[1], cstr[2]];
					space = 'rgb';
					alpha = cstr.length === 4 ? cstr[3] : 1;
				}

	return {
		space: space,
		values: parts,
		alpha: alpha
	};
}

},{"color-name":47,"is-plain-obj":108}],49:[function(require,module,exports){
/** @module  color-rgba */

'use strict';

var parse = require('color-parse');
var hsl = require('color-space/hsl');
var clamp = require('clamp');

module.exports = function rgba(color, normalize) {
	if (normalize == null) normalize = true;

	var parsed = parse(color);

	if (!parsed.space) return [];

	if (Array.isArray(color)) return color;

	var values = parsed.values,
	    i,
	    l = values.length;
	for (i = 0; i < l; i++) {
		values[i] = clamp(values[i], 0, 255);
	}

	if (parsed.space[0] === 'h') {
		values = hsl.rgb(values);
	}

	if (normalize) {
		for (i = 0; i < l; i++) {
			values[i] /= 255;
		}
	}

	values.push(clamp(parsed.alpha, 0, 1));

	return values;
};

},{"clamp":43,"color-parse":48,"color-space/hsl":50}],50:[function(require,module,exports){
/**
 * @module color-space/hsl
 */
'use strict';

var rgb = require('./rgb');

module.exports = {
	name: 'hsl',
	min: [0, 0, 0],
	max: [360, 100, 100],
	channel: ['hue', 'saturation', 'lightness'],
	alias: ['HSL'],

	rgb: function (hsl) {
		var h = hsl[0] / 360,
		    s = hsl[1] / 100,
		    l = hsl[2] / 100,
		    t1,
		    t2,
		    t3,
		    rgb,
		    val;

		if (s === 0) {
			val = l * 255;
			return [val, val, val];
		}

		if (l < 0.5) {
			t2 = l * (1 + s);
		} else {
			t2 = l + s - l * s;
		}
		t1 = 2 * l - t2;

		rgb = [0, 0, 0];
		for (var i = 0; i < 3; i++) {
			t3 = h + 1 / 3 * -(i - 1);
			if (t3 < 0) {
				t3++;
			} else if (t3 > 1) {
				t3--;
			}

			if (6 * t3 < 1) {
				val = t1 + (t2 - t1) * 6 * t3;
			} else if (2 * t3 < 1) {
				val = t2;
			} else if (3 * t3 < 2) {
				val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
			} else {
				val = t1;
			}

			rgb[i] = val * 255;
		}

		return rgb;
	}
};

//extend rgb
rgb.hsl = function (rgb) {
	var r = rgb[0] / 255,
	    g = rgb[1] / 255,
	    b = rgb[2] / 255,
	    min = Math.min(r, g, b),
	    max = Math.max(r, g, b),
	    delta = max - min,
	    h,
	    s,
	    l;

	if (max === min) {
		h = 0;
	} else if (r === max) {
		h = (g - b) / delta;
	} else if (g === max) {
		h = 2 + (b - r) / delta;
	} else if (b === max) {
		h = 4 + (r - g) / delta;
	}

	h = Math.min(h * 60, 360);

	if (h < 0) {
		h += 360;
	}

	l = (min + max) / 2;

	if (max === min) {
		s = 0;
	} else if (l <= 0.5) {
		s = delta / (max + min);
	} else {
		s = delta / (2 - max - min);
	}

	return [h, s * 100, l * 100];
};

},{"./rgb":51}],51:[function(require,module,exports){
/**
 * RGB space.
 *
 * @module  color-space/rgb
 */
'use strict';

module.exports = {
	name: 'rgb',
	min: [0, 0, 0],
	max: [255, 255, 255],
	channel: ['red', 'green', 'blue'],
	alias: ['RGB']
};

},{}],52:[function(require,module,exports){
"use strict";

module.exports = compareAngle;

var orient = require("robust-orientation");
var sgn = require("signum");
var twoSum = require("two-sum");
var robustProduct = require("robust-product");
var robustSum = require("robust-sum");

function testInterior(a, b, c) {
  var x0 = twoSum(a[0], -b[0]);
  var y0 = twoSum(a[1], -b[1]);
  var x1 = twoSum(c[0], -b[0]);
  var y1 = twoSum(c[1], -b[1]);

  var d = robustSum(robustProduct(x0, x1), robustProduct(y0, y1));

  return d[d.length - 1] >= 0;
}

function compareAngle(a, b, c, d) {
  var bcd = orient(b, c, d);
  if (bcd === 0) {
    //Handle degenerate cases
    var sabc = sgn(orient(a, b, c));
    var sabd = sgn(orient(a, b, d));
    if (sabc === sabd) {
      if (sabc === 0) {
        var ic = testInterior(a, b, c);
        var id = testInterior(a, b, d);
        if (ic === id) {
          return 0;
        } else if (ic) {
          return 1;
        } else {
          return -1;
        }
      }
      return 0;
    } else if (sabd === 0) {
      if (sabc > 0) {
        return -1;
      } else if (testInterior(a, b, d)) {
        return -1;
      } else {
        return 1;
      }
    } else if (sabc === 0) {
      if (sabd > 0) {
        return 1;
      } else if (testInterior(a, b, c)) {
        return 1;
      } else {
        return -1;
      }
    }
    return sgn(sabd - sabc);
  }
  var abc = orient(a, b, c);
  if (abc > 0) {
    if (bcd > 0 && orient(a, b, d) > 0) {
      return 1;
    }
    return -1;
  } else if (abc < 0) {
    if (bcd > 0 || orient(a, b, d) > 0) {
      return 1;
    }
    return -1;
  } else {
    var abd = orient(a, b, d);
    if (abd > 0) {
      return 1;
    } else {
      if (testInterior(a, b, c)) {
        return 1;
      } else {
        return -1;
      }
    }
  }
}

},{"robust-orientation":137,"robust-product":138,"robust-sum":142,"signum":53,"two-sum":160}],53:[function(require,module,exports){
"use strict";

module.exports = function signum(x) {
  if (x < 0) {
    return -1;
  }
  if (x > 0) {
    return 1;
  }
  return 0.0;
};

},{}],54:[function(require,module,exports){
"use strict";

var createThunk = require("./lib/thunk.js");

function Procedure() {
  this.argTypes = [];
  this.shimArgs = [];
  this.arrayArgs = [];
  this.arrayBlockIndices = [];
  this.scalarArgs = [];
  this.offsetArgs = [];
  this.offsetArgIndex = [];
  this.indexArgs = [];
  this.shapeArgs = [];
  this.funcName = "";
  this.pre = null;
  this.body = null;
  this.post = null;
  this.debug = false;
}

function compileCwise(user_args) {
  //Create procedure
  var proc = new Procedure();

  //Parse blocks
  proc.pre = user_args.pre;
  proc.body = user_args.body;
  proc.post = user_args.post;

  //Parse arguments
  var proc_args = user_args.args.slice(0);
  proc.argTypes = proc_args;
  for (var i = 0; i < proc_args.length; ++i) {
    var arg_type = proc_args[i];
    if (arg_type === "array" || typeof arg_type === "object" && arg_type.blockIndices) {
      proc.argTypes[i] = "array";
      proc.arrayArgs.push(i);
      proc.arrayBlockIndices.push(arg_type.blockIndices ? arg_type.blockIndices : 0);
      proc.shimArgs.push("array" + i);
      if (i < proc.pre.args.length && proc.pre.args[i].count > 0) {
        throw new Error("cwise: pre() block may not reference array args");
      }
      if (i < proc.post.args.length && proc.post.args[i].count > 0) {
        throw new Error("cwise: post() block may not reference array args");
      }
    } else if (arg_type === "scalar") {
      proc.scalarArgs.push(i);
      proc.shimArgs.push("scalar" + i);
    } else if (arg_type === "index") {
      proc.indexArgs.push(i);
      if (i < proc.pre.args.length && proc.pre.args[i].count > 0) {
        throw new Error("cwise: pre() block may not reference array index");
      }
      if (i < proc.body.args.length && proc.body.args[i].lvalue) {
        throw new Error("cwise: body() block may not write to array index");
      }
      if (i < proc.post.args.length && proc.post.args[i].count > 0) {
        throw new Error("cwise: post() block may not reference array index");
      }
    } else if (arg_type === "shape") {
      proc.shapeArgs.push(i);
      if (i < proc.pre.args.length && proc.pre.args[i].lvalue) {
        throw new Error("cwise: pre() block may not write to array shape");
      }
      if (i < proc.body.args.length && proc.body.args[i].lvalue) {
        throw new Error("cwise: body() block may not write to array shape");
      }
      if (i < proc.post.args.length && proc.post.args[i].lvalue) {
        throw new Error("cwise: post() block may not write to array shape");
      }
    } else if (typeof arg_type === "object" && arg_type.offset) {
      proc.argTypes[i] = "offset";
      proc.offsetArgs.push({ array: arg_type.array, offset: arg_type.offset });
      proc.offsetArgIndex.push(i);
    } else {
      throw new Error("cwise: Unknown argument type " + proc_args[i]);
    }
  }

  //Make sure at least one array argument was specified
  if (proc.arrayArgs.length <= 0) {
    throw new Error("cwise: No array arguments specified");
  }

  //Make sure arguments are correct
  if (proc.pre.args.length > proc_args.length) {
    throw new Error("cwise: Too many arguments in pre() block");
  }
  if (proc.body.args.length > proc_args.length) {
    throw new Error("cwise: Too many arguments in body() block");
  }
  if (proc.post.args.length > proc_args.length) {
    throw new Error("cwise: Too many arguments in post() block");
  }

  //Check debug flag
  proc.debug = !!user_args.printCode || !!user_args.debug;

  //Retrieve name
  proc.funcName = user_args.funcName || "cwise";

  //Read in block size
  proc.blockSize = user_args.blockSize || 64;

  return createThunk(proc);
}

module.exports = compileCwise;

},{"./lib/thunk.js":56}],55:[function(require,module,exports){
"use strict";

var uniq = require("uniq"

// This function generates very simple loops analogous to how you typically traverse arrays (the outermost loop corresponds to the slowest changing index, the innermost loop to the fastest changing index)
// TODO: If two arrays have the same strides (and offsets) there is potential for decreasing the number of "pointers" and related variables. The drawback is that the type signature would become more specific and that there would thus be less potential for caching, but it might still be worth it, especially when dealing with large numbers of arguments.
);function innerFill(order, proc, body) {
  var dimension = order.length,
      nargs = proc.arrayArgs.length,
      has_index = proc.indexArgs.length > 0,
      code = [],
      vars = [],
      idx = 0,
      pidx = 0,
      i,
      j;
  for (i = 0; i < dimension; ++i) {
    // Iteration variables
    vars.push(["i", i, "=0"].join(""));
  }
  //Compute scan deltas
  for (j = 0; j < nargs; ++j) {
    for (i = 0; i < dimension; ++i) {
      pidx = idx;
      idx = order[i];
      if (i === 0) {
        // The innermost/fastest dimension's delta is simply its stride
        vars.push(["d", j, "s", i, "=t", j, "p", idx].join(""));
      } else {
        // For other dimensions the delta is basically the stride minus something which essentially "rewinds" the previous (more inner) dimension
        vars.push(["d", j, "s", i, "=(t", j, "p", idx, "-s", pidx, "*t", j, "p", pidx, ")"].join(""));
      }
    }
  }
  if (vars.length > 0) {
    code.push("var " + vars.join(","));
  }
  //Scan loop
  for (i = dimension - 1; i >= 0; --i) {
    // Start at largest stride and work your way inwards
    idx = order[i];
    code.push(["for(i", i, "=0;i", i, "<s", idx, ";++i", i, "){"].join(""));
  }
  //Push body of inner loop
  code.push(body
  //Advance scan pointers
  );for (i = 0; i < dimension; ++i) {
    pidx = idx;
    idx = order[i];
    for (j = 0; j < nargs; ++j) {
      code.push(["p", j, "+=d", j, "s", i].join(""));
    }
    if (has_index) {
      if (i > 0) {
        code.push(["index[", pidx, "]-=s", pidx].join(""));
      }
      code.push(["++index[", idx, "]"].join(""));
    }
    code.push("}");
  }
  return code.join("\n");
}

// Generate "outer" loops that loop over blocks of data, applying "inner" loops to the blocks by manipulating the local variables in such a way that the inner loop only "sees" the current block.
// TODO: If this is used, then the previous declaration (done by generateCwiseOp) of s* is essentially unnecessary.
//       I believe the s* are not used elsewhere (in particular, I don't think they're used in the pre/post parts and "shape" is defined independently), so it would be possible to make defining the s* dependent on what loop method is being used.
function outerFill(matched, order, proc, body) {
  var dimension = order.length,
      nargs = proc.arrayArgs.length,
      blockSize = proc.blockSize,
      has_index = proc.indexArgs.length > 0,
      code = [];
  for (var i = 0; i < nargs; ++i) {
    code.push(["var offset", i, "=p", i].join(""));
  }
  //Generate loops for unmatched dimensions
  // The order in which these dimensions are traversed is fairly arbitrary (from small stride to large stride, for the first argument)
  // TODO: It would be nice if the order in which these loops are placed would also be somehow "optimal" (at the very least we should check that it really doesn't hurt us if they're not).
  for (var i = matched; i < dimension; ++i) {
    code.push(["for(var j" + i + "=SS[", order[i], "]|0;j", i, ">0;){"].join("") // Iterate back to front
    );code.push(["if(j", i, "<", blockSize, "){"].join("") // Either decrease j by blockSize (s = blockSize), or set it to zero (after setting s = j).
    );code.push(["s", order[i], "=j", i].join(""));
    code.push(["j", i, "=0"].join(""));
    code.push(["}else{s", order[i], "=", blockSize].join(""));
    code.push(["j", i, "-=", blockSize, "}"].join(""));
    if (has_index) {
      code.push(["index[", order[i], "]=j", i].join(""));
    }
  }
  for (var i = 0; i < nargs; ++i) {
    var indexStr = ["offset" + i];
    for (var j = matched; j < dimension; ++j) {
      indexStr.push(["j", j, "*t", i, "p", order[j]].join(""));
    }
    code.push(["p", i, "=(", indexStr.join("+"), ")"].join(""));
  }
  code.push(innerFill(order, proc, body));
  for (var i = matched; i < dimension; ++i) {
    code.push("}");
  }
  return code.join("\n");
}

//Count the number of compatible inner orders
// This is the length of the longest common prefix of the arrays in orders.
// Each array in orders lists the dimensions of the correspond ndarray in order of increasing stride.
// This is thus the maximum number of dimensions that can be efficiently traversed by simple nested loops for all arrays.
function countMatches(orders) {
  var matched = 0,
      dimension = orders[0].length;
  while (matched < dimension) {
    for (var j = 1; j < orders.length; ++j) {
      if (orders[j][matched] !== orders[0][matched]) {
        return matched;
      }
    }
    ++matched;
  }
  return matched;
}

//Processes a block according to the given data types
// Replaces variable names by different ones, either "local" ones (that are then ferried in and out of the given array) or ones matching the arguments that the function performing the ultimate loop will accept.
function processBlock(block, proc, dtypes) {
  var code = block.body;
  var pre = [];
  var post = [];
  for (var i = 0; i < block.args.length; ++i) {
    var carg = block.args[i];
    if (carg.count <= 0) {
      continue;
    }
    var re = new RegExp(carg.name, "g");
    var ptrStr = "";
    var arrNum = proc.arrayArgs.indexOf(i);
    switch (proc.argTypes[i]) {
      case "offset":
        var offArgIndex = proc.offsetArgIndex.indexOf(i);
        var offArg = proc.offsetArgs[offArgIndex];
        arrNum = offArg.array;
        ptrStr = "+q" + offArgIndex; // Adds offset to the "pointer" in the array
      case "array":
        ptrStr = "p" + arrNum + ptrStr;
        var localStr = "l" + i;
        var arrStr = "a" + arrNum;
        if (proc.arrayBlockIndices[arrNum] === 0) {
          // Argument to body is just a single value from this array
          if (carg.count === 1) {
            // Argument/array used only once(?)
            if (dtypes[arrNum] === "generic") {
              if (carg.lvalue) {
                pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join("") // Is this necessary if the argument is ONLY used as an lvalue? (keep in mind that we can have a += something, so we would actually need to check carg.rvalue)
                );code = code.replace(re, localStr);
                post.push([arrStr, ".set(", ptrStr, ",", localStr, ")"].join(""));
              } else {
                code = code.replace(re, [arrStr, ".get(", ptrStr, ")"].join(""));
              }
            } else {
              code = code.replace(re, [arrStr, "[", ptrStr, "]"].join(""));
            }
          } else if (dtypes[arrNum] === "generic") {
            pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join("") // TODO: Could we optimize by checking for carg.rvalue?
            );code = code.replace(re, localStr);
            if (carg.lvalue) {
              post.push([arrStr, ".set(", ptrStr, ",", localStr, ")"].join(""));
            }
          } else {
            pre.push(["var ", localStr, "=", arrStr, "[", ptrStr, "]"].join("") // TODO: Could we optimize by checking for carg.rvalue?
            );code = code.replace(re, localStr);
            if (carg.lvalue) {
              post.push([arrStr, "[", ptrStr, "]=", localStr].join(""));
            }
          }
        } else {
          // Argument to body is a "block"
          var reStrArr = [carg.name],
              ptrStrArr = [ptrStr];
          for (var j = 0; j < Math.abs(proc.arrayBlockIndices[arrNum]); j++) {
            reStrArr.push("\\s*\\[([^\\]]+)\\]");
            ptrStrArr.push("$" + (j + 1) + "*t" + arrNum + "b" + j // Matched index times stride
            );
          }
          re = new RegExp(reStrArr.join(""), "g");
          ptrStr = ptrStrArr.join("+");
          if (dtypes[arrNum] === "generic") {
            /*if(carg.lvalue) {
              pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join("")) // Is this necessary if the argument is ONLY used as an lvalue? (keep in mind that we can have a += something, so we would actually need to check carg.rvalue)
              code = code.replace(re, localStr)
              post.push([arrStr, ".set(", ptrStr, ",", localStr,")"].join(""))
            } else {
              code = code.replace(re, [arrStr, ".get(", ptrStr, ")"].join(""))
            }*/
            throw new Error("cwise: Generic arrays not supported in combination with blocks!");
          } else {
            // This does not produce any local variables, even if variables are used multiple times. It would be possible to do so, but it would complicate things quite a bit.
            code = code.replace(re, [arrStr, "[", ptrStr, "]"].join(""));
          }
        }
        break;
      case "scalar":
        code = code.replace(re, "Y" + proc.scalarArgs.indexOf(i));
        break;
      case "index":
        code = code.replace(re, "index");
        break;
      case "shape":
        code = code.replace(re, "shape");
        break;
    }
  }
  return [pre.join("\n"), code, post.join("\n")].join("\n").trim();
}

function typeSummary(dtypes) {
  var summary = new Array(dtypes.length);
  var allEqual = true;
  for (var i = 0; i < dtypes.length; ++i) {
    var t = dtypes[i];
    var digits = t.match(/\d+/);
    if (!digits) {
      digits = "";
    } else {
      digits = digits[0];
    }
    if (t.charAt(0) === 0) {
      summary[i] = "u" + t.charAt(1) + digits;
    } else {
      summary[i] = t.charAt(0) + digits;
    }
    if (i > 0) {
      allEqual = allEqual && summary[i] === summary[i - 1];
    }
  }
  if (allEqual) {
    return summary[0];
  }
  return summary.join("");
}

//Generates a cwise operator
function generateCWiseOp(proc, typesig) {

  //Compute dimension
  // Arrays get put first in typesig, and there are two entries per array (dtype and order), so this gets the number of dimensions in the first array arg.
  var dimension = typesig[1].length - Math.abs(proc.arrayBlockIndices[0]) | 0;
  var orders = new Array(proc.arrayArgs.length);
  var dtypes = new Array(proc.arrayArgs.length);
  for (var i = 0; i < proc.arrayArgs.length; ++i) {
    dtypes[i] = typesig[2 * i];
    orders[i] = typesig[2 * i + 1];
  }

  //Determine where block and loop indices start and end
  var blockBegin = [],
      blockEnd = []; // These indices are exposed as blocks
  var loopBegin = [],
      loopEnd = []; // These indices are iterated over
  var loopOrders = []; // orders restricted to the loop indices
  for (var i = 0; i < proc.arrayArgs.length; ++i) {
    if (proc.arrayBlockIndices[i] < 0) {
      loopBegin.push(0);
      loopEnd.push(dimension);
      blockBegin.push(dimension);
      blockEnd.push(dimension + proc.arrayBlockIndices[i]);
    } else {
      loopBegin.push(proc.arrayBlockIndices[i] // Non-negative
      );loopEnd.push(proc.arrayBlockIndices[i] + dimension);
      blockBegin.push(0);
      blockEnd.push(proc.arrayBlockIndices[i]);
    }
    var newOrder = [];
    for (var j = 0; j < orders[i].length; j++) {
      if (loopBegin[i] <= orders[i][j] && orders[i][j] < loopEnd[i]) {
        newOrder.push(orders[i][j] - loopBegin[i] // If this is a loop index, put it in newOrder, subtracting loopBegin, to make sure that all loopOrders are using a common set of indices.
        );
      }
    }
    loopOrders.push(newOrder);
  }

  //First create arguments for procedure
  var arglist = ["SS"]; // SS is the overall shape over which we iterate
  var code = ["'use strict'"];
  var vars = [];

  for (var j = 0; j < dimension; ++j) {
    vars.push(["s", j, "=SS[", j, "]"].join("") // The limits for each dimension.
    );
  }
  for (var i = 0; i < proc.arrayArgs.length; ++i) {
    arglist.push("a" + i // Actual data array
    );arglist.push("t" + i // Strides
    );arglist.push("p" + i // Offset in the array at which the data starts (also used for iterating over the data)

    );for (var j = 0; j < dimension; ++j) {
      // Unpack the strides into vars for looping
      vars.push(["t", i, "p", j, "=t", i, "[", loopBegin[i] + j, "]"].join(""));
    }

    for (var j = 0; j < Math.abs(proc.arrayBlockIndices[i]); ++j) {
      // Unpack the strides into vars for block iteration
      vars.push(["t", i, "b", j, "=t", i, "[", blockBegin[i] + j, "]"].join(""));
    }
  }
  for (var i = 0; i < proc.scalarArgs.length; ++i) {
    arglist.push("Y" + i);
  }
  if (proc.shapeArgs.length > 0) {
    vars.push("shape=SS.slice(0)" // Makes the shape over which we iterate available to the user defined functions (so you can use width/height for example)
    );
  }
  if (proc.indexArgs.length > 0) {
    // Prepare an array to keep track of the (logical) indices, initialized to dimension zeroes.
    var zeros = new Array(dimension);
    for (var i = 0; i < dimension; ++i) {
      zeros[i] = "0";
    }
    vars.push(["index=[", zeros.join(","), "]"].join(""));
  }
  for (var i = 0; i < proc.offsetArgs.length; ++i) {
    // Offset arguments used for stencil operations
    var off_arg = proc.offsetArgs[i];
    var init_string = [];
    for (var j = 0; j < off_arg.offset.length; ++j) {
      if (off_arg.offset[j] === 0) {
        continue;
      } else if (off_arg.offset[j] === 1) {
        init_string.push(["t", off_arg.array, "p", j].join(""));
      } else {
        init_string.push([off_arg.offset[j], "*t", off_arg.array, "p", j].join(""));
      }
    }
    if (init_string.length === 0) {
      vars.push("q" + i + "=0");
    } else {
      vars.push(["q", i, "=", init_string.join("+")].join(""));
    }
  }

  //Prepare this variables
  var thisVars = uniq([].concat(proc.pre.thisVars).concat(proc.body.thisVars).concat(proc.post.thisVars));
  vars = vars.concat(thisVars);
  if (vars.length > 0) {
    code.push("var " + vars.join(","));
  }
  for (var i = 0; i < proc.arrayArgs.length; ++i) {
    code.push("p" + i + "|=0");
  }

  //Inline prelude
  if (proc.pre.body.length > 3) {
    code.push(processBlock(proc.pre, proc, dtypes));
  }

  //Process body
  var body = processBlock(proc.body, proc, dtypes);
  var matched = countMatches(loopOrders);
  if (matched < dimension) {
    code.push(outerFill(matched, loopOrders[0], proc, body) // TODO: Rather than passing loopOrders[0], it might be interesting to look at passing an order that represents the majority of the arguments for example.
    );
  } else {
    code.push(innerFill(loopOrders[0], proc, body));
  }

  //Inline epilog
  if (proc.post.body.length > 3) {
    code.push(processBlock(proc.post, proc, dtypes));
  }

  if (proc.debug) {
    console.log("-----Generated cwise routine for ", typesig, ":\n" + code.join("\n") + "\n----------");
  }

  var loopName = [proc.funcName || "unnamed", "_cwise_loop_", orders[0].join("s"), "m", matched, typeSummary(dtypes)].join("");
  var f = new Function(["function ", loopName, "(", arglist.join(","), "){", code.join("\n"), "} return ", loopName].join(""));
  return f();
}
module.exports = generateCWiseOp;

},{"uniq":164}],56:[function(require,module,exports){
"use strict";

// The function below is called when constructing a cwise function object, and does the following:
// A function object is constructed which accepts as argument a compilation function and returns another function.
// It is this other function that is eventually returned by createThunk, and this function is the one that actually
// checks whether a certain pattern of arguments has already been used before and compiles new loops as needed.
// The compilation passed to the first function object is used for compiling new functions.
// Once this function object is created, it is called with compile as argument, where the first argument of compile
// is bound to "proc" (essentially containing a preprocessed version of the user arguments to cwise).
// So createThunk roughly works like this:
// function createThunk(proc) {
//   var thunk = function(compileBound) {
//     var CACHED = {}
//     return function(arrays and scalars) {
//       if (dtype and order of arrays in CACHED) {
//         var func = CACHED[dtype and order of arrays]
//       } else {
//         var func = CACHED[dtype and order of arrays] = compileBound(dtype and order of arrays)
//       }
//       return func(arrays and scalars)
//     }
//   }
//   return thunk(compile.bind1(proc))
// }

var compile = require("./compile.js");

function createThunk(proc) {
  var code = ["'use strict'", "var CACHED={}"];
  var vars = [];
  var thunkName = proc.funcName + "_cwise_thunk";

  //Build thunk
  code.push(["return function ", thunkName, "(", proc.shimArgs.join(","), "){"].join(""));
  var typesig = [];
  var string_typesig = [];
  var proc_args = [["array", proc.arrayArgs[0], ".shape.slice(", // Slice shape so that we only retain the shape over which we iterate (which gets passed to the cwise operator as SS).
  Math.max(0, proc.arrayBlockIndices[0]), proc.arrayBlockIndices[0] < 0 ? "," + proc.arrayBlockIndices[0] + ")" : ")"].join("")];
  var shapeLengthConditions = [],
      shapeConditions = [];
  // Process array arguments
  for (var i = 0; i < proc.arrayArgs.length; ++i) {
    var j = proc.arrayArgs[i];
    vars.push(["t", j, "=array", j, ".dtype,", "r", j, "=array", j, ".order"].join(""));
    typesig.push("t" + j);
    typesig.push("r" + j);
    string_typesig.push("t" + j);
    string_typesig.push("r" + j + ".join()");
    proc_args.push("array" + j + ".data");
    proc_args.push("array" + j + ".stride");
    proc_args.push("array" + j + ".offset|0");
    if (i > 0) {
      // Gather conditions to check for shape equality (ignoring block indices)
      shapeLengthConditions.push("array" + proc.arrayArgs[0] + ".shape.length===array" + j + ".shape.length+" + (Math.abs(proc.arrayBlockIndices[0]) - Math.abs(proc.arrayBlockIndices[i])));
      shapeConditions.push("array" + proc.arrayArgs[0] + ".shape[shapeIndex+" + Math.max(0, proc.arrayBlockIndices[0]) + "]===array" + j + ".shape[shapeIndex+" + Math.max(0, proc.arrayBlockIndices[i]) + "]");
    }
  }
  // Check for shape equality
  if (proc.arrayArgs.length > 1) {
    code.push("if (!(" + shapeLengthConditions.join(" && ") + ")) throw new Error('cwise: Arrays do not all have the same dimensionality!')");
    code.push("for(var shapeIndex=array" + proc.arrayArgs[0] + ".shape.length-" + Math.abs(proc.arrayBlockIndices[0]) + "; shapeIndex-->0;) {");
    code.push("if (!(" + shapeConditions.join(" && ") + ")) throw new Error('cwise: Arrays do not all have the same shape!')");
    code.push("}");
  }
  // Process scalar arguments
  for (var i = 0; i < proc.scalarArgs.length; ++i) {
    proc_args.push("scalar" + proc.scalarArgs[i]);
  }
  // Check for cached function (and if not present, generate it)
  vars.push(["type=[", string_typesig.join(","), "].join()"].join(""));
  vars.push("proc=CACHED[type]");
  code.push("var " + vars.join(","));

  code.push(["if(!proc){", "CACHED[type]=proc=compile([", typesig.join(","), "])}", "return proc(", proc_args.join(","), ")}"].join(""));

  if (proc.debug) {
    console.log("-----Generated thunk:\n" + code.join("\n") + "\n----------");
  }

  //Compile thunk
  var thunk = new Function("compile", code.join("\n"));
  return thunk(compile.bind(undefined, proc));
}

module.exports = createThunk;

},{"./compile.js":55}],57:[function(require,module,exports){
module.exports = require("cwise-compiler");

},{"cwise-compiler":54}],58:[function(require,module,exports){
(function (Buffer){
var hasTypedArrays = false;
if (typeof Float64Array !== "undefined") {
  var DOUBLE_VIEW = new Float64Array(1),
      UINT_VIEW = new Uint32Array(DOUBLE_VIEW.buffer);
  DOUBLE_VIEW[0] = 1.0;
  hasTypedArrays = true;
  if (UINT_VIEW[1] === 0x3ff00000) {
    //Use little endian
    module.exports = function doubleBitsLE(n) {
      DOUBLE_VIEW[0] = n;
      return [UINT_VIEW[0], UINT_VIEW[1]];
    };
    function toDoubleLE(lo, hi) {
      UINT_VIEW[0] = lo;
      UINT_VIEW[1] = hi;
      return DOUBLE_VIEW[0];
    }
    module.exports.pack = toDoubleLE;
    function lowUintLE(n) {
      DOUBLE_VIEW[0] = n;
      return UINT_VIEW[0];
    }
    module.exports.lo = lowUintLE;
    function highUintLE(n) {
      DOUBLE_VIEW[0] = n;
      return UINT_VIEW[1];
    }
    module.exports.hi = highUintLE;
  } else if (UINT_VIEW[0] === 0x3ff00000) {
    //Use big endian
    module.exports = function doubleBitsBE(n) {
      DOUBLE_VIEW[0] = n;
      return [UINT_VIEW[1], UINT_VIEW[0]];
    };
    function toDoubleBE(lo, hi) {
      UINT_VIEW[1] = lo;
      UINT_VIEW[0] = hi;
      return DOUBLE_VIEW[0];
    }
    module.exports.pack = toDoubleBE;
    function lowUintBE(n) {
      DOUBLE_VIEW[0] = n;
      return UINT_VIEW[1];
    }
    module.exports.lo = lowUintBE;
    function highUintBE(n) {
      DOUBLE_VIEW[0] = n;
      return UINT_VIEW[0];
    }
    module.exports.hi = highUintBE;
  } else {
    hasTypedArrays = false;
  }
}
if (!hasTypedArrays) {
  var buffer = new Buffer(8);
  module.exports = function doubleBits(n) {
    buffer.writeDoubleLE(n, 0, true);
    return [buffer.readUInt32LE(0, true), buffer.readUInt32LE(4, true)];
  };
  function toDouble(lo, hi) {
    buffer.writeUInt32LE(lo, 0, true);
    buffer.writeUInt32LE(hi, 4, true);
    return buffer.readDoubleLE(0, true);
  }
  module.exports.pack = toDouble;
  function lowUint(n) {
    buffer.writeDoubleLE(n, 0, true);
    return buffer.readUInt32LE(0, true);
  }
  module.exports.lo = lowUint;
  function highUint(n) {
    buffer.writeDoubleLE(n, 0, true);
    return buffer.readUInt32LE(4, true);
  }
  module.exports.hi = highUint;
}

module.exports.sign = function (n) {
  return module.exports.hi(n) >>> 31;
};

module.exports.exponent = function (n) {
  var b = module.exports.hi(n);
  return (b << 1 >>> 21) - 1023;
};

module.exports.fraction = function (n) {
  var lo = module.exports.lo(n);
  var hi = module.exports.hi(n);
  var b = hi & (1 << 20) - 1;
  if (hi & 0x7ff00000) {
    b += 1 << 20;
  }
  return [lo, b];
};

module.exports.denormalized = function (n) {
  var hi = module.exports.hi(n);
  return !(hi & 0x7ff00000);
};

}).call(this,require("buffer").Buffer)
},{"buffer":36}],59:[function(require,module,exports){
"use strict";

function dupe_array(count, value, i) {
  var c = count[i] | 0;
  if (c <= 0) {
    return [];
  }
  var result = new Array(c),
      j;
  if (i === count.length - 1) {
    for (j = 0; j < c; ++j) {
      result[j] = value;
    }
  } else {
    for (j = 0; j < c; ++j) {
      result[j] = dupe_array(count, value, i + 1);
    }
  }
  return result;
}

function dupe_number(count, value) {
  var result, i;
  result = new Array(count);
  for (i = 0; i < count; ++i) {
    result[i] = value;
  }
  return result;
}

function dupe(count, value) {
  if (typeof value === "undefined") {
    value = 0;
  }
  switch (typeof count) {
    case "number":
      if (count > 0) {
        return dupe_number(count | 0, value);
      }
      break;
    case "object":
      if (typeof count.length === "number") {
        return dupe_array(count, value, 0);
      }
      break;
  }
  return [];
}

module.exports = dupe;

},{}],60:[function(require,module,exports){
"use strict";

module.exports = edgeToAdjacency;

var uniq = require("uniq");

function edgeToAdjacency(edges, numVertices) {
  var numEdges = edges.length;
  if (typeof numVertices !== "number") {
    numVertices = 0;
    for (var i = 0; i < numEdges; ++i) {
      var e = edges[i];
      numVertices = Math.max(numVertices, e[0], e[1]);
    }
    numVertices = (numVertices | 0) + 1;
  }
  numVertices = numVertices | 0;
  var adj = new Array(numVertices);
  for (var i = 0; i < numVertices; ++i) {
    adj[i] = [];
  }
  for (var i = 0; i < numEdges; ++i) {
    var e = edges[i];
    adj[e[0]].push(e[1]);
    adj[e[1]].push(e[0]);
  }
  for (var j = 0; j < numVertices; ++j) {
    uniq(adj[j], function (a, b) {
      return a - b;
    });
  }
  return adj;
}

},{"uniq":164}],61:[function(require,module,exports){
module.exports = getSize;

function getSize(element) {
  // Handle cases where the element is not already
  // attached to the DOM by briefly appending it
  // to document.body, and removing it again later.
  if (element === window || element === document.body) {
    return [window.innerWidth, window.innerHeight];
  }

  if (!element.parentNode) {
    var temporary = true;
    document.body.appendChild(element);
  }

  var bounds = element.getBoundingClientRect();
  var styles = getComputedStyle(element);
  var height = (bounds.height | 0) + parse(styles.getPropertyValue('margin-top')) + parse(styles.getPropertyValue('margin-bottom'));
  var width = (bounds.width | 0) + parse(styles.getPropertyValue('margin-left')) + parse(styles.getPropertyValue('margin-right'));

  if (temporary) {
    document.body.removeChild(element);
  }

  return [width, height];
}

function parse(prop) {
  return parseFloat(prop) || 0;
}

},{}],62:[function(require,module,exports){
if (!Array.prototype.fill) {
    Array.prototype.fill = function (value) {

        // Steps 1-2.
        if (this == null) {
            throw new TypeError('this is null or not defined');
        }

        var O = Object(this);

        // Steps 3-5.
        var len = O.length >>> 0;

        // Steps 6-7.
        var start = arguments[1];
        var relativeStart = start >> 0;

        // Step 8.
        var k = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len);

        // Steps 9-10.
        var end = arguments[2];
        var relativeEnd = end === undefined ? len : end >> 0;

        // Step 11.
        var final = relativeEnd < 0 ? Math.max(len + relativeEnd, 0) : Math.min(relativeEnd, len);

        // Step 12.
        while (k < final) {
            O[k] = value;
            k++;
        }

        // Step 13.
        return O;
    };
}

},{}],63:[function(require,module,exports){
require('./arr-fill');
require('typedarray-methods');
require('get-float-time-domain-data');
const css = require('insert-styles');

css("/*! normalize.css v7.0.0 | MIT License | github.com/necolas/normalize.css */\n\n/* Document\n   ========================================================================== */\n\n/**\n * 1. Correct the line height in all browsers.\n * 2. Prevent adjustments of font size after orientation changes in\n *    IE on Windows Phone and in iOS.\n */\n\nhtml {\n  line-height: 1.15; /* 1 */\n  -ms-text-size-adjust: 100%; /* 2 */\n  -webkit-text-size-adjust: 100%; /* 2 */\n}\n\n/* Sections\n   ========================================================================== */\n\n/**\n * Remove the margin in all browsers (opinionated).\n */\n\nbody {\n  margin: 0;\n}\n\n/**\n * Add the correct display in IE 9-.\n */\n\narticle,\naside,\nfooter,\nheader,\nnav,\nsection {\n  display: block;\n}\n\n/**\n * Correct the font size and margin on `h1` elements within `section` and\n * `article` contexts in Chrome, Firefox, and Safari.\n */\n\nh1 {\n  font-size: 2em;\n  margin: 0.67em 0;\n}\n\n/* Grouping content\n   ========================================================================== */\n\n/**\n * Add the correct display in IE 9-.\n * 1. Add the correct display in IE.\n */\n\nfigcaption,\nfigure,\nmain { /* 1 */\n  display: block;\n}\n\n/**\n * Add the correct margin in IE 8.\n */\n\nfigure {\n  margin: 1em 40px;\n}\n\n/**\n * 1. Add the correct box sizing in Firefox.\n * 2. Show the overflow in Edge and IE.\n */\n\nhr {\n  box-sizing: content-box; /* 1 */\n  height: 0; /* 1 */\n  overflow: visible; /* 2 */\n}\n\n/**\n * 1. Correct the inheritance and scaling of font size in all browsers.\n * 2. Correct the odd `em` font sizing in all browsers.\n */\n\npre {\n  font-family: monospace, monospace; /* 1 */\n  font-size: 1em; /* 2 */\n}\n\n/* Text-level semantics\n   ========================================================================== */\n\n/**\n * 1. Remove the gray background on active links in IE 10.\n * 2. Remove gaps in links underline in iOS 8+ and Safari 8+.\n */\n\na {\n  background-color: transparent; /* 1 */\n  -webkit-text-decoration-skip: objects; /* 2 */\n}\n\n/**\n * 1. Remove the bottom border in Chrome 57- and Firefox 39-.\n * 2. Add the correct text decoration in Chrome, Edge, IE, Opera, and Safari.\n */\n\nabbr[title] {\n  border-bottom: none; /* 1 */\n  text-decoration: underline; /* 2 */\n  text-decoration: underline dotted; /* 2 */\n}\n\n/**\n * Prevent the duplicate application of `bolder` by the next rule in Safari 6.\n */\n\nb,\nstrong {\n  font-weight: inherit;\n}\n\n/**\n * Add the correct font weight in Chrome, Edge, and Safari.\n */\n\nb,\nstrong {\n  font-weight: bolder;\n}\n\n/**\n * 1. Correct the inheritance and scaling of font size in all browsers.\n * 2. Correct the odd `em` font sizing in all browsers.\n */\n\ncode,\nkbd,\nsamp {\n  font-family: monospace, monospace; /* 1 */\n  font-size: 1em; /* 2 */\n}\n\n/**\n * Add the correct font style in Android 4.3-.\n */\n\ndfn {\n  font-style: italic;\n}\n\n/**\n * Add the correct background and color in IE 9-.\n */\n\nmark {\n  background-color: #ff0;\n  color: #000;\n}\n\n/**\n * Add the correct font size in all browsers.\n */\n\nsmall {\n  font-size: 80%;\n}\n\n/**\n * Prevent `sub` and `sup` elements from affecting the line height in\n * all browsers.\n */\n\nsub,\nsup {\n  font-size: 75%;\n  line-height: 0;\n  position: relative;\n  vertical-align: baseline;\n}\n\nsub {\n  bottom: -0.25em;\n}\n\nsup {\n  top: -0.5em;\n}\n\n/* Embedded content\n   ========================================================================== */\n\n/**\n * Add the correct display in IE 9-.\n */\n\naudio,\nvideo {\n  display: inline-block;\n}\n\n/**\n * Add the correct display in iOS 4-7.\n */\n\naudio:not([controls]) {\n  display: none;\n  height: 0;\n}\n\n/**\n * Remove the border on images inside links in IE 10-.\n */\n\nimg {\n  border-style: none;\n}\n\n/**\n * Hide the overflow in IE.\n */\n\nsvg:not(:root) {\n  overflow: hidden;\n}\n\n/* Forms\n   ========================================================================== */\n\n/**\n * 1. Change the font styles in all browsers (opinionated).\n * 2. Remove the margin in Firefox and Safari.\n */\n\nbutton,\ninput,\noptgroup,\nselect,\ntextarea {\n  font-family: sans-serif; /* 1 */\n  font-size: 100%; /* 1 */\n  line-height: 1.15; /* 1 */\n  margin: 0; /* 2 */\n}\n\n/**\n * Show the overflow in IE.\n * 1. Show the overflow in Edge.\n */\n\nbutton,\ninput { /* 1 */\n  overflow: visible;\n}\n\n/**\n * Remove the inheritance of text transform in Edge, Firefox, and IE.\n * 1. Remove the inheritance of text transform in Firefox.\n */\n\nbutton,\nselect { /* 1 */\n  text-transform: none;\n}\n\n/**\n * 1. Prevent a WebKit bug where (2) destroys native `audio` and `video`\n *    controls in Android 4.\n * 2. Correct the inability to style clickable types in iOS and Safari.\n */\n\nbutton,\nhtml [type=\"button\"], /* 1 */\n[type=\"reset\"],\n[type=\"submit\"] {\n  -webkit-appearance: button; /* 2 */\n}\n\n/**\n * Remove the inner border and padding in Firefox.\n */\n\nbutton::-moz-focus-inner,\n[type=\"button\"]::-moz-focus-inner,\n[type=\"reset\"]::-moz-focus-inner,\n[type=\"submit\"]::-moz-focus-inner {\n  border-style: none;\n  padding: 0;\n}\n\n/**\n * Restore the focus styles unset by the previous rule.\n */\n\nbutton:-moz-focusring,\n[type=\"button\"]:-moz-focusring,\n[type=\"reset\"]:-moz-focusring,\n[type=\"submit\"]:-moz-focusring {\n  outline: 1px dotted ButtonText;\n}\n\n/**\n * Correct the padding in Firefox.\n */\n\nfieldset {\n  padding: 0.35em 0.75em 0.625em;\n}\n\n/**\n * 1. Correct the text wrapping in Edge and IE.\n * 2. Correct the color inheritance from `fieldset` elements in IE.\n * 3. Remove the padding so developers are not caught out when they zero out\n *    `fieldset` elements in all browsers.\n */\n\nlegend {\n  box-sizing: border-box; /* 1 */\n  color: inherit; /* 2 */\n  display: table; /* 1 */\n  max-width: 100%; /* 1 */\n  padding: 0; /* 3 */\n  white-space: normal; /* 1 */\n}\n\n/**\n * 1. Add the correct display in IE 9-.\n * 2. Add the correct vertical alignment in Chrome, Firefox, and Opera.\n */\n\nprogress {\n  display: inline-block; /* 1 */\n  vertical-align: baseline; /* 2 */\n}\n\n/**\n * Remove the default vertical scrollbar in IE.\n */\n\ntextarea {\n  overflow: auto;\n}\n\n/**\n * 1. Add the correct box sizing in IE 10-.\n * 2. Remove the padding in IE 10-.\n */\n\n[type=\"checkbox\"],\n[type=\"radio\"] {\n  box-sizing: border-box; /* 1 */\n  padding: 0; /* 2 */\n}\n\n/**\n * Correct the cursor style of increment and decrement buttons in Chrome.\n */\n\n[type=\"number\"]::-webkit-inner-spin-button,\n[type=\"number\"]::-webkit-outer-spin-button {\n  height: auto;\n}\n\n/**\n * 1. Correct the odd appearance in Chrome and Safari.\n * 2. Correct the outline style in Safari.\n */\n\n[type=\"search\"] {\n  -webkit-appearance: textfield; /* 1 */\n  outline-offset: -2px; /* 2 */\n}\n\n/**\n * Remove the inner padding and cancel buttons in Chrome and Safari on macOS.\n */\n\n[type=\"search\"]::-webkit-search-cancel-button,\n[type=\"search\"]::-webkit-search-decoration {\n  -webkit-appearance: none;\n}\n\n/**\n * 1. Correct the inability to style clickable types in iOS and Safari.\n * 2. Change font properties to `inherit` in Safari.\n */\n\n::-webkit-file-upload-button {\n  -webkit-appearance: button; /* 1 */\n  font: inherit; /* 2 */\n}\n\n/* Interactive\n   ========================================================================== */\n\n/*\n * Add the correct display in IE 9-.\n * 1. Add the correct display in Edge, IE, and Firefox.\n */\n\ndetails, /* 1 */\nmenu {\n  display: block;\n}\n\n/*\n * Add the correct display in all browsers.\n */\n\nsummary {\n  display: list-item;\n}\n\n/* Scripting\n   ========================================================================== */\n\n/**\n * Add the correct display in IE 9-.\n */\n\ncanvas {\n  display: inline-block;\n}\n\n/**\n * Add the correct display in IE.\n */\n\ntemplate {\n  display: none;\n}\n\n/* Hidden\n   ========================================================================== */\n\n/**\n * Add the correct display in IE 10-.\n */\n\n[hidden] {\n  display: none;\n}\n");

css(`
	html {
		touch-action: manipulation;
	}
`);

addMeta({
	name: 'viewport',
	content: 'width=device-width, initial-scale=1, shrink-to-fit=no, user-scalable=0'
});
addMeta({
	'http-equiv': 'x-ua-compatible',
	content: 'ie=edge'
});
addMeta({
	charset: 'utf-8'
});

function addMeta(obj) {
	let meta = document.createElement('meta');
	let qs = 'meta';
	for (let name in obj) {
		qs += `[${name}]`;
		meta.setAttribute(name, obj[name]);
	}
	if (!document.querySelector(qs)) {
		document.head.insertBefore(meta, document.head.firstChild);
	}
}

},{"./arr-fill":62,"get-float-time-domain-data":69,"insert-styles":102,"typedarray-methods":161}],64:[function(require,module,exports){
'use strict';

var SDF = require('tiny-sdf');

module.exports = atlas;

function atlas(options) {
	options = options || {};

	var canvas = options.canvas || document.createElement('canvas');
	var family = options.family || 'monospace';
	var shape = options.shape || [512, 512];
	var step = options.step || [32, 32];
	var size = options.size || 16;
	var chars = options.chars || [32, 126];
	var bufferSize = Math.floor((step[0] - size) / 2);
	var radius = options.radius || bufferSize * 1.5;
	var sdf = new SDF(size, bufferSize, radius, 0, family);
	var vAlign = options.align || true;
	var i, j;

	if (typeof size === 'number') {
		size = size + 'px';
	}

	if (!Array.isArray(chars)) {
		chars = String(chars).split('');
	} else if (chars.length === 2 && typeof chars[0] === 'number' && typeof chars[1] === 'number') {
		var newchars = [];

		for (i = chars[0], j = 0; i <= chars[1]; i++) {
			newchars[j++] = String.fromCharCode(i);
		}

		chars = newchars;
	}

	shape = shape.slice();
	canvas.width = shape[0];
	canvas.height = shape[1];

	var ctx = canvas.getContext('2d');

	ctx.fillStyle = '#000';
	ctx.fillRect(0, 0, canvas.width, canvas.height);
	ctx.font = size + ' ' + family;
	ctx.textBaseline = 'middle';

	var x = 0;
	var y = 0;
	var len = Math.min(chars.length, Math.floor(shape[0] / step[0]) * Math.ceil(shape[1] / step[1])

	// hack tiny-sdf to render centered
	//FIXME: get rif of it by [possibly] PR to tiny-sdf
	);var align = sdf.ctx.textAlign;
	var buffer = sdf.buffer;

	sdf.ctx.textAlign = 'center';
	sdf.buffer = sdf.size / 2;

	for (i = 0; i < len; i++) {
		var data = sdf.draw(chars[i]);

		var offY = 0;
		if (vAlign) offY = getAlignOffset(data);

		ctx.putImageData(data, x, y - offY);

		x += step[0];
		if (x > shape[0] - step[0]) {
			x = 0;
			y += step[1];
		}
	}

	// unhack tiny-sdf
	sdf.ctx.textAlign = align;
	sdf.buffer = buffer;

	return canvas;

	function getAlignOffset(data) {
		var buf = data.data,
		    w = data.width,
		    h = data.height;

		var top = 0,
		    bottom = 0,
		    x,
		    y,
		    r,
		    line;

		//find top boundary
		for (y = 0; y < h; y++) {
			line = y * w * 4;
			for (x = 0; x < w; x++) {
				r = buf[line + x * 4];

				if (r > 0) {
					top = y;
					break;
				}
			}
			if (top) break;
		}

		//find bottom boundary
		for (y = h; y--;) {
			line = y * w * 4;
			for (x = 0; x < w; x++) {
				r = buf[line + x * 4];

				if (r > 0) {
					bottom = y;
					break;
				}
			}
			if (bottom) break;
		}

		return top - .5 * (top + (h - bottom));
	}
}

},{"tiny-sdf":155}],65:[function(require,module,exports){
/**
 * @module fps-indicator
 */
'use strict';

const raf = require('raf');
const now = require('right-now');
const css = require('to-css');

module.exports = fps;

function fps(opts) {
	if (!(this instanceof fps)) return new fps(opts);

	if (typeof opts === 'string') opts = { position: opts };
	opts = opts || {};

	if (opts.container) {
		if (typeof opts.container === 'string') {
			this.container = document.querySelector(opts.container);
		} else {
			this.container = opts.container;
		}
	} else {
		this.container = document.body || document.documentElement;
	}

	//init fps
	this.element = document.createElement('div');
	this.element.classList.add('fps');
	this.element.innerHTML = `
		<div class="fps-bg"></div>
		<canvas class="fps-canvas"></canvas>
		<span class="fps-text">fps <span class="fps-value">60.0</span></span>
	`;
	this.container.appendChild(this.element);

	this.canvas = this.element.querySelector('.fps-canvas');
	this.textEl = this.element.querySelector('.fps-text');
	this.valueEl = this.element.querySelector('.fps-value');
	this.bgEl = this.element.querySelector('.fps-bg');

	let style = opts.css || opts.style || ``;
	if (typeof style === 'object') style = css(style);

	let posCss = ``;
	switch (opts.position) {
		case 'top-left':
			posCss = `left: 0; top: 0;`;
			break;
		case 'top-right':
			posCss = `right: 0; top: 0;`;
			break;
		case 'bottom-right':
			posCss = `right: 0; bottom: 0;`;
			break;
		case 'bottom-left':
			posCss = `left: 0; bottom: 0;`;
			break;
		default:
			posCss = `left: 0; bottom: 0;`;
	}

	this.element.style.cssText = `
		line-height: 1;
		position: absolute;
		font-family: Roboto, sans-serif;
		z-index: 1;
		font-weight: 300;
		font-size: small;
		padding: 1rem;
		${posCss}` + (opts.color ? `color: ${opts.color}` : ``) + style;

	this.canvas.style.cssText = `
		position: relative;
		width: 2em;
		height: 1em;
		display: block;
		float: left;
		margin-right: .333em;
	`;

	this.bgEl.style.cssText = `
		position: absolute;
		height: 1em;
		width: 2em;
		background: currentcolor;
		opacity: .1;
	`;

	this.canvas.width = parseInt(getComputedStyle(this.canvas).width) || 1;
	this.canvas.height = parseInt(getComputedStyle(this.canvas).height) || 1;

	this.context = this.canvas.getContext('2d');

	let ctx = this.context;
	let w = this.canvas.width;
	let h = this.canvas.height;
	let count = 0;
	let lastTime = 0;
	let values = opts.values || Array(this.canvas.width);
	let period = opts.period || 1000;
	let max = opts.max || 100;

	//enable update routine
	let that = this;
	raf(function measure() {
		count++;
		let t = now();

		if (t - lastTime > period) {
			lastTime = t;
			values.push(count / (max * period * 0.001));
			values = values.slice(-w);
			count = 0;

			ctx.clearRect(0, 0, w, h);
			ctx.fillStyle = getComputedStyle(that.canvas).color;
			for (let i = w; i--;) {
				let value = values[i];
				if (value == null) break;
				ctx.fillRect(i, h - h * value, 1, h * value);
			}

			that.valueEl.innerHTML = (values[values.length - 1] * max).toFixed(1);
		}

		raf(measure);
	});
}

},{"raf":128,"right-now":135,"to-css":156}],66:[function(require,module,exports){
"use strict";

module.exports = createRBTree;

var RED = 0;
var BLACK = 1;

function RBNode(color, key, value, left, right, count) {
  this._color = color;
  this.key = key;
  this.value = value;
  this.left = left;
  this.right = right;
  this._count = count;
}

function cloneNode(node) {
  return new RBNode(node._color, node.key, node.value, node.left, node.right, node._count);
}

function repaint(color, node) {
  return new RBNode(color, node.key, node.value, node.left, node.right, node._count);
}

function recount(node) {
  node._count = 1 + (node.left ? node.left._count : 0) + (node.right ? node.right._count : 0);
}

function RedBlackTree(compare, root) {
  this._compare = compare;
  this.root = root;
}

var proto = RedBlackTree.prototype;

Object.defineProperty(proto, "keys", {
  get: function () {
    var result = [];
    this.forEach(function (k, v) {
      result.push(k);
    });
    return result;
  }
});

Object.defineProperty(proto, "values", {
  get: function () {
    var result = [];
    this.forEach(function (k, v) {
      result.push(v);
    });
    return result;
  }
}

//Returns the number of nodes in the tree
);Object.defineProperty(proto, "length", {
  get: function () {
    if (this.root) {
      return this.root._count;
    }
    return 0;
  }
}

//Insert a new item into the tree
);proto.insert = function (key, value) {
  var cmp = this._compare;
  //Find point to insert new node at
  var n = this.root;
  var n_stack = [];
  var d_stack = [];
  while (n) {
    var d = cmp(key, n.key);
    n_stack.push(n);
    d_stack.push(d);
    if (d <= 0) {
      n = n.left;
    } else {
      n = n.right;
    }
  }
  //Rebuild path to leaf node
  n_stack.push(new RBNode(RED, key, value, null, null, 1));
  for (var s = n_stack.length - 2; s >= 0; --s) {
    var n = n_stack[s];
    if (d_stack[s] <= 0) {
      n_stack[s] = new RBNode(n._color, n.key, n.value, n_stack[s + 1], n.right, n._count + 1);
    } else {
      n_stack[s] = new RBNode(n._color, n.key, n.value, n.left, n_stack[s + 1], n._count + 1);
    }
  }
  //Rebalance tree using rotations
  //console.log("start insert", key, d_stack)
  for (var s = n_stack.length - 1; s > 1; --s) {
    var p = n_stack[s - 1];
    var n = n_stack[s];
    if (p._color === BLACK || n._color === BLACK) {
      break;
    }
    var pp = n_stack[s - 2];
    if (pp.left === p) {
      if (p.left === n) {
        var y = pp.right;
        if (y && y._color === RED) {
          //console.log("LLr")
          p._color = BLACK;
          pp.right = repaint(BLACK, y);
          pp._color = RED;
          s -= 1;
        } else {
          //console.log("LLb")
          pp._color = RED;
          pp.left = p.right;
          p._color = BLACK;
          p.right = pp;
          n_stack[s - 2] = p;
          n_stack[s - 1] = n;
          recount(pp);
          recount(p);
          if (s >= 3) {
            var ppp = n_stack[s - 3];
            if (ppp.left === pp) {
              ppp.left = p;
            } else {
              ppp.right = p;
            }
          }
          break;
        }
      } else {
        var y = pp.right;
        if (y && y._color === RED) {
          //console.log("LRr")
          p._color = BLACK;
          pp.right = repaint(BLACK, y);
          pp._color = RED;
          s -= 1;
        } else {
          //console.log("LRb")
          p.right = n.left;
          pp._color = RED;
          pp.left = n.right;
          n._color = BLACK;
          n.left = p;
          n.right = pp;
          n_stack[s - 2] = n;
          n_stack[s - 1] = p;
          recount(pp);
          recount(p);
          recount(n);
          if (s >= 3) {
            var ppp = n_stack[s - 3];
            if (ppp.left === pp) {
              ppp.left = n;
            } else {
              ppp.right = n;
            }
          }
          break;
        }
      }
    } else {
      if (p.right === n) {
        var y = pp.left;
        if (y && y._color === RED) {
          //console.log("RRr", y.key)
          p._color = BLACK;
          pp.left = repaint(BLACK, y);
          pp._color = RED;
          s -= 1;
        } else {
          //console.log("RRb")
          pp._color = RED;
          pp.right = p.left;
          p._color = BLACK;
          p.left = pp;
          n_stack[s - 2] = p;
          n_stack[s - 1] = n;
          recount(pp);
          recount(p);
          if (s >= 3) {
            var ppp = n_stack[s - 3];
            if (ppp.right === pp) {
              ppp.right = p;
            } else {
              ppp.left = p;
            }
          }
          break;
        }
      } else {
        var y = pp.left;
        if (y && y._color === RED) {
          //console.log("RLr")
          p._color = BLACK;
          pp.left = repaint(BLACK, y);
          pp._color = RED;
          s -= 1;
        } else {
          //console.log("RLb")
          p.left = n.right;
          pp._color = RED;
          pp.right = n.left;
          n._color = BLACK;
          n.right = p;
          n.left = pp;
          n_stack[s - 2] = n;
          n_stack[s - 1] = p;
          recount(pp);
          recount(p);
          recount(n);
          if (s >= 3) {
            var ppp = n_stack[s - 3];
            if (ppp.right === pp) {
              ppp.right = n;
            } else {
              ppp.left = n;
            }
          }
          break;
        }
      }
    }
  }
  //Return new tree
  n_stack[0]._color = BLACK;
  return new RedBlackTree(cmp, n_stack[0]);
};

//Visit all nodes inorder
function doVisitFull(visit, node) {
  if (node.left) {
    var v = doVisitFull(visit, node.left);
    if (v) {
      return v;
    }
  }
  var v = visit(node.key, node.value);
  if (v) {
    return v;
  }
  if (node.right) {
    return doVisitFull(visit, node.right);
  }
}

//Visit half nodes in order
function doVisitHalf(lo, compare, visit, node) {
  var l = compare(lo, node.key);
  if (l <= 0) {
    if (node.left) {
      var v = doVisitHalf(lo, compare, visit, node.left);
      if (v) {
        return v;
      }
    }
    var v = visit(node.key, node.value);
    if (v) {
      return v;
    }
  }
  if (node.right) {
    return doVisitHalf(lo, compare, visit, node.right);
  }
}

//Visit all nodes within a range
function doVisit(lo, hi, compare, visit, node) {
  var l = compare(lo, node.key);
  var h = compare(hi, node.key);
  var v;
  if (l <= 0) {
    if (node.left) {
      v = doVisit(lo, hi, compare, visit, node.left);
      if (v) {
        return v;
      }
    }
    if (h > 0) {
      v = visit(node.key, node.value);
      if (v) {
        return v;
      }
    }
  }
  if (h > 0 && node.right) {
    return doVisit(lo, hi, compare, visit, node.right);
  }
}

proto.forEach = function rbTreeForEach(visit, lo, hi) {
  if (!this.root) {
    return;
  }
  switch (arguments.length) {
    case 1:
      return doVisitFull(visit, this.root);
      break;

    case 2:
      return doVisitHalf(lo, this._compare, visit, this.root);
      break;

    case 3:
      if (this._compare(lo, hi) >= 0) {
        return;
      }
      return doVisit(lo, hi, this._compare, visit, this.root);
      break;
  }
};

//First item in list
Object.defineProperty(proto, "begin", {
  get: function () {
    var stack = [];
    var n = this.root;
    while (n) {
      stack.push(n);
      n = n.left;
    }
    return new RedBlackTreeIterator(this, stack);
  }
}

//Last item in list
);Object.defineProperty(proto, "end", {
  get: function () {
    var stack = [];
    var n = this.root;
    while (n) {
      stack.push(n);
      n = n.right;
    }
    return new RedBlackTreeIterator(this, stack);
  }
}

//Find the ith item in the tree
);proto.at = function (idx) {
  if (idx < 0) {
    return new RedBlackTreeIterator(this, []);
  }
  var n = this.root;
  var stack = [];
  while (true) {
    stack.push(n);
    if (n.left) {
      if (idx < n.left._count) {
        n = n.left;
        continue;
      }
      idx -= n.left._count;
    }
    if (!idx) {
      return new RedBlackTreeIterator(this, stack);
    }
    idx -= 1;
    if (n.right) {
      if (idx >= n.right._count) {
        break;
      }
      n = n.right;
    } else {
      break;
    }
  }
  return new RedBlackTreeIterator(this, []);
};

proto.ge = function (key) {
  var cmp = this._compare;
  var n = this.root;
  var stack = [];
  var last_ptr = 0;
  while (n) {
    var d = cmp(key, n.key);
    stack.push(n);
    if (d <= 0) {
      last_ptr = stack.length;
    }
    if (d <= 0) {
      n = n.left;
    } else {
      n = n.right;
    }
  }
  stack.length = last_ptr;
  return new RedBlackTreeIterator(this, stack);
};

proto.gt = function (key) {
  var cmp = this._compare;
  var n = this.root;
  var stack = [];
  var last_ptr = 0;
  while (n) {
    var d = cmp(key, n.key);
    stack.push(n);
    if (d < 0) {
      last_ptr = stack.length;
    }
    if (d < 0) {
      n = n.left;
    } else {
      n = n.right;
    }
  }
  stack.length = last_ptr;
  return new RedBlackTreeIterator(this, stack);
};

proto.lt = function (key) {
  var cmp = this._compare;
  var n = this.root;
  var stack = [];
  var last_ptr = 0;
  while (n) {
    var d = cmp(key, n.key);
    stack.push(n);
    if (d > 0) {
      last_ptr = stack.length;
    }
    if (d <= 0) {
      n = n.left;
    } else {
      n = n.right;
    }
  }
  stack.length = last_ptr;
  return new RedBlackTreeIterator(this, stack);
};

proto.le = function (key) {
  var cmp = this._compare;
  var n = this.root;
  var stack = [];
  var last_ptr = 0;
  while (n) {
    var d = cmp(key, n.key);
    stack.push(n);
    if (d >= 0) {
      last_ptr = stack.length;
    }
    if (d < 0) {
      n = n.left;
    } else {
      n = n.right;
    }
  }
  stack.length = last_ptr;
  return new RedBlackTreeIterator(this, stack);
};

//Finds the item with key if it exists
proto.find = function (key) {
  var cmp = this._compare;
  var n = this.root;
  var stack = [];
  while (n) {
    var d = cmp(key, n.key);
    stack.push(n);
    if (d === 0) {
      return new RedBlackTreeIterator(this, stack);
    }
    if (d <= 0) {
      n = n.left;
    } else {
      n = n.right;
    }
  }
  return new RedBlackTreeIterator(this, []);
};

//Removes item with key from tree
proto.remove = function (key) {
  var iter = this.find(key);
  if (iter) {
    return iter.remove();
  }
  return this;
};

//Returns the item at `key`
proto.get = function (key) {
  var cmp = this._compare;
  var n = this.root;
  while (n) {
    var d = cmp(key, n.key);
    if (d === 0) {
      return n.value;
    }
    if (d <= 0) {
      n = n.left;
    } else {
      n = n.right;
    }
  }
  return;
};

//Iterator for red black tree
function RedBlackTreeIterator(tree, stack) {
  this.tree = tree;
  this._stack = stack;
}

var iproto = RedBlackTreeIterator.prototype;

//Test if iterator is valid
Object.defineProperty(iproto, "valid", {
  get: function () {
    return this._stack.length > 0;
  }
}

//Node of the iterator
);Object.defineProperty(iproto, "node", {
  get: function () {
    if (this._stack.length > 0) {
      return this._stack[this._stack.length - 1];
    }
    return null;
  },
  enumerable: true
}

//Makes a copy of an iterator
);iproto.clone = function () {
  return new RedBlackTreeIterator(this.tree, this._stack.slice());
};

//Swaps two nodes
function swapNode(n, v) {
  n.key = v.key;
  n.value = v.value;
  n.left = v.left;
  n.right = v.right;
  n._color = v._color;
  n._count = v._count;
}

//Fix up a double black node in a tree
function fixDoubleBlack(stack) {
  var n, p, s, z;
  for (var i = stack.length - 1; i >= 0; --i) {
    n = stack[i];
    if (i === 0) {
      n._color = BLACK;
      return;
    }
    //console.log("visit node:", n.key, i, stack[i].key, stack[i-1].key)
    p = stack[i - 1];
    if (p.left === n) {
      //console.log("left child")
      s = p.right;
      if (s.right && s.right._color === RED) {
        //console.log("case 1: right sibling child red")
        s = p.right = cloneNode(s);
        z = s.right = cloneNode(s.right);
        p.right = s.left;
        s.left = p;
        s.right = z;
        s._color = p._color;
        n._color = BLACK;
        p._color = BLACK;
        z._color = BLACK;
        recount(p);
        recount(s);
        if (i > 1) {
          var pp = stack[i - 2];
          if (pp.left === p) {
            pp.left = s;
          } else {
            pp.right = s;
          }
        }
        stack[i - 1] = s;
        return;
      } else if (s.left && s.left._color === RED) {
        //console.log("case 1: left sibling child red")
        s = p.right = cloneNode(s);
        z = s.left = cloneNode(s.left);
        p.right = z.left;
        s.left = z.right;
        z.left = p;
        z.right = s;
        z._color = p._color;
        p._color = BLACK;
        s._color = BLACK;
        n._color = BLACK;
        recount(p);
        recount(s);
        recount(z);
        if (i > 1) {
          var pp = stack[i - 2];
          if (pp.left === p) {
            pp.left = z;
          } else {
            pp.right = z;
          }
        }
        stack[i - 1] = z;
        return;
      }
      if (s._color === BLACK) {
        if (p._color === RED) {
          //console.log("case 2: black sibling, red parent", p.right.value)
          p._color = BLACK;
          p.right = repaint(RED, s);
          return;
        } else {
          //console.log("case 2: black sibling, black parent", p.right.value)
          p.right = repaint(RED, s);
          continue;
        }
      } else {
        //console.log("case 3: red sibling")
        s = cloneNode(s);
        p.right = s.left;
        s.left = p;
        s._color = p._color;
        p._color = RED;
        recount(p);
        recount(s);
        if (i > 1) {
          var pp = stack[i - 2];
          if (pp.left === p) {
            pp.left = s;
          } else {
            pp.right = s;
          }
        }
        stack[i - 1] = s;
        stack[i] = p;
        if (i + 1 < stack.length) {
          stack[i + 1] = n;
        } else {
          stack.push(n);
        }
        i = i + 2;
      }
    } else {
      //console.log("right child")
      s = p.left;
      if (s.left && s.left._color === RED) {
        //console.log("case 1: left sibling child red", p.value, p._color)
        s = p.left = cloneNode(s);
        z = s.left = cloneNode(s.left);
        p.left = s.right;
        s.right = p;
        s.left = z;
        s._color = p._color;
        n._color = BLACK;
        p._color = BLACK;
        z._color = BLACK;
        recount(p);
        recount(s);
        if (i > 1) {
          var pp = stack[i - 2];
          if (pp.right === p) {
            pp.right = s;
          } else {
            pp.left = s;
          }
        }
        stack[i - 1] = s;
        return;
      } else if (s.right && s.right._color === RED) {
        //console.log("case 1: right sibling child red")
        s = p.left = cloneNode(s);
        z = s.right = cloneNode(s.right);
        p.left = z.right;
        s.right = z.left;
        z.right = p;
        z.left = s;
        z._color = p._color;
        p._color = BLACK;
        s._color = BLACK;
        n._color = BLACK;
        recount(p);
        recount(s);
        recount(z);
        if (i > 1) {
          var pp = stack[i - 2];
          if (pp.right === p) {
            pp.right = z;
          } else {
            pp.left = z;
          }
        }
        stack[i - 1] = z;
        return;
      }
      if (s._color === BLACK) {
        if (p._color === RED) {
          //console.log("case 2: black sibling, red parent")
          p._color = BLACK;
          p.left = repaint(RED, s);
          return;
        } else {
          //console.log("case 2: black sibling, black parent")
          p.left = repaint(RED, s);
          continue;
        }
      } else {
        //console.log("case 3: red sibling")
        s = cloneNode(s);
        p.left = s.right;
        s.right = p;
        s._color = p._color;
        p._color = RED;
        recount(p);
        recount(s);
        if (i > 1) {
          var pp = stack[i - 2];
          if (pp.right === p) {
            pp.right = s;
          } else {
            pp.left = s;
          }
        }
        stack[i - 1] = s;
        stack[i] = p;
        if (i + 1 < stack.length) {
          stack[i + 1] = n;
        } else {
          stack.push(n);
        }
        i = i + 2;
      }
    }
  }
}

//Removes item at iterator from tree
iproto.remove = function () {
  var stack = this._stack;
  if (stack.length === 0) {
    return this.tree;
  }
  //First copy path to node
  var cstack = new Array(stack.length);
  var n = stack[stack.length - 1];
  cstack[cstack.length - 1] = new RBNode(n._color, n.key, n.value, n.left, n.right, n._count);
  for (var i = stack.length - 2; i >= 0; --i) {
    var n = stack[i];
    if (n.left === stack[i + 1]) {
      cstack[i] = new RBNode(n._color, n.key, n.value, cstack[i + 1], n.right, n._count);
    } else {
      cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i + 1], n._count);
    }
  }

  //Get node
  n = cstack[cstack.length - 1];
  //console.log("start remove: ", n.value)

  //If not leaf, then swap with previous node
  if (n.left && n.right) {
    //console.log("moving to leaf")

    //First walk to previous leaf
    var split = cstack.length;
    n = n.left;
    while (n.right) {
      cstack.push(n);
      n = n.right;
    }
    //Copy path to leaf
    var v = cstack[split - 1];
    cstack.push(new RBNode(n._color, v.key, v.value, n.left, n.right, n._count));
    cstack[split - 1].key = n.key;
    cstack[split - 1].value = n.value;

    //Fix up stack
    for (var i = cstack.length - 2; i >= split; --i) {
      n = cstack[i];
      cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i + 1], n._count);
    }
    cstack[split - 1].left = cstack[split];
  }
  //console.log("stack=", cstack.map(function(v) { return v.value }))

  //Remove leaf node
  n = cstack[cstack.length - 1];
  if (n._color === RED) {
    //Easy case: removing red leaf
    //console.log("RED leaf")
    var p = cstack[cstack.length - 2];
    if (p.left === n) {
      p.left = null;
    } else if (p.right === n) {
      p.right = null;
    }
    cstack.pop();
    for (var i = 0; i < cstack.length; ++i) {
      cstack[i]._count--;
    }
    return new RedBlackTree(this.tree._compare, cstack[0]);
  } else {
    if (n.left || n.right) {
      //Second easy case:  Single child black parent
      //console.log("BLACK single child")
      if (n.left) {
        swapNode(n, n.left);
      } else if (n.right) {
        swapNode(n, n.right);
      }
      //Child must be red, so repaint it black to balance color
      n._color = BLACK;
      for (var i = 0; i < cstack.length - 1; ++i) {
        cstack[i]._count--;
      }
      return new RedBlackTree(this.tree._compare, cstack[0]);
    } else if (cstack.length === 1) {
      //Third easy case: root
      //console.log("ROOT")
      return new RedBlackTree(this.tree._compare, null);
    } else {
      //Hard case: Repaint n, and then do some nasty stuff
      //console.log("BLACK leaf no children")
      for (var i = 0; i < cstack.length; ++i) {
        cstack[i]._count--;
      }
      var parent = cstack[cstack.length - 2];
      fixDoubleBlack(cstack
      //Fix up links
      );if (parent.left === n) {
        parent.left = null;
      } else {
        parent.right = null;
      }
    }
  }
  return new RedBlackTree(this.tree._compare, cstack[0]);
};

//Returns key
Object.defineProperty(iproto, "key", {
  get: function () {
    if (this._stack.length > 0) {
      return this._stack[this._stack.length - 1].key;
    }
    return;
  },
  enumerable: true
}

//Returns value
);Object.defineProperty(iproto, "value", {
  get: function () {
    if (this._stack.length > 0) {
      return this._stack[this._stack.length - 1].value;
    }
    return;
  },
  enumerable: true
}

//Returns the position of this iterator in the sorted list
);Object.defineProperty(iproto, "index", {
  get: function () {
    var idx = 0;
    var stack = this._stack;
    if (stack.length === 0) {
      var r = this.tree.root;
      if (r) {
        return r._count;
      }
      return 0;
    } else if (stack[stack.length - 1].left) {
      idx = stack[stack.length - 1].left._count;
    }
    for (var s = stack.length - 2; s >= 0; --s) {
      if (stack[s + 1] === stack[s].right) {
        ++idx;
        if (stack[s].left) {
          idx += stack[s].left._count;
        }
      }
    }
    return idx;
  },
  enumerable: true
}

//Advances iterator to next element in list
);iproto.next = function () {
  var stack = this._stack;
  if (stack.length === 0) {
    return;
  }
  var n = stack[stack.length - 1];
  if (n.right) {
    n = n.right;
    while (n) {
      stack.push(n);
      n = n.left;
    }
  } else {
    stack.pop();
    while (stack.length > 0 && stack[stack.length - 1].right === n) {
      n = stack[stack.length - 1];
      stack.pop();
    }
  }
};

//Checks if iterator is at end of tree
Object.defineProperty(iproto, "hasNext", {
  get: function () {
    var stack = this._stack;
    if (stack.length === 0) {
      return false;
    }
    if (stack[stack.length - 1].right) {
      return true;
    }
    for (var s = stack.length - 1; s > 0; --s) {
      if (stack[s - 1].left === stack[s]) {
        return true;
      }
    }
    return false;
  }
}

//Update value
);iproto.update = function (value) {
  var stack = this._stack;
  if (stack.length === 0) {
    throw new Error("Can't update empty node!");
  }
  var cstack = new Array(stack.length);
  var n = stack[stack.length - 1];
  cstack[cstack.length - 1] = new RBNode(n._color, n.key, value, n.left, n.right, n._count);
  for (var i = stack.length - 2; i >= 0; --i) {
    n = stack[i];
    if (n.left === stack[i + 1]) {
      cstack[i] = new RBNode(n._color, n.key, n.value, cstack[i + 1], n.right, n._count);
    } else {
      cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i + 1], n._count);
    }
  }
  return new RedBlackTree(this.tree._compare, cstack[0]);
};

//Moves iterator backward one element
iproto.prev = function () {
  var stack = this._stack;
  if (stack.length === 0) {
    return;
  }
  var n = stack[stack.length - 1];
  if (n.left) {
    n = n.left;
    while (n) {
      stack.push(n);
      n = n.right;
    }
  } else {
    stack.pop();
    while (stack.length > 0 && stack[stack.length - 1].left === n) {
      n = stack[stack.length - 1];
      stack.pop();
    }
  }
};

//Checks if iterator is at start of tree
Object.defineProperty(iproto, "hasPrev", {
  get: function () {
    var stack = this._stack;
    if (stack.length === 0) {
      return false;
    }
    if (stack[stack.length - 1].left) {
      return true;
    }
    for (var s = stack.length - 1; s > 0; --s) {
      if (stack[s - 1].right === stack[s]) {
        return true;
      }
    }
    return false;
  }
}

//Default comparison function
);function defaultCompare(a, b) {
  if (a < b) {
    return -1;
  }
  if (a > b) {
    return 1;
  }
  return 0;
}

//Build a tree
function createRBTree(compare) {
  return new RedBlackTree(compare || defaultCompare, null);
}

},{}],67:[function(require,module,exports){
// transliterated from the python snippet here:
// http://en.wikipedia.org/wiki/Lanczos_approximation

var g = 7;
var p = [0.99999999999980993, 676.5203681218851, -1259.1392167224028, 771.32342877765313, -176.61502916214059, 12.507343278686905, -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7];

var g_ln = 607 / 128;
var p_ln = [0.99999999999999709182, 57.156235665862923517, -59.597960355475491248, 14.136097974741747174, -0.49191381609762019978, 0.33994649984811888699e-4, 0.46523628927048575665e-4, -0.98374475304879564677e-4, 0.15808870322491248884e-3, -0.21026444172410488319e-3, 0.21743961811521264320e-3, -0.16431810653676389022e-3, 0.84418223983852743293e-4, -0.26190838401581408670e-4, 0.36899182659531622704e-5];

// Spouge approximation (suitable for large arguments)
function lngamma(z) {

    if (z < 0) return Number('0/0');
    var x = p_ln[0];
    for (var i = p_ln.length - 1; i > 0; --i) x += p_ln[i] / (z + i);
    var t = z + g_ln + 0.5;
    return .5 * Math.log(2 * Math.PI) + (z + .5) * Math.log(t) - t + Math.log(x) - Math.log(z);
}

module.exports = function gamma(z) {
    if (z < 0.5) {
        return Math.PI / (Math.sin(Math.PI * z) * gamma(1 - z));
    } else if (z > 100) return Math.exp(lngamma(z));else {
        z -= 1;
        var x = p[0];
        for (var i = 1; i < g + 2; i++) {
            x += p[i] / (z + i);
        }
        var t = z + g + 0.5;

        return Math.sqrt(2 * Math.PI) * Math.pow(t, z + 0.5) * Math.exp(-t) * x;
    }
};

module.exports.log = lngamma;

},{}],68:[function(require,module,exports){
'use strict';

module.exports = gaussRandom;

function gaussRandom() {
  return Math.sqrt(-2.0 * Math.log(Math.random())) * Math.cos(2.0 * Math.PI * Math.random());
}

},{}],69:[function(require,module,exports){
(function (global){
"use strict";

if (global.AnalyserNode && !global.AnalyserNode.prototype.getFloatTimeDomainData) {
  var uint8 = new Uint8Array(2048);
  global.AnalyserNode.prototype.getFloatTimeDomainData = function (array) {
    this.getByteTimeDomainData(uint8);
    for (var i = 0, imax = array.length; i < imax; i++) {
      array[i] = (uint8[i] - 128) * 0.0078125;
    }
  };
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],70:[function(require,module,exports){
"use strict";

var pool = require("typedarray-pool");
var ops = require("ndarray-ops");
var ndarray = require("ndarray");

var SUPPORTED_TYPES = ["uint8", "uint8_clamped", "uint16", "uint32", "int8", "int16", "int32", "float32"];

function GLBuffer(gl, type, handle, length, usage) {
  this.gl = gl;
  this.type = type;
  this.handle = handle;
  this.length = length;
  this.usage = usage;
}

var proto = GLBuffer.prototype;

proto.bind = function () {
  this.gl.bindBuffer(this.type, this.handle);
};

proto.unbind = function () {
  this.gl.bindBuffer(this.type, null);
};

proto.dispose = function () {
  this.gl.deleteBuffer(this.handle);
};

function updateTypeArray(gl, type, len, usage, data, offset) {
  var dataLen = data.length * data.BYTES_PER_ELEMENT;
  if (offset < 0) {
    gl.bufferData(type, data, usage);
    return dataLen;
  }
  if (dataLen + offset > len) {
    throw new Error("gl-buffer: If resizing buffer, must not specify offset");
  }
  gl.bufferSubData(type, offset, data);
  return len;
}

function makeScratchTypeArray(array, dtype) {
  var res = pool.malloc(array.length, dtype);
  var n = array.length;
  for (var i = 0; i < n; ++i) {
    res[i] = array[i];
  }
  return res;
}

function isPacked(shape, stride) {
  var n = 1;
  for (var i = stride.length - 1; i >= 0; --i) {
    if (stride[i] !== n) {
      return false;
    }
    n *= shape[i];
  }
  return true;
}

proto.update = function (array, offset) {
  if (typeof offset !== "number") {
    offset = -1;
  }
  this.bind();
  if (typeof array === "object" && typeof array.shape !== "undefined") {
    //ndarray
    var dtype = array.dtype;
    if (SUPPORTED_TYPES.indexOf(dtype) < 0) {
      dtype = "float32";
    }
    if (this.type === this.gl.ELEMENT_ARRAY_BUFFER) {
      var ext = gl.getExtension('OES_element_index_uint');
      if (ext && dtype !== "uint16") {
        dtype = "uint32";
      } else {
        dtype = "uint16";
      }
    }
    if (dtype === array.dtype && isPacked(array.shape, array.stride)) {
      if (array.offset === 0 && array.data.length === array.shape[0]) {
        this.length = updateTypeArray(this.gl, this.type, this.length, this.usage, array.data, offset);
      } else {
        this.length = updateTypeArray(this.gl, this.type, this.length, this.usage, array.data.subarray(array.offset, array.shape[0]), offset);
      }
    } else {
      var tmp = pool.malloc(array.size, dtype);
      var ndt = ndarray(tmp, array.shape);
      ops.assign(ndt, array);
      if (offset < 0) {
        this.length = updateTypeArray(this.gl, this.type, this.length, this.usage, tmp, offset);
      } else {
        this.length = updateTypeArray(this.gl, this.type, this.length, this.usage, tmp.subarray(0, array.size), offset);
      }
      pool.free(tmp);
    }
  } else if (Array.isArray(array)) {
    //Vanilla array
    var t;
    if (this.type === this.gl.ELEMENT_ARRAY_BUFFER) {
      t = makeScratchTypeArray(array, "uint16");
    } else {
      t = makeScratchTypeArray(array, "float32");
    }
    if (offset < 0) {
      this.length = updateTypeArray(this.gl, this.type, this.length, this.usage, t, offset);
    } else {
      this.length = updateTypeArray(this.gl, this.type, this.length, this.usage, t.subarray(0, array.length), offset);
    }
    pool.free(t);
  } else if (typeof array === "object" && typeof array.length === "number") {
    //Typed array
    this.length = updateTypeArray(this.gl, this.type, this.length, this.usage, array, offset);
  } else if (typeof array === "number" || array === undefined) {
    //Number/default
    if (offset >= 0) {
      throw new Error("gl-buffer: Cannot specify offset when resizing buffer");
    }
    array = array | 0;
    if (array <= 0) {
      array = 1;
    }
    this.gl.bufferData(this.type, array | 0, this.usage);
    this.length = array;
  } else {
    //Error, case should not happen
    throw new Error("gl-buffer: Invalid data type");
  }
};

function createBuffer(gl, data, type, usage) {
  type = type || gl.ARRAY_BUFFER;
  usage = usage || gl.DYNAMIC_DRAW;
  if (type !== gl.ARRAY_BUFFER && type !== gl.ELEMENT_ARRAY_BUFFER) {
    throw new Error("gl-buffer: Invalid type for webgl buffer, must be either gl.ARRAY_BUFFER or gl.ELEMENT_ARRAY_BUFFER");
  }
  if (usage !== gl.DYNAMIC_DRAW && usage !== gl.STATIC_DRAW && usage !== gl.STREAM_DRAW) {
    throw new Error("gl-buffer: Invalid usage for buffer, must be either gl.DYNAMIC_DRAW, gl.STATIC_DRAW or gl.STREAM_DRAW");
  }
  var handle = gl.createBuffer();
  var result = new GLBuffer(gl, type, handle, 0, usage);
  result.update(data);
  return result;
}

module.exports = createBuffer;

},{"ndarray":114,"ndarray-ops":113,"typedarray-pool":162}],71:[function(require,module,exports){
module.exports = {
  0: 'NONE',
  1: 'ONE',
  2: 'LINE_LOOP',
  3: 'LINE_STRIP',
  4: 'TRIANGLES',
  5: 'TRIANGLE_STRIP',
  6: 'TRIANGLE_FAN',
  256: 'DEPTH_BUFFER_BIT',
  512: 'NEVER',
  513: 'LESS',
  514: 'EQUAL',
  515: 'LEQUAL',
  516: 'GREATER',
  517: 'NOTEQUAL',
  518: 'GEQUAL',
  519: 'ALWAYS',
  768: 'SRC_COLOR',
  769: 'ONE_MINUS_SRC_COLOR',
  770: 'SRC_ALPHA',
  771: 'ONE_MINUS_SRC_ALPHA',
  772: 'DST_ALPHA',
  773: 'ONE_MINUS_DST_ALPHA',
  774: 'DST_COLOR',
  775: 'ONE_MINUS_DST_COLOR',
  776: 'SRC_ALPHA_SATURATE',
  1024: 'STENCIL_BUFFER_BIT',
  1028: 'FRONT',
  1029: 'BACK',
  1032: 'FRONT_AND_BACK',
  1280: 'INVALID_ENUM',
  1281: 'INVALID_VALUE',
  1282: 'INVALID_OPERATION',
  1285: 'OUT_OF_MEMORY',
  1286: 'INVALID_FRAMEBUFFER_OPERATION',
  2304: 'CW',
  2305: 'CCW',
  2849: 'LINE_WIDTH',
  2884: 'CULL_FACE',
  2885: 'CULL_FACE_MODE',
  2886: 'FRONT_FACE',
  2928: 'DEPTH_RANGE',
  2929: 'DEPTH_TEST',
  2930: 'DEPTH_WRITEMASK',
  2931: 'DEPTH_CLEAR_VALUE',
  2932: 'DEPTH_FUNC',
  2960: 'STENCIL_TEST',
  2961: 'STENCIL_CLEAR_VALUE',
  2962: 'STENCIL_FUNC',
  2963: 'STENCIL_VALUE_MASK',
  2964: 'STENCIL_FAIL',
  2965: 'STENCIL_PASS_DEPTH_FAIL',
  2966: 'STENCIL_PASS_DEPTH_PASS',
  2967: 'STENCIL_REF',
  2968: 'STENCIL_WRITEMASK',
  2978: 'VIEWPORT',
  3024: 'DITHER',
  3042: 'BLEND',
  3088: 'SCISSOR_BOX',
  3089: 'SCISSOR_TEST',
  3106: 'COLOR_CLEAR_VALUE',
  3107: 'COLOR_WRITEMASK',
  3317: 'UNPACK_ALIGNMENT',
  3333: 'PACK_ALIGNMENT',
  3379: 'MAX_TEXTURE_SIZE',
  3386: 'MAX_VIEWPORT_DIMS',
  3408: 'SUBPIXEL_BITS',
  3410: 'RED_BITS',
  3411: 'GREEN_BITS',
  3412: 'BLUE_BITS',
  3413: 'ALPHA_BITS',
  3414: 'DEPTH_BITS',
  3415: 'STENCIL_BITS',
  3553: 'TEXTURE_2D',
  4352: 'DONT_CARE',
  4353: 'FASTEST',
  4354: 'NICEST',
  5120: 'BYTE',
  5121: 'UNSIGNED_BYTE',
  5122: 'SHORT',
  5123: 'UNSIGNED_SHORT',
  5124: 'INT',
  5125: 'UNSIGNED_INT',
  5126: 'FLOAT',
  5386: 'INVERT',
  5890: 'TEXTURE',
  6401: 'STENCIL_INDEX',
  6402: 'DEPTH_COMPONENT',
  6406: 'ALPHA',
  6407: 'RGB',
  6408: 'RGBA',
  6409: 'LUMINANCE',
  6410: 'LUMINANCE_ALPHA',
  7680: 'KEEP',
  7681: 'REPLACE',
  7682: 'INCR',
  7683: 'DECR',
  7936: 'VENDOR',
  7937: 'RENDERER',
  7938: 'VERSION',
  9728: 'NEAREST',
  9729: 'LINEAR',
  9984: 'NEAREST_MIPMAP_NEAREST',
  9985: 'LINEAR_MIPMAP_NEAREST',
  9986: 'NEAREST_MIPMAP_LINEAR',
  9987: 'LINEAR_MIPMAP_LINEAR',
  10240: 'TEXTURE_MAG_FILTER',
  10241: 'TEXTURE_MIN_FILTER',
  10242: 'TEXTURE_WRAP_S',
  10243: 'TEXTURE_WRAP_T',
  10497: 'REPEAT',
  10752: 'POLYGON_OFFSET_UNITS',
  16384: 'COLOR_BUFFER_BIT',
  32769: 'CONSTANT_COLOR',
  32770: 'ONE_MINUS_CONSTANT_COLOR',
  32771: 'CONSTANT_ALPHA',
  32772: 'ONE_MINUS_CONSTANT_ALPHA',
  32773: 'BLEND_COLOR',
  32774: 'FUNC_ADD',
  32777: 'BLEND_EQUATION_RGB',
  32778: 'FUNC_SUBTRACT',
  32779: 'FUNC_REVERSE_SUBTRACT',
  32819: 'UNSIGNED_SHORT_4_4_4_4',
  32820: 'UNSIGNED_SHORT_5_5_5_1',
  32823: 'POLYGON_OFFSET_FILL',
  32824: 'POLYGON_OFFSET_FACTOR',
  32854: 'RGBA4',
  32855: 'RGB5_A1',
  32873: 'TEXTURE_BINDING_2D',
  32926: 'SAMPLE_ALPHA_TO_COVERAGE',
  32928: 'SAMPLE_COVERAGE',
  32936: 'SAMPLE_BUFFERS',
  32937: 'SAMPLES',
  32938: 'SAMPLE_COVERAGE_VALUE',
  32939: 'SAMPLE_COVERAGE_INVERT',
  32968: 'BLEND_DST_RGB',
  32969: 'BLEND_SRC_RGB',
  32970: 'BLEND_DST_ALPHA',
  32971: 'BLEND_SRC_ALPHA',
  33071: 'CLAMP_TO_EDGE',
  33170: 'GENERATE_MIPMAP_HINT',
  33189: 'DEPTH_COMPONENT16',
  33306: 'DEPTH_STENCIL_ATTACHMENT',
  33635: 'UNSIGNED_SHORT_5_6_5',
  33648: 'MIRRORED_REPEAT',
  33901: 'ALIASED_POINT_SIZE_RANGE',
  33902: 'ALIASED_LINE_WIDTH_RANGE',
  33984: 'TEXTURE0',
  33985: 'TEXTURE1',
  33986: 'TEXTURE2',
  33987: 'TEXTURE3',
  33988: 'TEXTURE4',
  33989: 'TEXTURE5',
  33990: 'TEXTURE6',
  33991: 'TEXTURE7',
  33992: 'TEXTURE8',
  33993: 'TEXTURE9',
  33994: 'TEXTURE10',
  33995: 'TEXTURE11',
  33996: 'TEXTURE12',
  33997: 'TEXTURE13',
  33998: 'TEXTURE14',
  33999: 'TEXTURE15',
  34000: 'TEXTURE16',
  34001: 'TEXTURE17',
  34002: 'TEXTURE18',
  34003: 'TEXTURE19',
  34004: 'TEXTURE20',
  34005: 'TEXTURE21',
  34006: 'TEXTURE22',
  34007: 'TEXTURE23',
  34008: 'TEXTURE24',
  34009: 'TEXTURE25',
  34010: 'TEXTURE26',
  34011: 'TEXTURE27',
  34012: 'TEXTURE28',
  34013: 'TEXTURE29',
  34014: 'TEXTURE30',
  34015: 'TEXTURE31',
  34016: 'ACTIVE_TEXTURE',
  34024: 'MAX_RENDERBUFFER_SIZE',
  34041: 'DEPTH_STENCIL',
  34055: 'INCR_WRAP',
  34056: 'DECR_WRAP',
  34067: 'TEXTURE_CUBE_MAP',
  34068: 'TEXTURE_BINDING_CUBE_MAP',
  34069: 'TEXTURE_CUBE_MAP_POSITIVE_X',
  34070: 'TEXTURE_CUBE_MAP_NEGATIVE_X',
  34071: 'TEXTURE_CUBE_MAP_POSITIVE_Y',
  34072: 'TEXTURE_CUBE_MAP_NEGATIVE_Y',
  34073: 'TEXTURE_CUBE_MAP_POSITIVE_Z',
  34074: 'TEXTURE_CUBE_MAP_NEGATIVE_Z',
  34076: 'MAX_CUBE_MAP_TEXTURE_SIZE',
  34338: 'VERTEX_ATTRIB_ARRAY_ENABLED',
  34339: 'VERTEX_ATTRIB_ARRAY_SIZE',
  34340: 'VERTEX_ATTRIB_ARRAY_STRIDE',
  34341: 'VERTEX_ATTRIB_ARRAY_TYPE',
  34342: 'CURRENT_VERTEX_ATTRIB',
  34373: 'VERTEX_ATTRIB_ARRAY_POINTER',
  34466: 'NUM_COMPRESSED_TEXTURE_FORMATS',
  34467: 'COMPRESSED_TEXTURE_FORMATS',
  34660: 'BUFFER_SIZE',
  34661: 'BUFFER_USAGE',
  34816: 'STENCIL_BACK_FUNC',
  34817: 'STENCIL_BACK_FAIL',
  34818: 'STENCIL_BACK_PASS_DEPTH_FAIL',
  34819: 'STENCIL_BACK_PASS_DEPTH_PASS',
  34877: 'BLEND_EQUATION_ALPHA',
  34921: 'MAX_VERTEX_ATTRIBS',
  34922: 'VERTEX_ATTRIB_ARRAY_NORMALIZED',
  34930: 'MAX_TEXTURE_IMAGE_UNITS',
  34962: 'ARRAY_BUFFER',
  34963: 'ELEMENT_ARRAY_BUFFER',
  34964: 'ARRAY_BUFFER_BINDING',
  34965: 'ELEMENT_ARRAY_BUFFER_BINDING',
  34975: 'VERTEX_ATTRIB_ARRAY_BUFFER_BINDING',
  35040: 'STREAM_DRAW',
  35044: 'STATIC_DRAW',
  35048: 'DYNAMIC_DRAW',
  35632: 'FRAGMENT_SHADER',
  35633: 'VERTEX_SHADER',
  35660: 'MAX_VERTEX_TEXTURE_IMAGE_UNITS',
  35661: 'MAX_COMBINED_TEXTURE_IMAGE_UNITS',
  35663: 'SHADER_TYPE',
  35664: 'FLOAT_VEC2',
  35665: 'FLOAT_VEC3',
  35666: 'FLOAT_VEC4',
  35667: 'INT_VEC2',
  35668: 'INT_VEC3',
  35669: 'INT_VEC4',
  35670: 'BOOL',
  35671: 'BOOL_VEC2',
  35672: 'BOOL_VEC3',
  35673: 'BOOL_VEC4',
  35674: 'FLOAT_MAT2',
  35675: 'FLOAT_MAT3',
  35676: 'FLOAT_MAT4',
  35678: 'SAMPLER_2D',
  35680: 'SAMPLER_CUBE',
  35712: 'DELETE_STATUS',
  35713: 'COMPILE_STATUS',
  35714: 'LINK_STATUS',
  35715: 'VALIDATE_STATUS',
  35716: 'INFO_LOG_LENGTH',
  35717: 'ATTACHED_SHADERS',
  35718: 'ACTIVE_UNIFORMS',
  35719: 'ACTIVE_UNIFORM_MAX_LENGTH',
  35720: 'SHADER_SOURCE_LENGTH',
  35721: 'ACTIVE_ATTRIBUTES',
  35722: 'ACTIVE_ATTRIBUTE_MAX_LENGTH',
  35724: 'SHADING_LANGUAGE_VERSION',
  35725: 'CURRENT_PROGRAM',
  36003: 'STENCIL_BACK_REF',
  36004: 'STENCIL_BACK_VALUE_MASK',
  36005: 'STENCIL_BACK_WRITEMASK',
  36006: 'FRAMEBUFFER_BINDING',
  36007: 'RENDERBUFFER_BINDING',
  36048: 'FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE',
  36049: 'FRAMEBUFFER_ATTACHMENT_OBJECT_NAME',
  36050: 'FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL',
  36051: 'FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE',
  36053: 'FRAMEBUFFER_COMPLETE',
  36054: 'FRAMEBUFFER_INCOMPLETE_ATTACHMENT',
  36055: 'FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT',
  36057: 'FRAMEBUFFER_INCOMPLETE_DIMENSIONS',
  36061: 'FRAMEBUFFER_UNSUPPORTED',
  36064: 'COLOR_ATTACHMENT0',
  36096: 'DEPTH_ATTACHMENT',
  36128: 'STENCIL_ATTACHMENT',
  36160: 'FRAMEBUFFER',
  36161: 'RENDERBUFFER',
  36162: 'RENDERBUFFER_WIDTH',
  36163: 'RENDERBUFFER_HEIGHT',
  36164: 'RENDERBUFFER_INTERNAL_FORMAT',
  36168: 'STENCIL_INDEX8',
  36176: 'RENDERBUFFER_RED_SIZE',
  36177: 'RENDERBUFFER_GREEN_SIZE',
  36178: 'RENDERBUFFER_BLUE_SIZE',
  36179: 'RENDERBUFFER_ALPHA_SIZE',
  36180: 'RENDERBUFFER_DEPTH_SIZE',
  36181: 'RENDERBUFFER_STENCIL_SIZE',
  36194: 'RGB565',
  36336: 'LOW_FLOAT',
  36337: 'MEDIUM_FLOAT',
  36338: 'HIGH_FLOAT',
  36339: 'LOW_INT',
  36340: 'MEDIUM_INT',
  36341: 'HIGH_INT',
  36346: 'SHADER_COMPILER',
  36347: 'MAX_VERTEX_UNIFORM_VECTORS',
  36348: 'MAX_VARYING_VECTORS',
  36349: 'MAX_FRAGMENT_UNIFORM_VECTORS',
  37440: 'UNPACK_FLIP_Y_WEBGL',
  37441: 'UNPACK_PREMULTIPLY_ALPHA_WEBGL',
  37442: 'CONTEXT_LOST_WEBGL',
  37443: 'UNPACK_COLORSPACE_CONVERSION_WEBGL',
  37444: 'BROWSER_DEFAULT_WEBGL'
};

},{}],72:[function(require,module,exports){
var gl10 = require('./1.0/numbers');

module.exports = function lookupConstant(number) {
  return gl10[number];
};

},{"./1.0/numbers":71}],73:[function(require,module,exports){
'use strict';

var createTexture = require('gl-texture2d');

module.exports = createFBO;

var colorAttachmentArrays = null;
var FRAMEBUFFER_UNSUPPORTED;
var FRAMEBUFFER_INCOMPLETE_ATTACHMENT;
var FRAMEBUFFER_INCOMPLETE_DIMENSIONS;
var FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT;

function saveFBOState(gl) {
  var fbo = gl.getParameter(gl.FRAMEBUFFER_BINDING);
  var rbo = gl.getParameter(gl.RENDERBUFFER_BINDING);
  var tex = gl.getParameter(gl.TEXTURE_BINDING_2D);
  return [fbo, rbo, tex];
}

function restoreFBOState(gl, data) {
  gl.bindFramebuffer(gl.FRAMEBUFFER, data[0]);
  gl.bindRenderbuffer(gl.RENDERBUFFER, data[1]);
  gl.bindTexture(gl.TEXTURE_2D, data[2]);
}

function lazyInitColorAttachments(gl, ext) {
  var maxColorAttachments = gl.getParameter(ext.MAX_COLOR_ATTACHMENTS_WEBGL);
  colorAttachmentArrays = new Array(maxColorAttachments + 1);
  for (var i = 0; i <= maxColorAttachments; ++i) {
    var x = new Array(maxColorAttachments);
    for (var j = 0; j < i; ++j) {
      x[j] = gl.COLOR_ATTACHMENT0 + j;
    }
    for (var j = i; j < maxColorAttachments; ++j) {
      x[j] = gl.NONE;
    }
    colorAttachmentArrays[i] = x;
  }
}

//Throw an appropriate error
function throwFBOError(status) {
  switch (status) {
    case FRAMEBUFFER_UNSUPPORTED:
      throw new Error('gl-fbo: Framebuffer unsupported');
    case FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
      throw new Error('gl-fbo: Framebuffer incomplete attachment');
    case FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
      throw new Error('gl-fbo: Framebuffer incomplete dimensions');
    case FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
      throw new Error('gl-fbo: Framebuffer incomplete missing attachment');
    default:
      throw new Error('gl-fbo: Framebuffer failed for unspecified reason');
  }
}

//Initialize a texture object
function initTexture(gl, width, height, type, format, attachment) {
  if (!type) {
    return null;
  }
  var result = createTexture(gl, width, height, format, type);
  result.magFilter = gl.NEAREST;
  result.minFilter = gl.NEAREST;
  result.mipSamples = 1;
  result.bind();
  gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, result.handle, 0);
  return result;
}

//Initialize a render buffer object
function initRenderBuffer(gl, width, height, component, attachment) {
  var result = gl.createRenderbuffer();
  gl.bindRenderbuffer(gl.RENDERBUFFER, result);
  gl.renderbufferStorage(gl.RENDERBUFFER, component, width, height);
  gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachment, gl.RENDERBUFFER, result);
  return result;
}

//Rebuild the frame buffer
function rebuildFBO(fbo) {

  //Save FBO state
  var state = saveFBOState(fbo.gl);

  var gl = fbo.gl;
  var handle = fbo.handle = gl.createFramebuffer();
  var width = fbo._shape[0];
  var height = fbo._shape[1];
  var numColors = fbo.color.length;
  var ext = fbo._ext;
  var useStencil = fbo._useStencil;
  var useDepth = fbo._useDepth;
  var colorType = fbo._colorType;

  //Bind the fbo
  gl.bindFramebuffer(gl.FRAMEBUFFER, handle

  //Allocate color buffers
  );for (var i = 0; i < numColors; ++i) {
    fbo.color[i] = initTexture(gl, width, height, colorType, gl.RGBA, gl.COLOR_ATTACHMENT0 + i);
  }
  if (numColors === 0) {
    fbo._color_rb = initRenderBuffer(gl, width, height, gl.RGBA4, gl.COLOR_ATTACHMENT0);
    if (ext) {
      ext.drawBuffersWEBGL(colorAttachmentArrays[0]);
    }
  } else if (numColors > 1) {
    ext.drawBuffersWEBGL(colorAttachmentArrays[numColors]);
  }

  //Allocate depth/stencil buffers
  var WEBGL_depth_texture = gl.getExtension('WEBGL_depth_texture');
  if (WEBGL_depth_texture) {
    if (useStencil) {
      fbo.depth = initTexture(gl, width, height, WEBGL_depth_texture.UNSIGNED_INT_24_8_WEBGL, gl.DEPTH_STENCIL, gl.DEPTH_STENCIL_ATTACHMENT);
    } else if (useDepth) {
      fbo.depth = initTexture(gl, width, height, gl.UNSIGNED_SHORT, gl.DEPTH_COMPONENT, gl.DEPTH_ATTACHMENT);
    }
  } else {
    if (useDepth && useStencil) {
      fbo._depth_rb = initRenderBuffer(gl, width, height, gl.DEPTH_STENCIL, gl.DEPTH_STENCIL_ATTACHMENT);
    } else if (useDepth) {
      fbo._depth_rb = initRenderBuffer(gl, width, height, gl.DEPTH_COMPONENT16, gl.DEPTH_ATTACHMENT);
    } else if (useStencil) {
      fbo._depth_rb = initRenderBuffer(gl, width, height, gl.STENCIL_INDEX, gl.STENCIL_ATTACHMENT);
    }
  }

  //Check frame buffer state
  var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
  if (status !== gl.FRAMEBUFFER_COMPLETE) {

    //Release all partially allocated resources
    fbo._destroyed = true;

    //Release all resources
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.deleteFramebuffer(fbo.handle);
    fbo.handle = null;
    if (fbo.depth) {
      fbo.depth.dispose();
      fbo.depth = null;
    }
    if (fbo._depth_rb) {
      gl.deleteRenderbuffer(fbo._depth_rb);
      fbo._depth_rb = null;
    }
    for (var i = 0; i < fbo.color.length; ++i) {
      fbo.color[i].dispose();
      fbo.color[i] = null;
    }
    if (fbo._color_rb) {
      gl.deleteRenderbuffer(fbo._color_rb);
      fbo._color_rb = null;
    }

    restoreFBOState(gl, state

    //Throw the frame buffer error
    );throwFBOError(status);
  }

  //Everything ok, let's get on with life
  restoreFBOState(gl, state);
}

function Framebuffer(gl, width, height, colorType, numColors, useDepth, useStencil, ext) {

  //Handle and set properties
  this.gl = gl;
  this._shape = [width | 0, height | 0];
  this._destroyed = false;
  this._ext = ext;

  //Allocate buffers
  this.color = new Array(numColors);
  for (var i = 0; i < numColors; ++i) {
    this.color[i] = null;
  }
  this._color_rb = null;
  this.depth = null;
  this._depth_rb = null;

  //Save depth and stencil flags
  this._colorType = colorType;
  this._useDepth = useDepth;
  this._useStencil = useStencil;

  //Shape vector for resizing
  var parent = this;
  var shapeVector = [width | 0, height | 0];
  Object.defineProperties(shapeVector, {
    0: {
      get: function () {
        return parent._shape[0];
      },
      set: function (w) {
        return parent.width = w;
      }
    },
    1: {
      get: function () {
        return parent._shape[1];
      },
      set: function (h) {
        return parent.height = h;
      }
    }
  });
  this._shapeVector = shapeVector;

  //Initialize all attachments
  rebuildFBO(this);
}

var proto = Framebuffer.prototype;

function reshapeFBO(fbo, w, h) {
  //If fbo is invalid, just skip this
  if (fbo._destroyed) {
    throw new Error('gl-fbo: Can\'t resize destroyed FBO');
  }

  //Don't resize if no change in shape
  if (fbo._shape[0] === w && fbo._shape[1] === h) {
    return;
  }

  var gl = fbo.gl;

  //Check parameter ranges
  var maxFBOSize = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);
  if (w < 0 || w > maxFBOSize || h < 0 || h > maxFBOSize) {
    throw new Error('gl-fbo: Can\'t resize FBO, invalid dimensions');
  }

  //Update shape
  fbo._shape[0] = w;
  fbo._shape[1] = h;

  //Save framebuffer state
  var state = saveFBOState(gl

  //Resize framebuffer attachments
  );for (var i = 0; i < fbo.color.length; ++i) {
    fbo.color[i].shape = fbo._shape;
  }
  if (fbo._color_rb) {
    gl.bindRenderbuffer(gl.RENDERBUFFER, fbo._color_rb);
    gl.renderbufferStorage(gl.RENDERBUFFER, gl.RGBA4, fbo._shape[0], fbo._shape[1]);
  }
  if (fbo.depth) {
    fbo.depth.shape = fbo._shape;
  }
  if (fbo._depth_rb) {
    gl.bindRenderbuffer(gl.RENDERBUFFER, fbo._depth_rb);
    if (fbo._useDepth && fbo._useStencil) {
      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, fbo._shape[0], fbo._shape[1]);
    } else if (fbo._useDepth) {
      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, fbo._shape[0], fbo._shape[1]);
    } else if (fbo._useStencil) {
      gl.renderbufferStorage(gl.RENDERBUFFER, gl.STENCIL_INDEX, fbo._shape[0], fbo._shape[1]);
    }
  }

  //Check FBO status after resize, if something broke then die in a fire
  gl.bindFramebuffer(gl.FRAMEBUFFER, fbo.handle);
  var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
  if (status !== gl.FRAMEBUFFER_COMPLETE) {
    fbo.dispose();
    restoreFBOState(gl, state);
    throwFBOError(status);
  }

  //Restore framebuffer state
  restoreFBOState(gl, state);
}

Object.defineProperties(proto, {
  'shape': {
    get: function () {
      if (this._destroyed) {
        return [0, 0];
      }
      return this._shapeVector;
    },
    set: function (x) {
      if (!Array.isArray(x)) {
        x = [x | 0, x | 0];
      }
      if (x.length !== 2) {
        throw new Error('gl-fbo: Shape vector must be length 2');
      }

      var w = x[0] | 0;
      var h = x[1] | 0;
      reshapeFBO(this, w, h);

      return [w, h];
    },
    enumerable: false
  },
  'width': {
    get: function () {
      if (this._destroyed) {
        return 0;
      }
      return this._shape[0];
    },
    set: function (w) {
      w = w | 0;
      reshapeFBO(this, w, this._shape[1]);
      return w;
    },
    enumerable: false
  },
  'height': {
    get: function () {
      if (this._destroyed) {
        return 0;
      }
      return this._shape[1];
    },
    set: function (h) {
      h = h | 0;
      reshapeFBO(this, this._shape[0], h);
      return h;
    },
    enumerable: false
  }
});

proto.bind = function () {
  if (this._destroyed) {
    return;
  }
  var gl = this.gl;
  gl.bindFramebuffer(gl.FRAMEBUFFER, this.handle);
  gl.viewport(0, 0, this._shape[0], this._shape[1]);
};

proto.dispose = function () {
  if (this._destroyed) {
    return;
  }
  this._destroyed = true;
  var gl = this.gl;
  gl.deleteFramebuffer(this.handle);
  this.handle = null;
  if (this.depth) {
    this.depth.dispose();
    this.depth = null;
  }
  if (this._depth_rb) {
    gl.deleteRenderbuffer(this._depth_rb);
    this._depth_rb = null;
  }
  for (var i = 0; i < this.color.length; ++i) {
    this.color[i].dispose();
    this.color[i] = null;
  }
  if (this._color_rb) {
    gl.deleteRenderbuffer(this._color_rb);
    this._color_rb = null;
  }
};

function createFBO(gl, width, height, options) {

  //Update frame buffer error code values
  if (!FRAMEBUFFER_UNSUPPORTED) {
    FRAMEBUFFER_UNSUPPORTED = gl.FRAMEBUFFER_UNSUPPORTED;
    FRAMEBUFFER_INCOMPLETE_ATTACHMENT = gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT;
    FRAMEBUFFER_INCOMPLETE_DIMENSIONS = gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS;
    FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT;
  }

  //Lazily initialize color attachment arrays
  var WEBGL_draw_buffers = gl.getExtension('WEBGL_draw_buffers');
  if (!colorAttachmentArrays && WEBGL_draw_buffers) {
    lazyInitColorAttachments(gl, WEBGL_draw_buffers);
  }

  //Special case: Can accept an array as argument
  if (Array.isArray(width)) {
    options = height;
    height = width[1] | 0;
    width = width[0] | 0;
  }

  if (typeof width !== 'number') {
    throw new Error('gl-fbo: Missing shape parameter');
  }

  //Validate width/height properties
  var maxFBOSize = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);
  if (width < 0 || width > maxFBOSize || height < 0 || height > maxFBOSize) {
    throw new Error('gl-fbo: Parameters are too large for FBO');
  }

  //Handle each option type
  options = options || {};

  //Figure out number of color buffers to use
  var numColors = 1;
  if ('color' in options) {
    numColors = Math.max(options.color | 0, 0);
    if (numColors < 0) {
      throw new Error('gl-fbo: Must specify a nonnegative number of colors');
    }
    if (numColors > 1) {
      //Check if multiple render targets supported
      if (!WEBGL_draw_buffers) {
        throw new Error('gl-fbo: Multiple draw buffer extension not supported');
      } else if (numColors > gl.getParameter(WEBGL_draw_buffers.MAX_COLOR_ATTACHMENTS_WEBGL)) {
        throw new Error('gl-fbo: Context does not support ' + numColors + ' draw buffers');
      }
    }
  }

  //Determine whether to use floating point textures
  var colorType = gl.UNSIGNED_BYTE;
  var OES_texture_float = gl.getExtension('OES_texture_float');
  if (options.float && numColors > 0) {
    if (!OES_texture_float) {
      throw new Error('gl-fbo: Context does not support floating point textures');
    }
    colorType = gl.FLOAT;
  } else if (options.preferFloat && numColors > 0) {
    if (OES_texture_float) {
      colorType = gl.FLOAT;
    }
  }

  //Check if we should use depth buffer
  var useDepth = true;
  if ('depth' in options) {
    useDepth = !!options.depth;
  }

  //Check if we should use a stencil buffer
  var useStencil = false;
  if ('stencil' in options) {
    useStencil = !!options.stencil;
  }

  return new Framebuffer(gl, width, height, colorType, numColors, useDepth, useStencil, WEBGL_draw_buffers);
}

},{"gl-texture2d":92}],74:[function(require,module,exports){

var sprintf = require('sprintf-js').sprintf;
var glConstants = require('gl-constants/lookup');
var shaderName = require('glsl-shader-name');
var addLineNumbers = require('add-line-numbers');

module.exports = formatCompilerError;

function formatCompilerError(errLog, src, type) {
    "use strict";

    var name = shaderName(src) || 'of unknown name (see npm glsl-shader-name)';

    var typeName = 'unknown type';
    if (type !== undefined) {
        typeName = type === glConstants.FRAGMENT_SHADER ? 'fragment' : 'vertex';
    }

    var longForm = sprintf('Error compiling %s shader %s:\n', typeName, name);
    var shortForm = sprintf("%s%s", longForm, errLog);

    var errorStrings = errLog.split('\n');
    var errors = {};

    for (var i = 0; i < errorStrings.length; i++) {
        var errorString = errorStrings[i];
        if (errorString === '') continue;
        var lineNo = parseInt(errorString.split(':')[2]);
        if (isNaN(lineNo)) {
            throw new Error(sprintf('Could not parse error: %s', errorString));
        }
        errors[lineNo] = errorString;
    }

    var lines = addLineNumbers(src).split('\n');

    for (var i = 0; i < lines.length; i++) {
        if (!errors[i + 3] && !errors[i + 2] && !errors[i + 1]) continue;
        var line = lines[i];
        longForm += line + '\n';
        if (errors[i + 1]) {
            var e = errors[i + 1];
            e = e.substr(e.split(':', 3).join(':').length + 1).trim();
            longForm += sprintf('^^^ %s\n\n', e);
        }
    }

    return {
        long: longForm.trim(),
        short: shortForm.trim()
    };
}

},{"add-line-numbers":4,"gl-constants/lookup":72,"glsl-shader-name":93,"sprintf-js":152}],75:[function(require,module,exports){
'use strict';

module.exports = createBoxes;

var createBuffer = require('gl-buffer');
var createShader = require('gl-shader');

var shaders = require('./shaders');

function Boxes(plot, vbo, shader) {
  this.plot = plot;
  this.vbo = vbo;
  this.shader = shader;
}

var proto = Boxes.prototype;

proto.bind = function () {
  var shader = this.shader;
  this.vbo.bind();
  this.shader.bind();
  shader.attributes.coord.pointer();
  shader.uniforms.screenBox = this.plot.screenBox;
};

proto.drawBox = function () {
  var lo = [0, 0];
  var hi = [0, 0];
  return function (loX, loY, hiX, hiY, color) {
    var plot = this.plot;
    var shader = this.shader;
    var gl = plot.gl;

    lo[0] = loX;
    lo[1] = loY;
    hi[0] = hiX;
    hi[1] = hiY;

    shader.uniforms.lo = lo;
    shader.uniforms.hi = hi;
    shader.uniforms.color = color;

    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  };
}();

proto.dispose = function () {
  this.vbo.dispose();
  this.shader.dispose();
};

function createBoxes(plot) {
  var gl = plot.gl;
  var vbo = createBuffer(gl, [0, 0, 0, 1, 1, 0, 1, 1]);
  var shader = createShader(gl, shaders.boxVert, shaders.lineFrag);
  return new Boxes(plot, vbo, shader);
}

},{"./shaders":78,"gl-buffer":70,"gl-shader":84}],76:[function(require,module,exports){
'use strict';

module.exports = createGrid;

var createBuffer = require('gl-buffer');
var createShader = require('gl-shader');
var bsearch = require('binary-search-bounds');
var shaders = require('./shaders');

function Grid(plot, vbo, shader, tickShader) {
  this.plot = plot;
  this.vbo = vbo;
  this.shader = shader;
  this.tickShader = tickShader;
  this.ticks = [[], []];
}

function compareTickNum(a, b) {
  return a - b;
}

var proto = Grid.prototype;

proto.draw = function () {

  var DATA_SHIFT = [0, 0];
  var DATA_SCALE = [0, 0];
  var DATA_AXIS = [0, 0];

  return function () {
    var plot = this.plot;
    var vbo = this.vbo;
    var shader = this.shader;
    var ticks = this.ticks;
    var gl = plot.gl;
    var bounds = plot._tickBounds;
    var dataBox = plot.dataBox;
    var viewPixels = plot.viewBox;
    var lineWidth = plot.gridLineWidth;
    var gridColor = plot.gridLineColor;
    var gridEnable = plot.gridLineEnable;
    var pixelRatio = plot.pixelRatio;

    for (var i = 0; i < 2; ++i) {
      var lo = bounds[i];
      var hi = bounds[i + 2];
      var boundScale = hi - lo;
      var dataCenter = 0.5 * (dataBox[i + 2] + dataBox[i]);
      var dataWidth = dataBox[i + 2] - dataBox[i];
      DATA_SCALE[i] = 2.0 * boundScale / dataWidth;
      DATA_SHIFT[i] = 2.0 * (lo - dataCenter) / dataWidth;
    }

    shader.bind();
    vbo.bind();
    shader.attributes.dataCoord.pointer();
    shader.uniforms.dataShift = DATA_SHIFT;
    shader.uniforms.dataScale = DATA_SCALE;

    var offset = 0;
    for (var i = 0; i < 2; ++i) {
      DATA_AXIS[0] = DATA_AXIS[1] = 0;
      DATA_AXIS[i] = 1;
      shader.uniforms.dataAxis = DATA_AXIS;
      shader.uniforms.lineWidth = lineWidth[i] / (viewPixels[i + 2] - viewPixels[i]) * pixelRatio;
      shader.uniforms.color = gridColor[i];

      var size = ticks[i].length * 6;
      if (gridEnable[i] && size) {
        gl.drawArrays(gl.TRIANGLES, offset, size);
      }
      offset += size;
    }
  };
}();

proto.drawTickMarks = function () {
  var DATA_SHIFT = [0, 0];
  var DATA_SCALE = [0, 0];
  var X_AXIS = [1, 0];
  var Y_AXIS = [0, 1];
  var SCR_OFFSET = [0, 0];
  var TICK_SCALE = [0, 0];

  return function () {
    var plot = this.plot;
    var vbo = this.vbo;
    var shader = this.tickShader;
    var ticks = this.ticks;
    var gl = plot.gl;
    var bounds = plot._tickBounds;
    var dataBox = plot.dataBox;
    var viewBox = plot.viewBox;
    var pixelRatio = plot.pixelRatio;
    var screenBox = plot.screenBox;

    var screenWidth = screenBox[2] - screenBox[0];
    var screenHeight = screenBox[3] - screenBox[1];
    var viewWidth = viewBox[2] - viewBox[0];
    var viewHeight = viewBox[3] - viewBox[1];

    for (var i = 0; i < 2; ++i) {
      var lo = bounds[i];
      var hi = bounds[i + 2];
      var boundScale = hi - lo;
      var dataCenter = 0.5 * (dataBox[i + 2] + dataBox[i]);
      var dataWidth = dataBox[i + 2] - dataBox[i];
      DATA_SCALE[i] = 2.0 * boundScale / dataWidth;
      DATA_SHIFT[i] = 2.0 * (lo - dataCenter) / dataWidth;
    }

    DATA_SCALE[0] *= viewWidth / screenWidth;
    DATA_SHIFT[0] *= viewWidth / screenWidth;

    DATA_SCALE[1] *= viewHeight / screenHeight;
    DATA_SHIFT[1] *= viewHeight / screenHeight;

    shader.bind();
    vbo.bind();

    shader.attributes.dataCoord.pointer();

    var uniforms = shader.uniforms;
    uniforms.dataShift = DATA_SHIFT;
    uniforms.dataScale = DATA_SCALE;

    var tickMarkLength = plot.tickMarkLength;
    var tickMarkWidth = plot.tickMarkWidth;
    var tickMarkColor = plot.tickMarkColor;

    var xTicksOffset = 0;
    var yTicksOffset = ticks[0].length * 6;

    var xStart = Math.min(bsearch.ge(ticks[0], (dataBox[0] - bounds[0]) / (bounds[2] - bounds[0]), compareTickNum), ticks[0].length);
    var xEnd = Math.min(bsearch.gt(ticks[0], (dataBox[2] - bounds[0]) / (bounds[2] - bounds[0]), compareTickNum), ticks[0].length);
    var xOffset = xTicksOffset + 6 * xStart;
    var xCount = 6 * Math.max(0, xEnd - xStart);

    var yStart = Math.min(bsearch.ge(ticks[1], (dataBox[1] - bounds[1]) / (bounds[3] - bounds[1]), compareTickNum), ticks[1].length);
    var yEnd = Math.min(bsearch.gt(ticks[1], (dataBox[3] - bounds[1]) / (bounds[3] - bounds[1]), compareTickNum), ticks[1].length);
    var yOffset = yTicksOffset + 6 * yStart;
    var yCount = 6 * Math.max(0, yEnd - yStart);

    SCR_OFFSET[0] = 2.0 * (viewBox[0] - tickMarkLength[1]) / screenWidth - 1.0;
    SCR_OFFSET[1] = (viewBox[3] + viewBox[1]) / screenHeight - 1.0;
    TICK_SCALE[0] = tickMarkLength[1] * pixelRatio / screenWidth;
    TICK_SCALE[1] = tickMarkWidth[1] * pixelRatio / screenHeight;

    if (yCount) {
      uniforms.color = tickMarkColor[1];
      uniforms.tickScale = TICK_SCALE;
      uniforms.dataAxis = Y_AXIS;
      uniforms.screenOffset = SCR_OFFSET;
      gl.drawArrays(gl.TRIANGLES, yOffset, yCount);
    }

    SCR_OFFSET[0] = (viewBox[2] + viewBox[0]) / screenWidth - 1.0;
    SCR_OFFSET[1] = 2.0 * (viewBox[1] - tickMarkLength[0]) / screenHeight - 1.0;
    TICK_SCALE[0] = tickMarkWidth[0] * pixelRatio / screenWidth;
    TICK_SCALE[1] = tickMarkLength[0] * pixelRatio / screenHeight;

    if (xCount) {
      uniforms.color = tickMarkColor[0];
      uniforms.tickScale = TICK_SCALE;
      uniforms.dataAxis = X_AXIS;
      uniforms.screenOffset = SCR_OFFSET;
      gl.drawArrays(gl.TRIANGLES, xOffset, xCount);
    }

    SCR_OFFSET[0] = 2.0 * (viewBox[2] + tickMarkLength[3]) / screenWidth - 1.0;
    SCR_OFFSET[1] = (viewBox[3] + viewBox[1]) / screenHeight - 1.0;
    TICK_SCALE[0] = tickMarkLength[3] * pixelRatio / screenWidth;
    TICK_SCALE[1] = tickMarkWidth[3] * pixelRatio / screenHeight;

    if (yCount) {
      uniforms.color = tickMarkColor[3];
      uniforms.tickScale = TICK_SCALE;
      uniforms.dataAxis = Y_AXIS;
      uniforms.screenOffset = SCR_OFFSET;
      gl.drawArrays(gl.TRIANGLES, yOffset, yCount);
    }

    SCR_OFFSET[0] = (viewBox[2] + viewBox[0]) / screenWidth - 1.0;
    SCR_OFFSET[1] = 2.0 * (viewBox[3] + tickMarkLength[2]) / screenHeight - 1.0;
    TICK_SCALE[0] = tickMarkWidth[2] * pixelRatio / screenWidth;
    TICK_SCALE[1] = tickMarkLength[2] * pixelRatio / screenHeight;

    if (xCount) {
      uniforms.color = tickMarkColor[2];
      uniforms.tickScale = TICK_SCALE;
      uniforms.dataAxis = X_AXIS;
      uniforms.screenOffset = SCR_OFFSET;
      gl.drawArrays(gl.TRIANGLES, xOffset, xCount);
    }
  };
}();

proto.update = function () {
  var OFFSET_X = [1, 1, -1, -1, 1, -1];
  var OFFSET_Y = [1, -1, 1, 1, -1, -1];

  return function (options) {
    var ticks = options.ticks;
    var bounds = options.bounds;
    var data = new Float32Array(6 * 3 * (ticks[0].length + ticks[1].length));

    var zeroLineEnable = this.plot.zeroLineEnable;

    var ptr = 0;
    var gridTicks = [[], []];
    for (var dim = 0; dim < 2; ++dim) {
      var localTicks = gridTicks[dim];
      var axisTicks = ticks[dim];
      var lo = bounds[dim];
      var hi = bounds[dim + 2];
      for (var i = 0; i < axisTicks.length; ++i) {
        var x = (axisTicks[i].x - lo) / (hi - lo);
        localTicks.push(x);
        for (var j = 0; j < 6; ++j) {
          data[ptr++] = x;
          data[ptr++] = OFFSET_X[j];
          data[ptr++] = OFFSET_Y[j];
        }
      }
    }

    this.ticks = gridTicks;
    this.vbo.update(data);
  };
}();

proto.dispose = function () {
  this.vbo.dispose();
  this.shader.dispose();
  this.tickShader.dispose();
};

function createGrid(plot) {
  var gl = plot.gl;
  var vbo = createBuffer(gl);
  var shader = createShader(gl, shaders.gridVert, shaders.gridFrag);
  var tickShader = createShader(gl, shaders.tickVert, shaders.gridFrag);
  var grid = new Grid(plot, vbo, shader, tickShader);
  return grid;
}

},{"./shaders":78,"binary-search-bounds":26,"gl-buffer":70,"gl-shader":84}],77:[function(require,module,exports){
'use strict';

module.exports = createLines;

var createBuffer = require('gl-buffer');
var createShader = require('gl-shader');

var shaders = require('./shaders');

function Lines(plot, vbo, shader) {
  this.plot = plot;
  this.vbo = vbo;
  this.shader = shader;
}

var proto = Lines.prototype;

proto.bind = function () {
  var shader = this.shader;
  this.vbo.bind();
  this.shader.bind();
  shader.attributes.coord.pointer();
  shader.uniforms.screenBox = this.plot.screenBox;
};

proto.drawLine = function () {
  var start = [0, 0];
  var end = [0, 0];
  return function (startX, startY, endX, endY, width, color) {
    var plot = this.plot;
    var shader = this.shader;
    var gl = plot.gl;

    start[0] = startX;
    start[1] = startY;
    end[0] = endX;
    end[1] = endY;

    shader.uniforms.start = start;
    shader.uniforms.end = end;
    shader.uniforms.width = width * plot.pixelRatio;
    shader.uniforms.color = color;

    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  };
}();

proto.dispose = function () {
  this.vbo.dispose();
  this.shader.dispose();
};

function createLines(plot) {
  var gl = plot.gl;
  var vbo = createBuffer(gl, [-1, -1, -1, 1, 1, -1, 1, 1]);
  var shader = createShader(gl, shaders.lineVert, shaders.lineFrag);
  var lines = new Lines(plot, vbo, shader);
  return lines;
}

},{"./shaders":78,"gl-buffer":70,"gl-shader":84}],78:[function(require,module,exports){
'use strict';

var FRAGMENT = "precision lowp float;\n#define GLSLIFY 1\nuniform vec4 color;\nvoid main() {\n  gl_FragColor = vec4(color.xyz * color.w, color.w);\n}\n";

module.exports = {
  lineVert: "precision mediump float;\n#define GLSLIFY 1\n\nattribute vec2 coord;\n\nuniform vec4 screenBox;\nuniform vec2 start, end;\nuniform float width;\n\nvec2 perp(vec2 v) {\n  return vec2(v.y, -v.x);\n}\n\nvec2 screen(vec2 v) {\n  return 2.0 * (v - screenBox.xy) / (screenBox.zw - screenBox.xy) - 1.0;\n}\n\nvoid main() {\n  vec2 delta = normalize(perp(start - end));\n  vec2 offset = mix(start, end, 0.5 * (coord.y+1.0));\n  gl_Position = vec4(screen(offset + 0.5 * width * delta * coord.x), 0, 1);\n}\n",
  lineFrag: FRAGMENT,
  textVert: "#define GLSLIFY 1\nattribute vec3 textCoordinate;\n\nuniform vec2 dataScale, dataShift, dataAxis, screenOffset, textScale;\nuniform float angle;\n\nvoid main() {\n  float dataOffset  = textCoordinate.z;\n  vec2 glyphOffset  = textCoordinate.xy;\n  mat2 glyphMatrix = mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n  vec2 screenCoordinate = dataAxis * (dataScale * dataOffset + dataShift) +\n    glyphMatrix * glyphOffset * textScale + screenOffset;\n  gl_Position = vec4(screenCoordinate, 0, 1);\n}\n",
  textFrag: FRAGMENT,
  gridVert: "precision mediump float;\n#define GLSLIFY 1\n\nattribute vec3 dataCoord;\n\nuniform vec2 dataAxis, dataShift, dataScale;\nuniform float lineWidth;\n\nvoid main() {\n  vec2 pos = dataAxis * (dataScale * dataCoord.x + dataShift);\n  pos += 10.0 * dataCoord.y * vec2(dataAxis.y, -dataAxis.x) + dataCoord.z * lineWidth;\n  gl_Position = vec4(pos, 0, 1);\n}\n",
  gridFrag: FRAGMENT,
  boxVert: "precision mediump float;\n#define GLSLIFY 1\n\nattribute vec2 coord;\n\nuniform vec4 screenBox;\nuniform vec2 lo, hi;\n\nvec2 screen(vec2 v) {\n  return 2.0 * (v - screenBox.xy) / (screenBox.zw - screenBox.xy) - 1.0;\n}\n\nvoid main() {\n  gl_Position = vec4(screen(mix(lo, hi, coord)), 0, 1);\n}\n",
  tickVert: "precision mediump float;\n#define GLSLIFY 1\n\nattribute vec3 dataCoord;\n\nuniform vec2 dataAxis, dataShift, dataScale, screenOffset, tickScale;\n\nvoid main() {\n  vec2 pos = dataAxis * (dataScale * dataCoord.x + dataShift);\n  gl_Position = vec4(pos + tickScale*dataCoord.yz + screenOffset, 0, 1);\n}\n"
};

},{}],79:[function(require,module,exports){
'use strict';

module.exports = createTextElements;

var createBuffer = require('gl-buffer');
var createShader = require('gl-shader');
var getText = require('text-cache');
var bsearch = require('binary-search-bounds');
var shaders = require('./shaders');

function TextElements(plot, vbo, shader) {
  this.plot = plot;
  this.vbo = vbo;
  this.shader = shader;
  this.tickOffset = [[], []];
  this.tickX = [[], []];
  this.labelOffset = [0, 0];
  this.labelCount = [0, 0];
}

var proto = TextElements.prototype;

proto.drawTicks = function () {
  var DATA_AXIS = [0, 0];
  var SCREEN_OFFSET = [0, 0];
  var ZERO_2 = [0, 0];

  return function (axis) {
    var plot = this.plot;
    var shader = this.shader;
    var tickX = this.tickX[axis];
    var tickOffset = this.tickOffset[axis];
    var gl = plot.gl;
    var viewBox = plot.viewBox;
    var dataBox = plot.dataBox;
    var screenBox = plot.screenBox;
    var pixelRatio = plot.pixelRatio;
    var tickEnable = plot.tickEnable;
    var tickPad = plot.tickPad;
    var textColor = plot.tickColor;
    var textAngle = plot.tickAngle;
    // todo check if this should be used (now unused)
    // var tickLength  = plot.tickMarkLength

    var labelEnable = plot.labelEnable;
    var labelPad = plot.labelPad;
    var labelColor = plot.labelColor;
    var labelAngle = plot.labelAngle;
    var labelOffset = this.labelOffset[axis];
    var labelCount = this.labelCount[axis];

    var start = bsearch.lt(tickX, dataBox[axis]);
    var end = bsearch.le(tickX, dataBox[axis + 2]);

    DATA_AXIS[0] = DATA_AXIS[1] = 0;
    DATA_AXIS[axis] = 1;

    SCREEN_OFFSET[axis] = (viewBox[2 + axis] + viewBox[axis]) / (screenBox[2 + axis] - screenBox[axis]) - 1.0;

    var screenScale = 2.0 / screenBox[2 + (axis ^ 1)] - screenBox[axis ^ 1];

    SCREEN_OFFSET[axis ^ 1] = screenScale * viewBox[axis ^ 1] - 1.0;
    if (tickEnable[axis]) {
      SCREEN_OFFSET[axis ^ 1] -= screenScale * pixelRatio * tickPad[axis];
      if (start < end && tickOffset[end] > tickOffset[start]) {
        shader.uniforms.dataAxis = DATA_AXIS;
        shader.uniforms.screenOffset = SCREEN_OFFSET;
        shader.uniforms.color = textColor[axis];
        shader.uniforms.angle = textAngle[axis];
        gl.drawArrays(gl.TRIANGLES, tickOffset[start], tickOffset[end] - tickOffset[start]);
      }
    }
    if (labelEnable[axis] && labelCount) {
      SCREEN_OFFSET[axis ^ 1] -= screenScale * pixelRatio * labelPad[axis];
      shader.uniforms.dataAxis = ZERO_2;
      shader.uniforms.screenOffset = SCREEN_OFFSET;
      shader.uniforms.color = labelColor[axis];
      shader.uniforms.angle = labelAngle[axis];
      gl.drawArrays(gl.TRIANGLES, labelOffset, labelCount);
    }

    SCREEN_OFFSET[axis ^ 1] = screenScale * viewBox[2 + (axis ^ 1)] - 1.0;
    if (tickEnable[axis + 2]) {
      SCREEN_OFFSET[axis ^ 1] += screenScale * pixelRatio * tickPad[axis + 2];
      if (start < end && tickOffset[end] > tickOffset[start]) {
        shader.uniforms.dataAxis = DATA_AXIS;
        shader.uniforms.screenOffset = SCREEN_OFFSET;
        shader.uniforms.color = textColor[axis + 2];
        shader.uniforms.angle = textAngle[axis + 2];
        gl.drawArrays(gl.TRIANGLES, tickOffset[start], tickOffset[end] - tickOffset[start]);
      }
    }
    if (labelEnable[axis + 2] && labelCount) {
      SCREEN_OFFSET[axis ^ 1] += screenScale * pixelRatio * labelPad[axis + 2];
      shader.uniforms.dataAxis = ZERO_2;
      shader.uniforms.screenOffset = SCREEN_OFFSET;
      shader.uniforms.color = labelColor[axis + 2];
      shader.uniforms.angle = labelAngle[axis + 2];
      gl.drawArrays(gl.TRIANGLES, labelOffset, labelCount);
    }
  };
}();

proto.drawTitle = function () {
  var DATA_AXIS = [0, 0];
  var SCREEN_OFFSET = [0, 0];

  return function () {
    var plot = this.plot;
    var shader = this.shader;
    var gl = plot.gl;
    var screenBox = plot.screenBox;
    var titleCenter = plot.titleCenter;
    var titleAngle = plot.titleAngle;
    var titleColor = plot.titleColor;
    var pixelRatio = plot.pixelRatio;

    if (!this.titleCount) {
      return;
    }

    for (var i = 0; i < 2; ++i) {
      SCREEN_OFFSET[i] = 2.0 * (titleCenter[i] * pixelRatio - screenBox[i]) / (screenBox[2 + i] - screenBox[i]) - 1;
    }

    shader.bind();
    shader.uniforms.dataAxis = DATA_AXIS;
    shader.uniforms.screenOffset = SCREEN_OFFSET;
    shader.uniforms.angle = titleAngle;
    shader.uniforms.color = titleColor;

    gl.drawArrays(gl.TRIANGLES, this.titleOffset, this.titleCount);
  };
}();

proto.bind = function () {
  var DATA_SHIFT = [0, 0];
  var DATA_SCALE = [0, 0];
  var TEXT_SCALE = [0, 0];

  return function () {
    var plot = this.plot;
    var shader = this.shader;
    var bounds = plot._tickBounds;
    var dataBox = plot.dataBox;
    var screenBox = plot.screenBox;
    var viewBox = plot.viewBox;

    shader.bind

    //Set up coordinate scaling uniforms
    ();for (var i = 0; i < 2; ++i) {

      var lo = bounds[i];
      var hi = bounds[i + 2];
      var boundScale = hi - lo;
      var dataCenter = 0.5 * (dataBox[i + 2] + dataBox[i]);
      var dataWidth = dataBox[i + 2] - dataBox[i];

      var viewLo = viewBox[i];
      var viewHi = viewBox[i + 2];
      var viewScale = viewHi - viewLo;
      var screenLo = screenBox[i];
      var screenHi = screenBox[i + 2];
      var screenScale = screenHi - screenLo;

      DATA_SCALE[i] = 2.0 * boundScale / dataWidth * viewScale / screenScale;
      DATA_SHIFT[i] = 2.0 * (lo - dataCenter) / dataWidth * viewScale / screenScale;
    }

    TEXT_SCALE[1] = 2.0 * plot.pixelRatio / (screenBox[3] - screenBox[1]);
    TEXT_SCALE[0] = TEXT_SCALE[1] * (screenBox[3] - screenBox[1]) / (screenBox[2] - screenBox[0]);

    shader.uniforms.dataScale = DATA_SCALE;
    shader.uniforms.dataShift = DATA_SHIFT;
    shader.uniforms.textScale = TEXT_SCALE;

    //Set attributes
    this.vbo.bind();
    shader.attributes.textCoordinate.pointer();
  };
}();

proto.update = function (options) {
  var vertices = [];
  var axesTicks = options.ticks;
  var bounds = options.bounds;
  var i, j, k, data, scale, dimension;

  for (dimension = 0; dimension < 2; ++dimension) {
    var offsets = [Math.floor(vertices.length / 3)],
        tickX = [-Infinity];

    //Copy vertices over to buffer
    var ticks = axesTicks[dimension];
    for (i = 0; i < ticks.length; ++i) {
      var tick = ticks[i];
      var x = tick.x;
      var text = tick.text;
      var font = tick.font || 'sans-serif';
      scale = tick.fontSize || 12;

      var coordScale = 1.0 / (bounds[dimension + 2] - bounds[dimension]);
      var coordShift = bounds[dimension];

      var rows = text.split('\n');
      for (var r = 0; r < rows.length; r++) {
        data = getText(font, rows[r]).data;
        for (j = 0; j < data.length; j += 2) {
          vertices.push(data[j] * scale, -data[j + 1] * scale - r * scale * 1.2, (x - coordShift) * coordScale);
        }
      }

      offsets.push(Math.floor(vertices.length / 3));
      tickX.push(x);
    }

    this.tickOffset[dimension] = offsets;
    this.tickX[dimension] = tickX;
  }

  //Add labels
  for (dimension = 0; dimension < 2; ++dimension) {
    this.labelOffset[dimension] = Math.floor(vertices.length / 3);

    data = getText(options.labelFont[dimension], options.labels[dimension], { textAlign: 'center' }).data;
    scale = options.labelSize[dimension];
    for (i = 0; i < data.length; i += 2) {
      vertices.push(data[i] * scale, -data[i + 1] * scale, 0);
    }

    this.labelCount[dimension] = Math.floor(vertices.length / 3) - this.labelOffset[dimension];
  }

  //Add title
  this.titleOffset = Math.floor(vertices.length / 3);
  data = getText(options.titleFont, options.title).data;
  scale = options.titleSize;
  for (i = 0; i < data.length; i += 2) {
    vertices.push(data[i] * scale, -data[i + 1] * scale, 0);
  }
  this.titleCount = Math.floor(vertices.length / 3) - this.titleOffset;

  //Upload new vertices
  this.vbo.update(vertices);
};

proto.dispose = function () {
  this.vbo.dispose();
  this.shader.dispose();
};

function createTextElements(plot) {
  var gl = plot.gl;
  var vbo = createBuffer(gl);
  var shader = createShader(gl, shaders.textVert, shaders.textFrag);
  var text = new TextElements(plot, vbo, shader);
  return text;
}

},{"./shaders":78,"binary-search-bounds":26,"gl-buffer":70,"gl-shader":84,"text-cache":154}],80:[function(require,module,exports){
'use strict';

module.exports = createGLPlot2D;

var createPick = require('gl-select-static');

var createGrid = require('./lib/grid');
var createText = require('./lib/text');
var createLine = require('./lib/line');
var createBox = require('./lib/box');

function GLPlot2D(gl, pickBuffer) {
  this.gl = gl;
  this.pickBuffer = pickBuffer;

  this.screenBox = [0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight];
  this.viewBox = [0, 0, 0, 0];
  this.dataBox = [-10, -10, 10, 10];

  this.gridLineEnable = [true, true];
  this.gridLineWidth = [1, 1];
  this.gridLineColor = [[0, 0, 0, 1], [0, 0, 0, 1]];

  this.pixelRatio = 1;

  this.tickMarkLength = [0, 0, 0, 0];
  this.tickMarkWidth = [0, 0, 0, 0];
  this.tickMarkColor = [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]];

  this.tickPad = [15, 15, 15, 15];
  this.tickAngle = [0, 0, 0, 0];
  this.tickEnable = [true, true, true, true];
  this.tickColor = [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]];

  this.labelPad = [15, 15, 15, 15];
  this.labelAngle = [0, Math.PI / 2, 0, 3.0 * Math.PI / 2];
  this.labelEnable = [true, true, true, true];
  this.labelColor = [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]];

  this.titleCenter = [0, 0];
  this.titleEnable = true;
  this.titleAngle = 0;
  this.titleColor = [0, 0, 0, 1];

  this.borderColor = [0, 0, 0, 0];
  this.backgroundColor = [0, 0, 0, 0];

  this.zeroLineEnable = [true, true];
  this.zeroLineWidth = [4, 4];
  this.zeroLineColor = [[0, 0, 0, 1], [0, 0, 0, 1]];

  this.borderLineEnable = [true, true, true, true];
  this.borderLineWidth = [2, 2, 2, 2];
  this.borderLineColor = [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]];

  //Drawing parameters
  this.grid = null;
  this.text = null;
  this.line = null;
  this.box = null;
  this.objects = [];
  this.overlays = [];

  this._tickBounds = [Infinity, Infinity, -Infinity, -Infinity];

  this.static = false;

  this.dirty = false;
  this.pickDirty = false;
  this.pickDelay = 120;
  this.pickRadius = 10;
  this._pickTimeout = null;
  this._drawPick = this.drawPick.bind(this);

  this._depthCounter = 0;
}

var proto = GLPlot2D.prototype;

proto.setDirty = function () {
  this.dirty = this.pickDirty = true;
};

proto.setOverlayDirty = function () {
  this.dirty = true;
};

proto.nextDepthValue = function () {
  return this._depthCounter++ / 65536.0;
};

function lerp(a, b, t) {
  var s = 0.5 * (t + 1.0);
  return Math.floor((1.0 - s) * a + s * b) | 0;
}

proto.draw = function () {
  var TICK_MARK_BOX = [0, 0, 0, 0];
  return function () {
    var gl = this.gl;
    var screenBox = this.screenBox;
    var viewPixels = this.viewBox;
    var dataBox = this.dataBox;
    var pixelRatio = this.pixelRatio;
    var grid = this.grid;
    var line = this.line;
    var text = this.text;
    var objects = this.objects;

    this._depthCounter = 0;

    if (this.pickDirty) {
      if (this._pickTimeout) {
        clearTimeout(this._pickTimeout);
      }
      this.pickDirty = false;
      this._pickTimeout = setTimeout(this._drawPick, this.pickDelay);
    }

    if (!this.dirty) {
      return;
    }
    this.dirty = false;

    gl.bindFramebuffer(gl.FRAMEBUFFER, null

    //Turn on scissor
    );gl.enable(gl.SCISSOR_TEST

    //Turn off depth buffer
    );gl.disable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LESS);
    gl.depthMask(false

    //Configure premultiplied alpha blending
    );gl.enable(gl.BLEND);
    gl.blendEquation(gl.FUNC_ADD, gl.FUNC_ADD);
    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

    //Draw border
    gl.scissor(screenBox[0], screenBox[1], screenBox[2] - screenBox[0], screenBox[3] - screenBox[1]);
    var borderColor = this.borderColor;
    gl.clearColor(borderColor[0] * borderColor[3], borderColor[1] * borderColor[3], borderColor[2] * borderColor[3], borderColor[3]);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT

    //Draw center pane
    );gl.scissor(viewPixels[0], viewPixels[1], viewPixels[2] - viewPixels[0], viewPixels[3] - viewPixels[1]);
    gl.viewport(viewPixels[0], viewPixels[1], viewPixels[2] - viewPixels[0], viewPixels[3] - viewPixels[1]);
    var backgroundColor = this.backgroundColor;
    gl.clearColor(backgroundColor[0] * backgroundColor[3], backgroundColor[1] * backgroundColor[3], backgroundColor[2] * backgroundColor[3], backgroundColor[3]);
    gl.clear(gl.COLOR_BUFFER_BIT

    //Draw grid
    );grid.draw

    //Draw zero lines separately
    ();var zeroLineEnable = this.zeroLineEnable;
    var zeroLineColor = this.zeroLineColor;
    var zeroLineWidth = this.zeroLineWidth;
    if (zeroLineEnable[0] || zeroLineEnable[1]) {
      line.bind();
      for (var i = 0; i < 2; ++i) {
        if (!zeroLineEnable[i] || !(dataBox[i] <= 0 && dataBox[i + 2] >= 0)) {
          continue;
        }

        var zeroIntercept = screenBox[i] - dataBox[i] * (screenBox[i + 2] - screenBox[i]) / (dataBox[i + 2] - dataBox[i]);

        if (i === 0) {
          line.drawLine(zeroIntercept, screenBox[1], zeroIntercept, screenBox[3], zeroLineWidth[i], zeroLineColor[i]);
        } else {
          line.drawLine(screenBox[0], zeroIntercept, screenBox[2], zeroIntercept, zeroLineWidth[i], zeroLineColor[i]);
        }
      }
    }

    //Draw traces
    for (var i = 0; i < objects.length; ++i) {
      objects[i].draw();
    }

    //Return viewport to default
    gl.viewport(screenBox[0], screenBox[1], screenBox[2] - screenBox[0], screenBox[3] - screenBox[1]);
    gl.scissor(screenBox[0], screenBox[1], screenBox[2] - screenBox[0], screenBox[3] - screenBox[1]

    //Draw tick marks
    );this.grid.drawTickMarks

    //Draw line elements
    ();line.bind

    //Draw border lines
    ();var borderLineEnable = this.borderLineEnable;
    var borderLineWidth = this.borderLineWidth;
    var borderLineColor = this.borderLineColor;
    if (borderLineEnable[1]) {
      line.drawLine(viewPixels[0], viewPixels[1] - 0.5 * borderLineWidth[1] * pixelRatio, viewPixels[0], viewPixels[3] + 0.5 * borderLineWidth[3] * pixelRatio, borderLineWidth[1], borderLineColor[1]);
    }
    if (borderLineEnable[0]) {
      line.drawLine(viewPixels[0] - 0.5 * borderLineWidth[0] * pixelRatio, viewPixels[1], viewPixels[2] + 0.5 * borderLineWidth[2] * pixelRatio, viewPixels[1], borderLineWidth[0], borderLineColor[0]);
    }
    if (borderLineEnable[3]) {
      line.drawLine(viewPixels[2], viewPixels[1] - 0.5 * borderLineWidth[1] * pixelRatio, viewPixels[2], viewPixels[3] + 0.5 * borderLineWidth[3] * pixelRatio, borderLineWidth[3], borderLineColor[3]);
    }
    if (borderLineEnable[2]) {
      line.drawLine(viewPixels[0] - 0.5 * borderLineWidth[0] * pixelRatio, viewPixels[3], viewPixels[2] + 0.5 * borderLineWidth[2] * pixelRatio, viewPixels[3], borderLineWidth[2], borderLineColor[2]);
    }

    //Draw text elements
    text.bind();
    for (var i = 0; i < 2; ++i) {
      text.drawTicks(i);
    }
    if (this.titleEnable) {
      text.drawTitle();
    }

    //Draw other overlay elements (select boxes, etc.)
    var overlays = this.overlays;
    for (var i = 0; i < overlays.length; ++i) {
      overlays[i].draw();
    }

    //Turn off scissor test
    gl.disable(gl.SCISSOR_TEST);
    gl.disable(gl.BLEND);
    gl.depthMask(true);
  };
}();

proto.drawPick = function () {

  return function () {
    if (this.static) return;

    var pickBuffer = this.pickBuffer;
    var gl = this.gl;

    this._pickTimeout = null;
    pickBuffer.begin();

    var pickOffset = 1;
    var objects = this.objects;
    for (var i = 0; i < objects.length; ++i) {
      pickOffset = objects[i].drawPick(pickOffset);
    }

    pickBuffer.end();
  };
}();

proto.pick = function () {
  return function (x, y) {
    if (this.static) return;

    var pixelRatio = this.pixelRatio;
    var pickPixelRatio = this.pickPixelRatio;
    var viewBox = this.viewBox;

    var scrX = Math.round((x - viewBox[0] / pixelRatio) * pickPixelRatio) | 0;
    var scrY = Math.round((y - viewBox[1] / pixelRatio) * pickPixelRatio) | 0;

    var pickResult = this.pickBuffer.query(scrX, scrY, this.pickRadius);
    if (!pickResult) {
      return null;
    }

    var pickValue = pickResult.id + (pickResult.value[0] << 8) + (pickResult.value[1] << 16) + (pickResult.value[2] << 24);

    var objects = this.objects;
    for (var i = 0; i < objects.length; ++i) {
      var result = objects[i].pick(scrX, scrY, pickValue);
      if (result) {
        return result;
      }
    }

    return null;
  };
}();

function deepClone(array) {
  var result = array.slice();
  for (var i = 0; i < result.length; ++i) {
    result[i] = result[i].slice();
  }
  return result;
}

function compareTicks(a, b) {
  return a.x - b.x;
}

proto.setScreenBox = function (nbox) {
  var screenBox = this.screenBox;
  var pixelRatio = this.pixelRatio;

  screenBox[0] = Math.round(nbox[0] * pixelRatio) | 0;
  screenBox[1] = Math.round(nbox[1] * pixelRatio) | 0;
  screenBox[2] = Math.round(nbox[2] * pixelRatio) | 0;
  screenBox[3] = Math.round(nbox[3] * pixelRatio) | 0;

  this.setDirty();
};

proto.setDataBox = function (nbox) {
  var dataBox = this.dataBox;

  var different = dataBox[0] !== nbox[0] || dataBox[1] !== nbox[1] || dataBox[2] !== nbox[2] || dataBox[3] !== nbox[3];

  if (different) {
    dataBox[0] = nbox[0];
    dataBox[1] = nbox[1];
    dataBox[2] = nbox[2];
    dataBox[3] = nbox[3];

    this.setDirty();
  }
};

proto.setViewBox = function (nbox) {
  var pixelRatio = this.pixelRatio;
  var viewBox = this.viewBox;

  viewBox[0] = Math.round(nbox[0] * pixelRatio) | 0;
  viewBox[1] = Math.round(nbox[1] * pixelRatio) | 0;
  viewBox[2] = Math.round(nbox[2] * pixelRatio) | 0;
  viewBox[3] = Math.round(nbox[3] * pixelRatio) | 0;

  var pickPixelRatio = this.pickPixelRatio;
  this.pickBuffer.shape = [Math.round((nbox[2] - nbox[0]) * pickPixelRatio) | 0, Math.round((nbox[3] - nbox[1]) * pickPixelRatio) | 0];

  this.setDirty();
};

proto.update = function (options) {
  options = options || {};

  var gl = this.gl;

  this.pixelRatio = options.pixelRatio || 1;

  var pixelRatio = this.pixelRatio;
  this.pickPixelRatio = Math.max(pixelRatio, 1);

  this.setScreenBox(options.screenBox || [0, 0, gl.drawingBufferWidth / pixelRatio, gl.drawingBufferHeight / pixelRatio]);

  var screenBox = this.screenBox;
  this.setViewBox(options.viewBox || [0.125 * (this.screenBox[2] - this.screenBox[0]) / pixelRatio, 0.125 * (this.screenBox[3] - this.screenBox[1]) / pixelRatio, 0.875 * (this.screenBox[2] - this.screenBox[0]) / pixelRatio, 0.875 * (this.screenBox[3] - this.screenBox[1]) / pixelRatio]);

  var viewBox = this.viewBox;
  var aspectRatio = (viewBox[2] - viewBox[0]) / (viewBox[3] - viewBox[1]);
  this.setDataBox(options.dataBox || [-10, -10 / aspectRatio, 10, 10 / aspectRatio]);

  this.borderColor = (options.borderColor || [0, 0, 0, 0]).slice();
  this.backgroundColor = (options.backgroundColor || [0, 0, 0, 0]).slice();

  this.gridLineEnable = (options.gridLineEnable || [true, true]).slice();
  this.gridLineWidth = (options.gridLineWidth || [1, 1]).slice();
  this.gridLineColor = deepClone(options.gridLineColor || [[0.5, 0.5, 0.5, 1], [0.5, 0.5, 0.5, 1]]);

  this.zeroLineEnable = (options.zeroLineEnable || [true, true]).slice();
  this.zeroLineWidth = (options.zeroLineWidth || [4, 4]).slice();
  this.zeroLineColor = deepClone(options.zeroLineColor || [[0, 0, 0, 1], [0, 0, 0, 1]]);

  this.tickMarkLength = (options.tickMarkLength || [0, 0, 0, 0]).slice();
  this.tickMarkWidth = (options.tickMarkWidth || [0, 0, 0, 0]).slice();
  this.tickMarkColor = deepClone(options.tickMarkColor || [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]]);

  this.titleCenter = (options.titleCenter || [0.5 * (viewBox[0] + viewBox[2]) / pixelRatio, (viewBox[3] + 120) / pixelRatio]).slice();
  this.titleEnable = !('titleEnable' in options) || !!options.titleEnable;
  this.titleAngle = options.titleAngle || 0;
  this.titleColor = (options.titleColor || [0, 0, 0, 1]).slice();

  this.labelPad = (options.labelPad || [15, 15, 15, 15]).slice();
  this.labelAngle = (options.labelAngle || [0, Math.PI / 2, 0, 3.0 * Math.PI / 2]).slice();
  this.labelEnable = (options.labelEnable || [true, true, true, true]).slice();
  this.labelColor = deepClone(options.labelColor || [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]]);

  this.tickPad = (options.tickPad || [15, 15, 15, 15]).slice();
  this.tickAngle = (options.tickAngle || [0, 0, 0, 0]).slice();
  this.tickEnable = (options.tickEnable || [true, true, true, true]).slice();
  this.tickColor = deepClone(options.tickColor || [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]]);

  this.borderLineEnable = (options.borderLineEnable || [true, true, true, true]).slice();
  this.borderLineWidth = (options.borderLineWidth || [2, 2, 2, 2]).slice();
  this.borderLineColor = deepClone(options.borderLineColor || [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]]);

  var ticks = options.ticks || [[], []];

  //Compute bounds on ticks
  var bounds = this._tickBounds;
  bounds[0] = bounds[1] = Infinity;
  bounds[2] = bounds[3] = -Infinity;
  for (var i = 0; i < 2; ++i) {
    var axisTicks = ticks[i].slice(0);
    if (axisTicks.length === 0) {
      continue;
    }
    axisTicks.sort(compareTicks);
    bounds[i] = Math.min(bounds[i], axisTicks[0].x);
    bounds[i + 2] = Math.max(bounds[i + 2], axisTicks[axisTicks.length - 1].x);
  }

  //Update grid
  this.grid.update({
    bounds: bounds,
    ticks: ticks
  }

  //Update text
  );this.text.update({
    bounds: bounds,
    ticks: ticks,
    labels: options.labels || ['x', 'y'],
    labelSize: options.labelSize || [12, 12],
    labelFont: options.labelFont || ['sans-serif', 'sans-serif'],
    title: options.title || '',
    titleSize: options.titleSize || 18,
    titleFont: options.titleFont || 'sans-serif'
  });

  this.static = !!options.static;

  this.setDirty();
};

proto.dispose = function () {
  this.box.dispose();
  this.grid.dispose();
  this.text.dispose();
  this.line.dispose();
  for (var i = this.objects.length - 1; i >= 0; --i) {
    this.objects[i].dispose();
  }
  this.objects.length = 0;
  for (var i = this.overlays.length - 1; i >= 0; --i) {
    this.overlays[i].dispose();
  }
  this.overlays.length = 0;

  this.gl = null;
};

proto.addObject = function (object) {
  if (this.objects.indexOf(object) < 0) {
    this.objects.push(object);
    this.setDirty();
  }
};

proto.removeObject = function (object) {
  var objects = this.objects;
  for (var i = 0; i < objects.length; ++i) {
    if (objects[i] === object) {
      objects.splice(i, 1);
      this.setDirty();
      break;
    }
  }
};

proto.addOverlay = function (object) {
  if (this.overlays.indexOf(object) < 0) {
    this.overlays.push(object);
    this.setOverlayDirty();
  }
};

proto.removeOverlay = function (object) {
  var objects = this.overlays;
  for (var i = 0; i < objects.length; ++i) {
    if (objects[i] === object) {
      objects.splice(i, 1);
      this.setOverlayDirty();
      break;
    }
  }
};

function createGLPlot2D(options) {
  var gl = options.gl;
  var pickBuffer = createPick(gl, [gl.drawingBufferWidth, gl.drawingBufferHeight]);
  var plot = new GLPlot2D(gl, pickBuffer);
  plot.grid = createGrid(plot);
  plot.text = createText(plot);
  plot.line = createLine(plot);
  plot.box = createBox(plot);
  plot.update(options);
  return plot;
}

},{"./lib/box":75,"./lib/grid":76,"./lib/line":77,"./lib/text":79,"gl-select-static":83}],81:[function(require,module,exports){
'use strict';

exports.boxVertex = "precision mediump float;\n#define GLSLIFY 1\n\nattribute vec2 vertex;\n\nuniform vec2 cornerA, cornerB;\n\nvoid main() {\n  gl_Position = vec4(mix(cornerA, cornerB, vertex), 0, 1);\n}\n";
exports.boxFragment = "precision mediump float;\n#define GLSLIFY 1\n\nuniform vec4 color;\n\nvoid main() {\n  gl_FragColor = color;\n}\n";

},{}],82:[function(require,module,exports){
'use strict';

var createShader = require('gl-shader');
var createBuffer = require('gl-buffer');

var SHADERS = require('./lib/shaders');

module.exports = createSelectBox;

function SelectBox(plot, boxBuffer, boxShader) {
  this.plot = plot;
  this.boxBuffer = boxBuffer;
  this.boxShader = boxShader;

  this.enabled = true;

  this.selectBox = [Infinity, Infinity, -Infinity, -Infinity];

  this.borderColor = [0, 0, 0, 1];
  this.innerFill = false;
  this.innerColor = [0, 0, 0, 0.25];
  this.outerFill = true;
  this.outerColor = [0, 0, 0, 0.5];
  this.borderWidth = 10;
}

var proto = SelectBox.prototype;

proto.draw = function () {
  if (!this.enabled) {
    return;
  }

  var plot = this.plot;
  var selectBox = this.selectBox;
  var lineWidth = this.borderWidth;

  var innerFill = this.innerFill;
  var innerColor = this.innerColor;
  var outerFill = this.outerFill;
  var outerColor = this.outerColor;
  var borderColor = this.borderColor;

  var boxes = plot.box;
  var screenBox = plot.screenBox;
  var dataBox = plot.dataBox;
  var viewBox = plot.viewBox;
  var pixelRatio = plot.pixelRatio;

  //Map select box into pixel coordinates
  var loX = (selectBox[0] - dataBox[0]) * (viewBox[2] - viewBox[0]) / (dataBox[2] - dataBox[0]) + viewBox[0];
  var loY = (selectBox[1] - dataBox[1]) * (viewBox[3] - viewBox[1]) / (dataBox[3] - dataBox[1]) + viewBox[1];
  var hiX = (selectBox[2] - dataBox[0]) * (viewBox[2] - viewBox[0]) / (dataBox[2] - dataBox[0]) + viewBox[0];
  var hiY = (selectBox[3] - dataBox[1]) * (viewBox[3] - viewBox[1]) / (dataBox[3] - dataBox[1]) + viewBox[1];

  loX = Math.max(loX, viewBox[0]);
  loY = Math.max(loY, viewBox[1]);
  hiX = Math.min(hiX, viewBox[2]);
  hiY = Math.min(hiY, viewBox[3]);

  if (hiX < loX || hiY < loY) {
    return;
  }

  boxes.bind

  //Draw box
  ();var screenWidth = screenBox[2] - screenBox[0];
  var screenHeight = screenBox[3] - screenBox[1];

  if (this.outerFill) {
    boxes.drawBox(0, 0, screenWidth, loY, outerColor);
    boxes.drawBox(0, loY, loX, hiY, outerColor);
    boxes.drawBox(0, hiY, screenWidth, screenHeight, outerColor);
    boxes.drawBox(hiX, loY, screenWidth, hiY, outerColor);
  }

  if (this.innerFill) {
    boxes.drawBox(loX, loY, hiX, hiY, innerColor);
  }

  //Draw border
  if (lineWidth > 0) {

    //Draw border
    var w = lineWidth * pixelRatio;
    boxes.drawBox(loX - w, loY - w, hiX + w, loY + w, borderColor);
    boxes.drawBox(loX - w, hiY - w, hiX + w, hiY + w, borderColor);
    boxes.drawBox(loX - w, loY - w, loX + w, hiY + w, borderColor);
    boxes.drawBox(hiX - w, loY - w, hiX + w, hiY + w, borderColor);
  }
};

proto.update = function (options) {
  options = options || {};

  this.innerFill = !!options.innerFill;
  this.outerFill = !!options.outerFill;
  this.innerColor = (options.innerColor || [0, 0, 0, 0.5]).slice();
  this.outerColor = (options.outerColor || [0, 0, 0, 0.5]).slice();
  this.borderColor = (options.borderColor || [0, 0, 0, 1]).slice();
  this.borderWidth = options.borderWidth || 0;
  this.selectBox = (options.selectBox || this.selectBox).slice();
};

proto.dispose = function () {
  this.boxBuffer.dispose();
  this.boxShader.dispose();
  this.plot.removeOverlay(this);
};

function createSelectBox(plot, options) {
  var gl = plot.gl;
  var buffer = createBuffer(gl, [0, 0, 0, 1, 1, 0, 1, 1]);
  var shader = createShader(gl, SHADERS.boxVertex, SHADERS.boxFragment);
  var selectBox = new SelectBox(plot, buffer, shader);
  selectBox.update(options);
  plot.addOverlay(selectBox);
  return selectBox;
}

},{"./lib/shaders":81,"gl-buffer":70,"gl-shader":84}],83:[function(require,module,exports){
'use strict';

module.exports = createSelectBuffer;

var createFBO = require('gl-fbo');
var pool = require('typedarray-pool');
var ndarray = require('ndarray');

var nextPow2 = require('bit-twiddle').nextPow2;

var selectRange = require('cwise/lib/wrapper')({ "args": ["array", { "offset": [0, 0, 1], "array": 0 }, { "offset": [0, 0, 2], "array": 0 }, { "offset": [0, 0, 3], "array": 0 }, "scalar", "scalar", "index"], "pre": { "body": "{this_closestD2=1e8,this_closestX=-1,this_closestY=-1}", "args": [], "thisVars": ["this_closestD2", "this_closestX", "this_closestY"], "localVars": [] }, "body": { "body": "{if(_inline_1_arg0_<255||_inline_1_arg1_<255||_inline_1_arg2_<255||_inline_1_arg3_<255){var _inline_1_l=_inline_1_arg4_-_inline_1_arg6_[0],_inline_1_a=_inline_1_arg5_-_inline_1_arg6_[1],_inline_1_f=_inline_1_l*_inline_1_l+_inline_1_a*_inline_1_a;_inline_1_f<this_closestD2&&(this_closestD2=_inline_1_f,this_closestX=_inline_1_arg6_[0],this_closestY=_inline_1_arg6_[1])}}", "args": [{ "name": "_inline_1_arg0_", "lvalue": false, "rvalue": true, "count": 1 }, { "name": "_inline_1_arg1_", "lvalue": false, "rvalue": true, "count": 1 }, { "name": "_inline_1_arg2_", "lvalue": false, "rvalue": true, "count": 1 }, { "name": "_inline_1_arg3_", "lvalue": false, "rvalue": true, "count": 1 }, { "name": "_inline_1_arg4_", "lvalue": false, "rvalue": true, "count": 1 }, { "name": "_inline_1_arg5_", "lvalue": false, "rvalue": true, "count": 1 }, { "name": "_inline_1_arg6_", "lvalue": false, "rvalue": true, "count": 4 }], "thisVars": ["this_closestD2", "this_closestX", "this_closestY"], "localVars": ["_inline_1_a", "_inline_1_f", "_inline_1_l"] }, "post": { "body": "{return[this_closestX,this_closestY,this_closestD2]}", "args": [], "thisVars": ["this_closestD2", "this_closestX", "this_closestY"], "localVars": [] }, "debug": false, "funcName": "cwise", "blockSize": 64 });

function SelectResult(x, y, id, value, distance) {
  this.coord = [x, y];
  this.id = id;
  this.value = value;
  this.distance = distance;
}

function SelectBuffer(gl, fbo, buffer) {
  this.gl = gl;
  this.fbo = fbo;
  this.buffer = buffer;
  this._readTimeout = null;
  var self = this;

  this._readCallback = function () {
    if (!self.gl) {
      return;
    }
    fbo.bind();
    gl.readPixels(0, 0, fbo.shape[0], fbo.shape[1], gl.RGBA, gl.UNSIGNED_BYTE, self.buffer);
    self._readTimeout = null;
  };
}

var proto = SelectBuffer.prototype;

Object.defineProperty(proto, 'shape', {
  get: function () {
    if (!this.gl) {
      return [0, 0];
    }
    return this.fbo.shape.slice();
  },
  set: function (v) {
    if (!this.gl) {
      return;
    }
    this.fbo.shape = v;
    var c = this.fbo.shape[0];
    var r = this.fbo.shape[1];
    if (r * c * 4 > this.buffer.length) {
      pool.free(this.buffer);
      var buffer = this.buffer = pool.mallocUint8(nextPow2(r * c * 4));
      for (var i = 0; i < r * c * 4; ++i) {
        buffer[i] = 0xff;
      }
    }
    return v;
  }
});

proto.begin = function () {
  var gl = this.gl;
  var shape = this.shape;
  if (!gl) {
    return;
  }

  this.fbo.bind();
  gl.clearColor(1, 1, 1, 1);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
};

proto.end = function () {
  var gl = this.gl;
  if (!gl) {
    return;
  }
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  if (!this._readTimeout) {
    clearTimeout(this._readTimeout);
  }
  this._readTimeout = setTimeout(this._readCallback, 1);
};

proto.query = function (x, y, radius) {
  if (!this.gl) {
    return null;
  }

  var shape = this.fbo.shape.slice();

  x = x | 0;
  y = y | 0;
  if (typeof radius !== 'number') {
    radius = 1.0;
  }

  var x0 = Math.min(Math.max(x - radius, 0), shape[0]) | 0;
  var x1 = Math.min(Math.max(x + radius, 0), shape[0]) | 0;
  var y0 = Math.min(Math.max(y - radius, 0), shape[1]) | 0;
  var y1 = Math.min(Math.max(y + radius, 0), shape[1]) | 0;

  if (x1 <= x0 || y1 <= y0) {
    return null;
  }

  var dims = [x1 - x0, y1 - y0];
  var region = ndarray(this.buffer, [dims[0], dims[1], 4], [4, shape[0] * 4, 1], 4 * (x0 + shape[0] * y0));

  var closest = selectRange(region.hi(dims[0], dims[1], 1), radius, radius);
  var dx = closest[0];
  var dy = closest[1];
  if (dx < 0 || Math.pow(this.radius, 2) < closest[2]) {
    return null;
  }

  var c0 = region.get(dx, dy, 0);
  var c1 = region.get(dx, dy, 1);
  var c2 = region.get(dx, dy, 2);
  var c3 = region.get(dx, dy, 3);

  return new SelectResult(dx + x0 | 0, dy + y0 | 0, c0, [c1, c2, c3], Math.sqrt(closest[2]));
};

proto.dispose = function () {
  if (!this.gl) {
    return;
  }
  this.fbo.dispose();
  pool.free(this.buffer);
  this.gl = null;
  if (this._readTimeout) {
    clearTimeout(this._readTimeout);
  }
};

function createSelectBuffer(gl, shape) {
  var fbo = createFBO(gl, shape);
  var buffer = pool.mallocUint8(shape[0] * shape[1] * 4);
  return new SelectBuffer(gl, fbo, buffer);
}

},{"bit-twiddle":27,"cwise/lib/wrapper":57,"gl-fbo":73,"ndarray":114,"typedarray-pool":162}],84:[function(require,module,exports){
'use strict';

var createUniformWrapper = require('./lib/create-uniforms');
var createAttributeWrapper = require('./lib/create-attributes');
var makeReflect = require('./lib/reflect');
var shaderCache = require('./lib/shader-cache');
var runtime = require('./lib/runtime-reflect');
var GLError = require("./lib/GLError"

//Shader object
);function Shader(gl) {
  this.gl = gl;
  this.gl.lastAttribCount = 0; // fixme where else should we store info, safe but not nice on the gl object

  //Default initialize these to null
  this._vref = this._fref = this._relink = this.vertShader = this.fragShader = this.program = this.attributes = this.uniforms = this.types = null;
}

var proto = Shader.prototype;

proto.bind = function () {
  if (!this.program) {
    this._relink();
  }

  // ensuring that we have the right number of enabled vertex attributes
  var i;
  var newAttribCount = this.gl.getProgramParameter(this.program, this.gl.ACTIVE_ATTRIBUTES // more robust approach
  //var newAttribCount = Object.keys(this.attributes).length // avoids the probably immaterial introspection slowdown
  );var oldAttribCount = this.gl.lastAttribCount;
  if (newAttribCount > oldAttribCount) {
    for (i = oldAttribCount; i < newAttribCount; i++) {
      this.gl.enableVertexAttribArray(i);
    }
  } else if (oldAttribCount > newAttribCount) {
    for (i = newAttribCount; i < oldAttribCount; i++) {
      this.gl.disableVertexAttribArray(i);
    }
  }

  this.gl.lastAttribCount = newAttribCount;

  this.gl.useProgram(this.program);
};

proto.dispose = function () {

  // disabling vertex attributes so new shader starts with zero
  // and it's also useful if all shaders are disposed but the
  // gl context is reused for subsequent replotting
  var oldAttribCount = this.gl.lastAttribCount;
  for (var i = 0; i < oldAttribCount; i++) {
    this.gl.disableVertexAttribArray(i);
  }
  this.gl.lastAttribCount = 0;

  if (this._fref) {
    this._fref.dispose();
  }
  if (this._vref) {
    this._vref.dispose();
  }
  this.attributes = this.types = this.vertShader = this.fragShader = this.program = this._relink = this._fref = this._vref = null;
};

function compareAttributes(a, b) {
  if (a.name < b.name) {
    return -1;
  }
  return 1;
}

//Update export hook for glslify-live
proto.update = function (vertSource, fragSource, uniforms, attributes) {

  //If only one object passed, assume glslify style output
  if (!fragSource || arguments.length === 1) {
    var obj = vertSource;
    vertSource = obj.vertex;
    fragSource = obj.fragment;
    uniforms = obj.uniforms;
    attributes = obj.attributes;
  }

  var wrapper = this;
  var gl = wrapper.gl;

  //Compile vertex and fragment shaders
  var pvref = wrapper._vref;
  wrapper._vref = shaderCache.shader(gl, gl.VERTEX_SHADER, vertSource);
  if (pvref) {
    pvref.dispose();
  }
  wrapper.vertShader = wrapper._vref.shader;
  var pfref = this._fref;
  wrapper._fref = shaderCache.shader(gl, gl.FRAGMENT_SHADER, fragSource);
  if (pfref) {
    pfref.dispose();
  }
  wrapper.fragShader = wrapper._fref.shader;

  //If uniforms/attributes is not specified, use RT reflection
  if (!uniforms || !attributes) {

    //Create initial test program
    var testProgram = gl.createProgram();
    gl.attachShader(testProgram, wrapper.fragShader);
    gl.attachShader(testProgram, wrapper.vertShader);
    gl.linkProgram(testProgram);
    if (!gl.getProgramParameter(testProgram, gl.LINK_STATUS)) {
      var errLog = gl.getProgramInfoLog(testProgram);
      throw new GLError(errLog, 'Error linking program:' + errLog);
    }

    //Load data from runtime
    uniforms = uniforms || runtime.uniforms(gl, testProgram);
    attributes = attributes || runtime.attributes(gl, testProgram

    //Release test program
    );gl.deleteProgram(testProgram);
  }

  //Sort attributes lexicographically
  // overrides undefined WebGL behavior for attribute locations
  attributes = attributes.slice();
  attributes.sort(compareAttributes

  //Convert attribute types, read out locations
  );var attributeUnpacked = [];
  var attributeNames = [];
  var attributeLocations = [];
  var i;
  for (i = 0; i < attributes.length; ++i) {
    var attr = attributes[i];
    if (attr.type.indexOf('mat') >= 0) {
      var size = attr.type.charAt(attr.type.length - 1) | 0;
      var locVector = new Array(size);
      for (var j = 0; j < size; ++j) {
        locVector[j] = attributeLocations.length;
        attributeNames.push(attr.name + '[' + j + ']');
        if (typeof attr.location === 'number') {
          attributeLocations.push(attr.location + j);
        } else if (Array.isArray(attr.location) && attr.location.length === size && typeof attr.location[j] === 'number') {
          attributeLocations.push(attr.location[j] | 0);
        } else {
          attributeLocations.push(-1);
        }
      }
      attributeUnpacked.push({
        name: attr.name,
        type: attr.type,
        locations: locVector
      });
    } else {
      attributeUnpacked.push({
        name: attr.name,
        type: attr.type,
        locations: [attributeLocations.length]
      });
      attributeNames.push(attr.name);
      if (typeof attr.location === 'number') {
        attributeLocations.push(attr.location | 0);
      } else {
        attributeLocations.push(-1);
      }
    }
  }

  //For all unspecified attributes, assign them lexicographically min attribute
  var curLocation = 0;
  for (i = 0; i < attributeLocations.length; ++i) {
    if (attributeLocations[i] < 0) {
      while (attributeLocations.indexOf(curLocation) >= 0) {
        curLocation += 1;
      }
      attributeLocations[i] = curLocation;
    }
  }

  //Rebuild program and recompute all uniform locations
  var uniformLocations = new Array(uniforms.length);
  function relink() {
    wrapper.program = shaderCache.program(gl, wrapper._vref, wrapper._fref, attributeNames, attributeLocations);

    for (var i = 0; i < uniforms.length; ++i) {
      uniformLocations[i] = gl.getUniformLocation(wrapper.program, uniforms[i].name);
    }
  }

  //Perform initial linking, reuse program used for reflection
  relink

  //Save relinking procedure, defer until runtime
  ();wrapper._relink = relink;

  //Generate type info
  wrapper.types = {
    uniforms: makeReflect(uniforms),
    attributes: makeReflect(attributes)

    //Generate attribute wrappers
  };wrapper.attributes = createAttributeWrapper(gl, wrapper, attributeUnpacked, attributeLocations

  //Generate uniform wrappers
  );Object.defineProperty(wrapper, 'uniforms', createUniformWrapper(gl, wrapper, uniforms, uniformLocations));
};

//Compiles and links a shader program with the given attribute and vertex list
function createShader(gl, vertSource, fragSource, uniforms, attributes) {

  var shader = new Shader(gl);

  shader.update(vertSource, fragSource, uniforms, attributes);

  return shader;
}

module.exports = createShader;

},{"./lib/GLError":85,"./lib/create-attributes":86,"./lib/create-uniforms":87,"./lib/reflect":88,"./lib/runtime-reflect":89,"./lib/shader-cache":90}],85:[function(require,module,exports){
function GLError(rawError, shortMessage, longMessage) {
    this.shortMessage = shortMessage || '';
    this.longMessage = longMessage || '';
    this.rawError = rawError || '';
    this.message = 'gl-shader: ' + (shortMessage || rawError || '') + (longMessage ? '\n' + longMessage : '');
    this.stack = new Error().stack;
}
GLError.prototype = new Error();
GLError.prototype.name = 'GLError';
GLError.prototype.constructor = GLError;
module.exports = GLError;

},{}],86:[function(require,module,exports){
'use strict';

module.exports = createAttributeWrapper;

var GLError = require("./GLError");

function ShaderAttribute(gl, wrapper, index, locations, dimension, constFunc) {
  this._gl = gl;
  this._wrapper = wrapper;
  this._index = index;
  this._locations = locations;
  this._dimension = dimension;
  this._constFunc = constFunc;
}

var proto = ShaderAttribute.prototype;

proto.pointer = function setAttribPointer(type, normalized, stride, offset) {

  var self = this;
  var gl = self._gl;
  var location = self._locations[self._index];

  gl.vertexAttribPointer(location, self._dimension, type || gl.FLOAT, !!normalized, stride || 0, offset || 0);
  gl.enableVertexAttribArray(location);
};

proto.set = function (x0, x1, x2, x3) {
  return this._constFunc(this._locations[this._index], x0, x1, x2, x3);
};

Object.defineProperty(proto, 'location', {
  get: function () {
    return this._locations[this._index];
  },
  set: function (v) {
    if (v !== this._locations[this._index]) {
      this._locations[this._index] = v | 0;
      this._wrapper.program = null;
    }
    return v | 0;
  }
}

//Adds a vector attribute to obj
);function addVectorAttribute(gl, wrapper, index, locations, dimension, obj, name) {

  //Construct constant function
  var constFuncArgs = ['gl', 'v'];
  var varNames = [];
  for (var i = 0; i < dimension; ++i) {
    constFuncArgs.push('x' + i);
    varNames.push('x' + i);
  }
  constFuncArgs.push('if(x0.length===void 0){return gl.vertexAttrib' + dimension + 'f(v,' + varNames.join() + ')}else{return gl.vertexAttrib' + dimension + 'fv(v,x0)}');
  var constFunc = Function.apply(null, constFuncArgs

  //Create attribute wrapper
  );var attr = new ShaderAttribute(gl, wrapper, index, locations, dimension, constFunc);

  //Create accessor
  Object.defineProperty(obj, name, {
    set: function (x) {
      gl.disableVertexAttribArray(locations[index]);
      constFunc(gl, locations[index], x);
      return x;
    },
    get: function () {
      return attr;
    },
    enumerable: true
  });
}

function addMatrixAttribute(gl, wrapper, index, locations, dimension, obj, name) {

  var parts = new Array(dimension);
  var attrs = new Array(dimension);
  for (var i = 0; i < dimension; ++i) {
    addVectorAttribute(gl, wrapper, index[i], locations, dimension, parts, i);
    attrs[i] = parts[i];
  }

  Object.defineProperty(parts, 'location', {
    set: function (v) {
      if (Array.isArray(v)) {
        for (var i = 0; i < dimension; ++i) {
          attrs[i].location = v[i];
        }
      } else {
        for (var i = 0; i < dimension; ++i) {
          attrs[i].location = v + i;
        }
      }
      return v;
    },
    get: function () {
      var result = new Array(dimension);
      for (var i = 0; i < dimension; ++i) {
        result[i] = locations[index[i]];
      }
      return result;
    },
    enumerable: true
  });

  parts.pointer = function (type, normalized, stride, offset) {
    type = type || gl.FLOAT;
    normalized = !!normalized;
    stride = stride || dimension * dimension;
    offset = offset || 0;
    for (var i = 0; i < dimension; ++i) {
      var location = locations[index[i]];
      gl.vertexAttribPointer(location, dimension, type, normalized, stride, offset + i * dimension);
      gl.enableVertexAttribArray(location);
    }
  };

  var scratch = new Array(dimension);
  var vertexAttrib = gl['vertexAttrib' + dimension + 'fv'];

  Object.defineProperty(obj, name, {
    set: function (x) {
      for (var i = 0; i < dimension; ++i) {
        var loc = locations[index[i]];
        gl.disableVertexAttribArray(loc);
        if (Array.isArray(x[0])) {
          vertexAttrib.call(gl, loc, x[i]);
        } else {
          for (var j = 0; j < dimension; ++j) {
            scratch[j] = x[dimension * i + j];
          }
          vertexAttrib.call(gl, loc, scratch);
        }
      }
      return x;
    },
    get: function () {
      return parts;
    },
    enumerable: true
  });
}

//Create shims for attributes
function createAttributeWrapper(gl, wrapper, attributes, locations) {

  var obj = {};
  for (var i = 0, n = attributes.length; i < n; ++i) {

    var a = attributes[i];
    var name = a.name;
    var type = a.type;
    var locs = a.locations;

    switch (type) {
      case 'bool':
      case 'int':
      case 'float':
        addVectorAttribute(gl, wrapper, locs[0], locations, 1, obj, name);
        break;

      default:
        if (type.indexOf('vec') >= 0) {
          var d = type.charCodeAt(type.length - 1) - 48;
          if (d < 2 || d > 4) {
            throw new GLError('', 'Invalid data type for attribute ' + name + ': ' + type);
          }
          addVectorAttribute(gl, wrapper, locs[0], locations, d, obj, name);
        } else if (type.indexOf('mat') >= 0) {
          var d = type.charCodeAt(type.length - 1) - 48;
          if (d < 2 || d > 4) {
            throw new GLError('', 'Invalid data type for attribute ' + name + ': ' + type);
          }
          addMatrixAttribute(gl, wrapper, locs, locations, d, obj, name);
        } else {
          throw new GLError('', 'Unknown data type for attribute ' + name + ': ' + type);
        }
        break;
    }
  }
  return obj;
}

},{"./GLError":85}],87:[function(require,module,exports){
'use strict';

var coallesceUniforms = require('./reflect');
var GLError = require("./GLError");

module.exports = createUniformWrapper;

//Binds a function and returns a value
function identity(x) {
  var c = new Function('y', 'return function(){return y}');
  return c(x);
}

function makeVector(length, fill) {
  var result = new Array(length);
  for (var i = 0; i < length; ++i) {
    result[i] = fill;
  }
  return result;
}

//Create shims for uniforms
function createUniformWrapper(gl, wrapper, uniforms, locations) {

  function makeGetter(index) {
    var proc = new Function('gl', 'wrapper', 'locations', 'return function(){return gl.getUniform(wrapper.program,locations[' + index + '])}');
    return proc(gl, wrapper, locations);
  }

  function makePropSetter(path, index, type) {
    switch (type) {
      case 'bool':
      case 'int':
      case 'sampler2D':
      case 'samplerCube':
        return 'gl.uniform1i(locations[' + index + '],obj' + path + ')';
      case 'float':
        return 'gl.uniform1f(locations[' + index + '],obj' + path + ')';
      default:
        var vidx = type.indexOf('vec');
        if (0 <= vidx && vidx <= 1 && type.length === 4 + vidx) {
          var d = type.charCodeAt(type.length - 1) - 48;
          if (d < 2 || d > 4) {
            throw new GLError('', 'Invalid data type');
          }
          switch (type.charAt(0)) {
            case 'b':
            case 'i':
              return 'gl.uniform' + d + 'iv(locations[' + index + '],obj' + path + ')';
            case 'v':
              return 'gl.uniform' + d + 'fv(locations[' + index + '],obj' + path + ')';
            default:
              throw new GLError('', 'Unrecognized data type for vector ' + name + ': ' + type);
          }
        } else if (type.indexOf('mat') === 0 && type.length === 4) {
          var d = type.charCodeAt(type.length - 1) - 48;
          if (d < 2 || d > 4) {
            throw new GLError('', 'Invalid uniform dimension type for matrix ' + name + ': ' + type);
          }
          return 'gl.uniformMatrix' + d + 'fv(locations[' + index + '],false,obj' + path + ')';
        } else {
          throw new GLError('', 'Unknown uniform data type for ' + name + ': ' + type);
        }
        break;
    }
  }

  function enumerateIndices(prefix, type) {
    if (typeof type !== 'object') {
      return [[prefix, type]];
    }
    var indices = [];
    for (var id in type) {
      var prop = type[id];
      var tprefix = prefix;
      if (parseInt(id) + '' === id) {
        tprefix += '[' + id + ']';
      } else {
        tprefix += '.' + id;
      }
      if (typeof prop === 'object') {
        indices.push.apply(indices, enumerateIndices(tprefix, prop));
      } else {
        indices.push([tprefix, prop]);
      }
    }
    return indices;
  }

  function makeSetter(type) {
    var code = ['return function updateProperty(obj){'];
    var indices = enumerateIndices('', type);
    for (var i = 0; i < indices.length; ++i) {
      var item = indices[i];
      var path = item[0];
      var idx = item[1];
      if (locations[idx]) {
        code.push(makePropSetter(path, idx, uniforms[idx].type));
      }
    }
    code.push('return obj}');
    var proc = new Function('gl', 'locations', code.join('\n'));
    return proc(gl, locations);
  }

  function defaultValue(type) {
    switch (type) {
      case 'bool':
        return false;
      case 'int':
      case 'sampler2D':
      case 'samplerCube':
        return 0;
      case 'float':
        return 0.0;
      default:
        var vidx = type.indexOf('vec');
        if (0 <= vidx && vidx <= 1 && type.length === 4 + vidx) {
          var d = type.charCodeAt(type.length - 1) - 48;
          if (d < 2 || d > 4) {
            throw new GLError('', 'Invalid data type');
          }
          if (type.charAt(0) === 'b') {
            return makeVector(d, false);
          }
          return makeVector(d, 0);
        } else if (type.indexOf('mat') === 0 && type.length === 4) {
          var d = type.charCodeAt(type.length - 1) - 48;
          if (d < 2 || d > 4) {
            throw new GLError('', 'Invalid uniform dimension type for matrix ' + name + ': ' + type);
          }
          return makeVector(d * d, 0);
        } else {
          throw new GLError('', 'Unknown uniform data type for ' + name + ': ' + type);
        }
        break;
    }
  }

  function storeProperty(obj, prop, type) {
    if (typeof type === 'object') {
      var child = processObject(type);
      Object.defineProperty(obj, prop, {
        get: identity(child),
        set: makeSetter(type),
        enumerable: true,
        configurable: false
      });
    } else {
      if (locations[type]) {
        Object.defineProperty(obj, prop, {
          get: makeGetter(type),
          set: makeSetter(type),
          enumerable: true,
          configurable: false
        });
      } else {
        obj[prop] = defaultValue(uniforms[type].type);
      }
    }
  }

  function processObject(obj) {
    var result;
    if (Array.isArray(obj)) {
      result = new Array(obj.length);
      for (var i = 0; i < obj.length; ++i) {
        storeProperty(result, i, obj[i]);
      }
    } else {
      result = {};
      for (var id in obj) {
        storeProperty(result, id, obj[id]);
      }
    }
    return result;
  }

  //Return data
  var coallesced = coallesceUniforms(uniforms, true);
  return {
    get: identity(processObject(coallesced)),
    set: makeSetter(coallesced),
    enumerable: true,
    configurable: true
  };
}

},{"./GLError":85,"./reflect":88}],88:[function(require,module,exports){
'use strict';

module.exports = makeReflectTypes;

//Construct type info for reflection.
//
// This iterates over the flattened list of uniform type values and smashes them into a JSON object.
//
// The leaves of the resulting object are either indices or type strings representing primitive glslify types
function makeReflectTypes(uniforms, useIndex) {
  var obj = {};
  for (var i = 0; i < uniforms.length; ++i) {
    var n = uniforms[i].name;
    var parts = n.split(".");
    var o = obj;
    for (var j = 0; j < parts.length; ++j) {
      var x = parts[j].split("[");
      if (x.length > 1) {
        if (!(x[0] in o)) {
          o[x[0]] = [];
        }
        o = o[x[0]];
        for (var k = 1; k < x.length; ++k) {
          var y = parseInt(x[k]);
          if (k < x.length - 1 || j < parts.length - 1) {
            if (!(y in o)) {
              if (k < x.length - 1) {
                o[y] = [];
              } else {
                o[y] = {};
              }
            }
            o = o[y];
          } else {
            if (useIndex) {
              o[y] = i;
            } else {
              o[y] = uniforms[i].type;
            }
          }
        }
      } else if (j < parts.length - 1) {
        if (!(x[0] in o)) {
          o[x[0]] = {};
        }
        o = o[x[0]];
      } else {
        if (useIndex) {
          o[x[0]] = i;
        } else {
          o[x[0]] = uniforms[i].type;
        }
      }
    }
  }
  return obj;
}

},{}],89:[function(require,module,exports){
'use strict';

exports.uniforms = runtimeUniforms;
exports.attributes = runtimeAttributes;

var GL_TO_GLSL_TYPES = {
  'FLOAT': 'float',
  'FLOAT_VEC2': 'vec2',
  'FLOAT_VEC3': 'vec3',
  'FLOAT_VEC4': 'vec4',
  'INT': 'int',
  'INT_VEC2': 'ivec2',
  'INT_VEC3': 'ivec3',
  'INT_VEC4': 'ivec4',
  'BOOL': 'bool',
  'BOOL_VEC2': 'bvec2',
  'BOOL_VEC3': 'bvec3',
  'BOOL_VEC4': 'bvec4',
  'FLOAT_MAT2': 'mat2',
  'FLOAT_MAT3': 'mat3',
  'FLOAT_MAT4': 'mat4',
  'SAMPLER_2D': 'sampler2D',
  'SAMPLER_CUBE': 'samplerCube'
};

var GL_TABLE = null;

function getType(gl, type) {
  if (!GL_TABLE) {
    var typeNames = Object.keys(GL_TO_GLSL_TYPES);
    GL_TABLE = {};
    for (var i = 0; i < typeNames.length; ++i) {
      var tn = typeNames[i];
      GL_TABLE[gl[tn]] = GL_TO_GLSL_TYPES[tn];
    }
  }
  return GL_TABLE[type];
}

function runtimeUniforms(gl, program) {
  var numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
  var result = [];
  for (var i = 0; i < numUniforms; ++i) {
    var info = gl.getActiveUniform(program, i);
    if (info) {
      var type = getType(gl, info.type);
      if (info.size > 1) {
        for (var j = 0; j < info.size; ++j) {
          result.push({
            name: info.name.replace('[0]', '[' + j + ']'),
            type: type
          });
        }
      } else {
        result.push({
          name: info.name,
          type: type
        });
      }
    }
  }
  return result;
}

function runtimeAttributes(gl, program) {
  var numAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
  var result = [];
  for (var i = 0; i < numAttributes; ++i) {
    var info = gl.getActiveAttrib(program, i);
    if (info) {
      result.push({
        name: info.name,
        type: getType(gl, info.type)
      });
    }
  }
  return result;
}

},{}],90:[function(require,module,exports){
'use strict';

exports.shader = getShaderReference;
exports.program = createProgram;

var GLError = require("./GLError");
var formatCompilerError = require('gl-format-compiler-error');

var weakMap = typeof WeakMap === 'undefined' ? require('weakmap-shim') : WeakMap;
var CACHE = new weakMap();

var SHADER_COUNTER = 0;

function ShaderReference(id, src, type, shader, programs, count, cache) {
  this.id = id;
  this.src = src;
  this.type = type;
  this.shader = shader;
  this.count = count;
  this.programs = [];
  this.cache = cache;
}

ShaderReference.prototype.dispose = function () {
  if (--this.count === 0) {
    var cache = this.cache;
    var gl = cache.gl;

    //Remove program references
    var programs = this.programs;
    for (var i = 0, n = programs.length; i < n; ++i) {
      var p = cache.programs[programs[i]];
      if (p) {
        delete cache.programs[i];
        gl.deleteProgram(p);
      }
    }

    //Remove shader reference
    gl.deleteShader(this.shader);
    delete cache.shaders[this.type === gl.FRAGMENT_SHADER | 0][this.src];
  }
};

function ContextCache(gl) {
  this.gl = gl;
  this.shaders = [{}, {}];
  this.programs = {};
}

var proto = ContextCache.prototype;

function compileShader(gl, type, src) {
  var shader = gl.createShader(type);
  gl.shaderSource(shader, src);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    var errLog = gl.getShaderInfoLog(shader);
    try {
      var fmt = formatCompilerError(errLog, src, type);
    } catch (e) {
      console.warn('Failed to format compiler error: ' + e);
      throw new GLError(errLog, 'Error compiling shader:\n' + errLog);
    }
    throw new GLError(errLog, fmt.short, fmt.long);
  }
  return shader;
}

proto.getShaderReference = function (type, src) {
  var gl = this.gl;
  var shaders = this.shaders[type === gl.FRAGMENT_SHADER | 0];
  var shader = shaders[src];
  if (!shader || !gl.isShader(shader.shader)) {
    var shaderObj = compileShader(gl, type, src);
    shader = shaders[src] = new ShaderReference(SHADER_COUNTER++, src, type, shaderObj, [], 1, this);
  } else {
    shader.count += 1;
  }
  return shader;
};

function linkProgram(gl, vshader, fshader, attribs, locations) {
  var program = gl.createProgram();
  gl.attachShader(program, vshader);
  gl.attachShader(program, fshader);
  for (var i = 0; i < attribs.length; ++i) {
    gl.bindAttribLocation(program, locations[i], attribs[i]);
  }
  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    var errLog = gl.getProgramInfoLog(program);
    throw new GLError(errLog, 'Error linking program: ' + errLog);
  }
  return program;
}

proto.getProgram = function (vref, fref, attribs, locations) {
  var token = [vref.id, fref.id, attribs.join(':'), locations.join(':')].join('@');
  var prog = this.programs[token];
  if (!prog || !this.gl.isProgram(prog)) {
    this.programs[token] = prog = linkProgram(this.gl, vref.shader, fref.shader, attribs, locations);
    vref.programs.push(token);
    fref.programs.push(token);
  }
  return prog;
};

function getCache(gl) {
  var ctxCache = CACHE.get(gl);
  if (!ctxCache) {
    ctxCache = new ContextCache(gl);
    CACHE.set(gl, ctxCache);
  }
  return ctxCache;
}

function getShaderReference(gl, type, src) {
  return getCache(gl).getShaderReference(type, src);
}

function createProgram(gl, vref, fref, attribs, locations) {
  return getCache(gl).getProgram(vref, fref, attribs, locations);
}

},{"./GLError":85,"gl-format-compiler-error":74,"weakmap-shim":169}],91:[function(require,module,exports){
'use strict';

module.exports = createSpikes2D;

function GLSpikes2D(plot) {
  this.plot = plot;
  this.enable = [true, true, false, false];
  this.width = [1, 1, 1, 1];
  this.color = [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]];
  this.center = [Infinity, Infinity];
}

var proto = GLSpikes2D.prototype;

proto.update = function (options) {
  options = options || {};
  this.enable = (options.enable || [true, true, false, false]).slice();
  this.width = (options.width || [1, 1, 1, 1]).slice();
  this.color = (options.color || [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]]).map(function (x) {
    return x.slice();
  });
  this.center = (options.center || [Infinity, Infinity]).slice();
  this.plot.setOverlayDirty();
};

proto.draw = function () {
  var spikeEnable = this.enable;
  var spikeWidth = this.width;
  var spikeColor = this.color;
  var spikeCenter = this.center;
  var plot = this.plot;
  var line = plot.line;

  var dataBox = plot.dataBox;
  var viewPixels = plot.viewBox;

  line.bind();

  if (dataBox[0] <= spikeCenter[0] && spikeCenter[0] <= dataBox[2] && dataBox[1] <= spikeCenter[1] && spikeCenter[1] <= dataBox[3]) {

    var centerX = viewPixels[0] + (spikeCenter[0] - dataBox[0]) / (dataBox[2] - dataBox[0]) * (viewPixels[2] - viewPixels[0]);
    var centerY = viewPixels[1] + (spikeCenter[1] - dataBox[1]) / (dataBox[3] - dataBox[1]) * (viewPixels[3] - viewPixels[1]);

    if (spikeEnable[0]) {
      line.drawLine(centerX, centerY, viewPixels[0], centerY, spikeWidth[0], spikeColor[0]);
    }
    if (spikeEnable[1]) {
      line.drawLine(centerX, centerY, centerX, viewPixels[1], spikeWidth[1], spikeColor[1]);
    }
    if (spikeEnable[2]) {
      line.drawLine(centerX, centerY, viewPixels[2], centerY, spikeWidth[2], spikeColor[2]);
    }
    if (spikeEnable[3]) {
      line.drawLine(centerX, centerY, centerX, viewPixels[3], spikeWidth[3], spikeColor[3]);
    }
  }
};

proto.dispose = function () {
  this.plot.removeOverlay(this);
};

function createSpikes2D(plot, options) {
  var spikes = new GLSpikes2D(plot);
  spikes.update(options);
  plot.addOverlay(spikes);
  return spikes;
}

},{}],92:[function(require,module,exports){
'use strict';

var ndarray = require('ndarray');
var ops = require('ndarray-ops');
var pool = require('typedarray-pool');

module.exports = createTexture2D;

var linearTypes = null;
var filterTypes = null;
var wrapTypes = null;

function lazyInitLinearTypes(gl) {
  linearTypes = [gl.LINEAR, gl.NEAREST_MIPMAP_LINEAR, gl.LINEAR_MIPMAP_NEAREST, gl.LINEAR_MIPMAP_NEAREST];
  filterTypes = [gl.NEAREST, gl.LINEAR, gl.NEAREST_MIPMAP_NEAREST, gl.NEAREST_MIPMAP_LINEAR, gl.LINEAR_MIPMAP_NEAREST, gl.LINEAR_MIPMAP_LINEAR];
  wrapTypes = [gl.REPEAT, gl.CLAMP_TO_EDGE, gl.MIRRORED_REPEAT];
}

function acceptTextureDOM(obj) {
  return 'undefined' != typeof HTMLCanvasElement && obj instanceof HTMLCanvasElement || 'undefined' != typeof HTMLImageElement && obj instanceof HTMLImageElement || 'undefined' != typeof HTMLVideoElement && obj instanceof HTMLVideoElement || 'undefined' != typeof ImageData && obj instanceof ImageData;
}

var convertFloatToUint8 = function (out, inp) {
  ops.muls(out, inp, 255.0);
};

function reshapeTexture(tex, w, h) {
  var gl = tex.gl;
  var maxSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
  if (w < 0 || w > maxSize || h < 0 || h > maxSize) {
    throw new Error('gl-texture2d: Invalid texture size');
  }
  tex._shape = [w, h];
  tex.bind();
  gl.texImage2D(gl.TEXTURE_2D, 0, tex.format, w, h, 0, tex.format, tex.type, null);
  tex._mipLevels = [0];
  return tex;
}

function Texture2D(gl, handle, width, height, format, type) {
  this.gl = gl;
  this.handle = handle;
  this.format = format;
  this.type = type;
  this._shape = [width, height];
  this._mipLevels = [0];
  this._magFilter = gl.NEAREST;
  this._minFilter = gl.NEAREST;
  this._wrapS = gl.CLAMP_TO_EDGE;
  this._wrapT = gl.CLAMP_TO_EDGE;
  this._anisoSamples = 1;

  var parent = this;
  var wrapVector = [this._wrapS, this._wrapT];
  Object.defineProperties(wrapVector, [{
    get: function () {
      return parent._wrapS;
    },
    set: function (v) {
      return parent.wrapS = v;
    }
  }, {
    get: function () {
      return parent._wrapT;
    },
    set: function (v) {
      return parent.wrapT = v;
    }
  }]);
  this._wrapVector = wrapVector;

  var shapeVector = [this._shape[0], this._shape[1]];
  Object.defineProperties(shapeVector, [{
    get: function () {
      return parent._shape[0];
    },
    set: function (v) {
      return parent.width = v;
    }
  }, {
    get: function () {
      return parent._shape[1];
    },
    set: function (v) {
      return parent.height = v;
    }
  }]);
  this._shapeVector = shapeVector;
}

var proto = Texture2D.prototype;

Object.defineProperties(proto, {
  minFilter: {
    get: function () {
      return this._minFilter;
    },
    set: function (v) {
      this.bind();
      var gl = this.gl;
      if (this.type === gl.FLOAT && linearTypes.indexOf(v) >= 0) {
        if (!gl.getExtension('OES_texture_float_linear')) {
          v = gl.NEAREST;
        }
      }
      if (filterTypes.indexOf(v) < 0) {
        throw new Error('gl-texture2d: Unknown filter mode ' + v);
      }
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, v);
      return this._minFilter = v;
    }
  },
  magFilter: {
    get: function () {
      return this._magFilter;
    },
    set: function (v) {
      this.bind();
      var gl = this.gl;
      if (this.type === gl.FLOAT && linearTypes.indexOf(v) >= 0) {
        if (!gl.getExtension('OES_texture_float_linear')) {
          v = gl.NEAREST;
        }
      }
      if (filterTypes.indexOf(v) < 0) {
        throw new Error('gl-texture2d: Unknown filter mode ' + v);
      }
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, v);
      return this._magFilter = v;
    }
  },
  mipSamples: {
    get: function () {
      return this._anisoSamples;
    },
    set: function (i) {
      var psamples = this._anisoSamples;
      this._anisoSamples = Math.max(i, 1) | 0;
      if (psamples !== this._anisoSamples) {
        var ext = this.gl.getExtension('EXT_texture_filter_anisotropic');
        if (ext) {
          this.gl.texParameterf(this.gl.TEXTURE_2D, ext.TEXTURE_MAX_ANISOTROPY_EXT, this._anisoSamples);
        }
      }
      return this._anisoSamples;
    }
  },
  wrapS: {
    get: function () {
      return this._wrapS;
    },
    set: function (v) {
      this.bind();
      if (wrapTypes.indexOf(v) < 0) {
        throw new Error('gl-texture2d: Unknown wrap mode ' + v);
      }
      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, v);
      return this._wrapS = v;
    }
  },
  wrapT: {
    get: function () {
      return this._wrapT;
    },
    set: function (v) {
      this.bind();
      if (wrapTypes.indexOf(v) < 0) {
        throw new Error('gl-texture2d: Unknown wrap mode ' + v);
      }
      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, v);
      return this._wrapT = v;
    }
  },
  wrap: {
    get: function () {
      return this._wrapVector;
    },
    set: function (v) {
      if (!Array.isArray(v)) {
        v = [v, v];
      }
      if (v.length !== 2) {
        throw new Error('gl-texture2d: Must specify wrap mode for rows and columns');
      }
      for (var i = 0; i < 2; ++i) {
        if (wrapTypes.indexOf(v[i]) < 0) {
          throw new Error('gl-texture2d: Unknown wrap mode ' + v);
        }
      }
      this._wrapS = v[0];
      this._wrapT = v[1];

      var gl = this.gl;
      this.bind();
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, this._wrapS);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, this._wrapT);

      return v;
    }
  },
  shape: {
    get: function () {
      return this._shapeVector;
    },
    set: function (x) {
      if (!Array.isArray(x)) {
        x = [x | 0, x | 0];
      } else {
        if (x.length !== 2) {
          throw new Error('gl-texture2d: Invalid texture shape');
        }
      }
      reshapeTexture(this, x[0] | 0, x[1] | 0);
      return [x[0] | 0, x[1] | 0];
    }
  },
  width: {
    get: function () {
      return this._shape[0];
    },
    set: function (w) {
      w = w | 0;
      reshapeTexture(this, w, this._shape[1]);
      return w;
    }
  },
  height: {
    get: function () {
      return this._shape[1];
    },
    set: function (h) {
      h = h | 0;
      reshapeTexture(this, this._shape[0], h);
      return h;
    }
  }
});

proto.bind = function (unit) {
  var gl = this.gl;
  if (unit !== undefined) {
    gl.activeTexture(gl.TEXTURE0 + (unit | 0));
  }
  gl.bindTexture(gl.TEXTURE_2D, this.handle);
  if (unit !== undefined) {
    return unit | 0;
  }
  return gl.getParameter(gl.ACTIVE_TEXTURE) - gl.TEXTURE0;
};

proto.dispose = function () {
  this.gl.deleteTexture(this.handle);
};

proto.generateMipmap = function () {
  this.bind();
  this.gl.generateMipmap(this.gl.TEXTURE_2D

  //Update mip levels
  );var l = Math.min(this._shape[0], this._shape[1]);
  for (var i = 0; l > 0; ++i, l >>>= 1) {
    if (this._mipLevels.indexOf(i) < 0) {
      this._mipLevels.push(i);
    }
  }
};

proto.setPixels = function (data, x_off, y_off, mip_level) {
  var gl = this.gl;
  this.bind();
  if (Array.isArray(x_off)) {
    mip_level = y_off;
    y_off = x_off[1] | 0;
    x_off = x_off[0] | 0;
  } else {
    x_off = x_off || 0;
    y_off = y_off || 0;
  }
  mip_level = mip_level || 0;
  var directData = acceptTextureDOM(data) ? data : data.raw;
  if (directData) {
    var needsMip = this._mipLevels.indexOf(mip_level) < 0;
    if (needsMip) {
      gl.texImage2D(gl.TEXTURE_2D, 0, this.format, this.format, this.type, directData);
      this._mipLevels.push(mip_level);
    } else {
      gl.texSubImage2D(gl.TEXTURE_2D, mip_level, x_off, y_off, this.format, this.type, directData);
    }
  } else if (data.shape && data.stride && data.data) {
    if (data.shape.length < 2 || x_off + data.shape[1] > this._shape[1] >>> mip_level || y_off + data.shape[0] > this._shape[0] >>> mip_level || x_off < 0 || y_off < 0) {
      throw new Error('gl-texture2d: Texture dimensions are out of bounds');
    }
    texSubImageArray(gl, x_off, y_off, mip_level, this.format, this.type, this._mipLevels, data);
  } else {
    throw new Error('gl-texture2d: Unsupported data type');
  }
};

function isPacked(shape, stride) {
  if (shape.length === 3) {
    return stride[2] === 1 && stride[1] === shape[0] * shape[2] && stride[0] === shape[2];
  }
  return stride[0] === 1 && stride[1] === shape[0];
}

function texSubImageArray(gl, x_off, y_off, mip_level, cformat, ctype, mipLevels, array) {
  var dtype = array.dtype;
  var shape = array.shape.slice();
  if (shape.length < 2 || shape.length > 3) {
    throw new Error('gl-texture2d: Invalid ndarray, must be 2d or 3d');
  }
  var type = 0,
      format = 0;
  var packed = isPacked(shape, array.stride.slice());
  if (dtype === 'float32') {
    type = gl.FLOAT;
  } else if (dtype === 'float64') {
    type = gl.FLOAT;
    packed = false;
    dtype = 'float32';
  } else if (dtype === 'uint8') {
    type = gl.UNSIGNED_BYTE;
  } else {
    type = gl.UNSIGNED_BYTE;
    packed = false;
    dtype = 'uint8';
  }
  var channels = 1;
  if (shape.length === 2) {
    format = gl.LUMINANCE;
    shape = [shape[0], shape[1], 1];
    array = ndarray(array.data, shape, [array.stride[0], array.stride[1], 1], array.offset);
  } else if (shape.length === 3) {
    if (shape[2] === 1) {
      format = gl.ALPHA;
    } else if (shape[2] === 2) {
      format = gl.LUMINANCE_ALPHA;
    } else if (shape[2] === 3) {
      format = gl.RGB;
    } else if (shape[2] === 4) {
      format = gl.RGBA;
    } else {
      throw new Error('gl-texture2d: Invalid shape for pixel coords');
    }
    channels = shape[2];
  } else {
    throw new Error('gl-texture2d: Invalid shape for texture');
  }
  //For 1-channel textures allow conversion between formats
  if ((format === gl.LUMINANCE || format === gl.ALPHA) && (cformat === gl.LUMINANCE || cformat === gl.ALPHA)) {
    format = cformat;
  }
  if (format !== cformat) {
    throw new Error('gl-texture2d: Incompatible texture format for setPixels');
  }
  var size = array.size;
  var needsMip = mipLevels.indexOf(mip_level) < 0;
  if (needsMip) {
    mipLevels.push(mip_level);
  }
  if (type === ctype && packed) {
    //Array data types are compatible, can directly copy into texture
    if (array.offset === 0 && array.data.length === size) {
      if (needsMip) {
        gl.texImage2D(gl.TEXTURE_2D, mip_level, cformat, shape[0], shape[1], 0, cformat, ctype, array.data);
      } else {
        gl.texSubImage2D(gl.TEXTURE_2D, mip_level, x_off, y_off, shape[0], shape[1], cformat, ctype, array.data);
      }
    } else {
      if (needsMip) {
        gl.texImage2D(gl.TEXTURE_2D, mip_level, cformat, shape[0], shape[1], 0, cformat, ctype, array.data.subarray(array.offset, array.offset + size));
      } else {
        gl.texSubImage2D(gl.TEXTURE_2D, mip_level, x_off, y_off, shape[0], shape[1], cformat, ctype, array.data.subarray(array.offset, array.offset + size));
      }
    }
  } else {
    //Need to do type conversion to pack data into buffer
    var pack_buffer;
    if (ctype === gl.FLOAT) {
      pack_buffer = pool.mallocFloat32(size);
    } else {
      pack_buffer = pool.mallocUint8(size);
    }
    var pack_view = ndarray(pack_buffer, shape, [shape[2], shape[2] * shape[0], 1]);
    if (type === gl.FLOAT && ctype === gl.UNSIGNED_BYTE) {
      convertFloatToUint8(pack_view, array);
    } else {
      ops.assign(pack_view, array);
    }
    if (needsMip) {
      gl.texImage2D(gl.TEXTURE_2D, mip_level, cformat, shape[0], shape[1], 0, cformat, ctype, pack_buffer.subarray(0, size));
    } else {
      gl.texSubImage2D(gl.TEXTURE_2D, mip_level, x_off, y_off, shape[0], shape[1], cformat, ctype, pack_buffer.subarray(0, size));
    }
    if (ctype === gl.FLOAT) {
      pool.freeFloat32(pack_buffer);
    } else {
      pool.freeUint8(pack_buffer);
    }
  }
}

function initTexture(gl) {
  var tex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  return tex;
}

function createTextureShape(gl, width, height, format, type) {
  var maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
  if (width < 0 || width > maxTextureSize || height < 0 || height > maxTextureSize) {
    throw new Error('gl-texture2d: Invalid texture shape');
  }
  if (type === gl.FLOAT && !gl.getExtension('OES_texture_float')) {
    throw new Error('gl-texture2d: Floating point textures not supported on this platform');
  }
  var tex = initTexture(gl);
  gl.texImage2D(gl.TEXTURE_2D, 0, format, width, height, 0, format, type, null);
  return new Texture2D(gl, tex, width, height, format, type);
}

function createTextureDOM(gl, directData, width, height, format, type) {
  var tex = initTexture(gl);
  gl.texImage2D(gl.TEXTURE_2D, 0, format, format, type, directData);
  return new Texture2D(gl, tex, width, height, format, type);
}

//Creates a texture from an ndarray
function createTextureArray(gl, array) {
  var dtype = array.dtype;
  var shape = array.shape.slice();
  var maxSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
  if (shape[0] < 0 || shape[0] > maxSize || shape[1] < 0 || shape[1] > maxSize) {
    throw new Error('gl-texture2d: Invalid texture size');
  }
  var packed = isPacked(shape, array.stride.slice());
  var type = 0;
  if (dtype === 'float32') {
    type = gl.FLOAT;
  } else if (dtype === 'float64') {
    type = gl.FLOAT;
    packed = false;
    dtype = 'float32';
  } else if (dtype === 'uint8') {
    type = gl.UNSIGNED_BYTE;
  } else {
    type = gl.UNSIGNED_BYTE;
    packed = false;
    dtype = 'uint8';
  }
  var format = 0;
  if (shape.length === 2) {
    format = gl.LUMINANCE;
    shape = [shape[0], shape[1], 1];
    array = ndarray(array.data, shape, [array.stride[0], array.stride[1], 1], array.offset);
  } else if (shape.length === 3) {
    if (shape[2] === 1) {
      format = gl.ALPHA;
    } else if (shape[2] === 2) {
      format = gl.LUMINANCE_ALPHA;
    } else if (shape[2] === 3) {
      format = gl.RGB;
    } else if (shape[2] === 4) {
      format = gl.RGBA;
    } else {
      throw new Error('gl-texture2d: Invalid shape for pixel coords');
    }
  } else {
    throw new Error('gl-texture2d: Invalid shape for texture');
  }
  if (type === gl.FLOAT && !gl.getExtension('OES_texture_float')) {
    type = gl.UNSIGNED_BYTE;
    packed = false;
  }
  var buffer, buf_store;
  var size = array.size;
  if (!packed) {
    var stride = [shape[2], shape[2] * shape[0], 1];
    buf_store = pool.malloc(size, dtype);
    var buf_array = ndarray(buf_store, shape, stride, 0);
    if ((dtype === 'float32' || dtype === 'float64') && type === gl.UNSIGNED_BYTE) {
      convertFloatToUint8(buf_array, array);
    } else {
      ops.assign(buf_array, array);
    }
    buffer = buf_store.subarray(0, size);
  } else if (array.offset === 0 && array.data.length === size) {
    buffer = array.data;
  } else {
    buffer = array.data.subarray(array.offset, array.offset + size);
  }
  var tex = initTexture(gl);
  gl.texImage2D(gl.TEXTURE_2D, 0, format, shape[0], shape[1], 0, format, type, buffer);
  if (!packed) {
    pool.free(buf_store);
  }
  return new Texture2D(gl, tex, shape[0], shape[1], format, type);
}

function createTexture2D(gl) {
  if (arguments.length <= 1) {
    throw new Error('gl-texture2d: Missing arguments for texture2d constructor');
  }
  if (!linearTypes) {
    lazyInitLinearTypes(gl);
  }
  if (typeof arguments[1] === 'number') {
    return createTextureShape(gl, arguments[1], arguments[2], arguments[3] || gl.RGBA, arguments[4] || gl.UNSIGNED_BYTE);
  }
  if (Array.isArray(arguments[1])) {
    return createTextureShape(gl, arguments[1][0] | 0, arguments[1][1] | 0, arguments[2] || gl.RGBA, arguments[3] || gl.UNSIGNED_BYTE);
  }
  if (typeof arguments[1] === 'object') {
    var obj = arguments[1];
    var directData = acceptTextureDOM(obj) ? obj : obj.raw;
    if (directData) {
      return createTextureDOM(gl, directData, obj.width | 0, obj.height | 0, arguments[2] || gl.RGBA, arguments[3] || gl.UNSIGNED_BYTE);
    } else if (obj.shape && obj.data && obj.stride) {
      return createTextureArray(gl, obj);
    }
  }
  throw new Error('gl-texture2d: Invalid arguments for texture2d constructor');
}

},{"ndarray":114,"ndarray-ops":113,"typedarray-pool":162}],93:[function(require,module,exports){
var tokenize = require('glsl-tokenizer');
var atob = require('atob-lite');

module.exports = getName;

function getName(src) {
  var tokens = Array.isArray(src) ? src : tokenize(src);

  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i];
    if (token.type !== 'preprocessor') continue;
    var match = token.data.match(/\#define\s+SHADER_NAME(_B64)?\s+(.+)$/);
    if (!match) continue;
    if (!match[2]) continue;

    var b64 = match[1];
    var name = match[2];

    return (b64 ? atob(name) : name).trim();
  }
}

},{"atob-lite":8,"glsl-tokenizer":100}],94:[function(require,module,exports){
module.exports = tokenize;

var literals100 = require('./lib/literals'),
    operators = require('./lib/operators'),
    builtins100 = require('./lib/builtins'),
    literals300es = require('./lib/literals-300es'),
    builtins300es = require('./lib/builtins-300es');

var NORMAL = 999 // <-- never emitted
,
    TOKEN = 9999 // <-- never emitted
,
    BLOCK_COMMENT = 0,
    LINE_COMMENT = 1,
    PREPROCESSOR = 2,
    OPERATOR = 3,
    INTEGER = 4,
    FLOAT = 5,
    IDENT = 6,
    BUILTIN = 7,
    KEYWORD = 8,
    WHITESPACE = 9,
    EOF = 10,
    HEX = 11;

var map = ['block-comment', 'line-comment', 'preprocessor', 'operator', 'integer', 'float', 'ident', 'builtin', 'keyword', 'whitespace', 'eof', 'integer'];

function tokenize(opt) {
  var i = 0,
      total = 0,
      mode = NORMAL,
      c,
      last,
      content = [],
      tokens = [],
      token_idx = 0,
      token_offs = 0,
      line = 1,
      col = 0,
      start = 0,
      isnum = false,
      isoperator = false,
      input = '',
      len;

  opt = opt || {};
  var allBuiltins = builtins100;
  var allLiterals = literals100;
  if (opt.version === '300 es') {
    allBuiltins = builtins300es;
    allLiterals = literals300es;
  }

  return function (data) {
    tokens = [];
    if (data !== null) return write(data.replace ? data.replace(/\r\n/g, '\n') : data);
    return end();
  };

  function token(data) {
    if (data.length) {
      tokens.push({
        type: map[mode],
        data: data,
        position: start,
        line: line,
        column: col
      });
    }
  }

  function write(chunk) {
    i = 0;
    input += chunk;
    len = input.length;

    var last;

    while (c = input[i], i < len) {
      last = i;

      switch (mode) {
        case BLOCK_COMMENT:
          i = block_comment();break;
        case LINE_COMMENT:
          i = line_comment();break;
        case PREPROCESSOR:
          i = preprocessor();break;
        case OPERATOR:
          i = operator();break;
        case INTEGER:
          i = integer();break;
        case HEX:
          i = hex();break;
        case FLOAT:
          i = decimal();break;
        case TOKEN:
          i = readtoken();break;
        case WHITESPACE:
          i = whitespace();break;
        case NORMAL:
          i = normal();break;
      }

      if (last !== i) {
        switch (input[last]) {
          case '\n':
            col = 0;++line;break;
          default:
            ++col;break;
        }
      }
    }

    total += i;
    input = input.slice(i);
    return tokens;
  }

  function end(chunk) {
    if (content.length) {
      token(content.join(''));
    }

    mode = EOF;
    token('(eof)');
    return tokens;
  }

  function normal() {
    content = content.length ? [] : content;

    if (last === '/' && c === '*') {
      start = total + i - 1;
      mode = BLOCK_COMMENT;
      last = c;
      return i + 1;
    }

    if (last === '/' && c === '/') {
      start = total + i - 1;
      mode = LINE_COMMENT;
      last = c;
      return i + 1;
    }

    if (c === '#') {
      mode = PREPROCESSOR;
      start = total + i;
      return i;
    }

    if (/\s/.test(c)) {
      mode = WHITESPACE;
      start = total + i;
      return i;
    }

    isnum = /\d/.test(c);
    isoperator = /[^\w_]/.test(c);

    start = total + i;
    mode = isnum ? INTEGER : isoperator ? OPERATOR : TOKEN;
    return i;
  }

  function whitespace() {
    if (/[^\s]/g.test(c)) {
      token(content.join(''));
      mode = NORMAL;
      return i;
    }
    content.push(c);
    last = c;
    return i + 1;
  }

  function preprocessor() {
    if ((c === '\r' || c === '\n') && last !== '\\') {
      token(content.join(''));
      mode = NORMAL;
      return i;
    }
    content.push(c);
    last = c;
    return i + 1;
  }

  function line_comment() {
    return preprocessor();
  }

  function block_comment() {
    if (c === '/' && last === '*') {
      content.push(c);
      token(content.join(''));
      mode = NORMAL;
      return i + 1;
    }

    content.push(c);
    last = c;
    return i + 1;
  }

  function operator() {
    if (last === '.' && /\d/.test(c)) {
      mode = FLOAT;
      return i;
    }

    if (last === '/' && c === '*') {
      mode = BLOCK_COMMENT;
      return i;
    }

    if (last === '/' && c === '/') {
      mode = LINE_COMMENT;
      return i;
    }

    if (c === '.' && content.length) {
      while (determine_operator(content));

      mode = FLOAT;
      return i;
    }

    if (c === ';' || c === ')' || c === '(') {
      if (content.length) while (determine_operator(content));
      token(c);
      mode = NORMAL;
      return i + 1;
    }

    var is_composite_operator = content.length === 2 && c !== '=';
    if (/[\w_\d\s]/.test(c) || is_composite_operator) {
      while (determine_operator(content));
      mode = NORMAL;
      return i;
    }

    content.push(c);
    last = c;
    return i + 1;
  }

  function determine_operator(buf) {
    var j = 0,
        idx,
        res;

    do {
      idx = operators.indexOf(buf.slice(0, buf.length + j).join(''));
      res = operators[idx];

      if (idx === -1) {
        if (j-- + buf.length > 0) continue;
        res = buf.slice(0, 1).join('');
      }

      token(res);

      start += res.length;
      content = content.slice(res.length);
      return content.length;
    } while (1);
  }

  function hex() {
    if (/[^a-fA-F0-9]/.test(c)) {
      token(content.join(''));
      mode = NORMAL;
      return i;
    }

    content.push(c);
    last = c;
    return i + 1;
  }

  function integer() {
    if (c === '.') {
      content.push(c);
      mode = FLOAT;
      last = c;
      return i + 1;
    }

    if (/[eE]/.test(c)) {
      content.push(c);
      mode = FLOAT;
      last = c;
      return i + 1;
    }

    if (c === 'x' && content.length === 1 && content[0] === '0') {
      mode = HEX;
      content.push(c);
      last = c;
      return i + 1;
    }

    if (/[^\d]/.test(c)) {
      token(content.join(''));
      mode = NORMAL;
      return i;
    }

    content.push(c);
    last = c;
    return i + 1;
  }

  function decimal() {
    if (c === 'f') {
      content.push(c);
      last = c;
      i += 1;
    }

    if (/[eE]/.test(c)) {
      content.push(c);
      last = c;
      return i + 1;
    }

    if (c === '-' && /[eE]/.test(last)) {
      content.push(c);
      last = c;
      return i + 1;
    }

    if (/[^\d]/.test(c)) {
      token(content.join(''));
      mode = NORMAL;
      return i;
    }

    content.push(c);
    last = c;
    return i + 1;
  }

  function readtoken() {
    if (/[^\d\w_]/.test(c)) {
      var contentstr = content.join('');
      if (allLiterals.indexOf(contentstr) > -1) {
        mode = KEYWORD;
      } else if (allBuiltins.indexOf(contentstr) > -1) {
        mode = BUILTIN;
      } else {
        mode = IDENT;
      }
      token(content.join(''));
      mode = NORMAL;
      return i;
    }
    content.push(c);
    last = c;
    return i + 1;
  }
}

},{"./lib/builtins":96,"./lib/builtins-300es":95,"./lib/literals":98,"./lib/literals-300es":97,"./lib/operators":99}],95:[function(require,module,exports){
// 300es builtins/reserved words that were previously valid in v100
var v100 = require('./builtins'

// The texture2D|Cube functions have been removed
// And the gl_ features are updated
);v100 = v100.slice().filter(function (b) {
  return !/^(gl\_|texture)/.test(b);
});

module.exports = v100.concat([
// the updated gl_ constants
'gl_VertexID', 'gl_InstanceID', 'gl_Position', 'gl_PointSize', 'gl_FragCoord', 'gl_FrontFacing', 'gl_FragDepth', 'gl_PointCoord', 'gl_MaxVertexAttribs', 'gl_MaxVertexUniformVectors', 'gl_MaxVertexOutputVectors', 'gl_MaxFragmentInputVectors', 'gl_MaxVertexTextureImageUnits', 'gl_MaxCombinedTextureImageUnits', 'gl_MaxTextureImageUnits', 'gl_MaxFragmentUniformVectors', 'gl_MaxDrawBuffers', 'gl_MinProgramTexelOffset', 'gl_MaxProgramTexelOffset', 'gl_DepthRangeParameters', 'gl_DepthRange'

// other builtins
, 'trunc', 'round', 'roundEven', 'isnan', 'isinf', 'floatBitsToInt', 'floatBitsToUint', 'intBitsToFloat', 'uintBitsToFloat', 'packSnorm2x16', 'unpackSnorm2x16', 'packUnorm2x16', 'unpackUnorm2x16', 'packHalf2x16', 'unpackHalf2x16', 'outerProduct', 'transpose', 'determinant', 'inverse', 'texture', 'textureSize', 'textureProj', 'textureLod', 'textureOffset', 'texelFetch', 'texelFetchOffset', 'textureProjOffset', 'textureLodOffset', 'textureProjLod', 'textureProjLodOffset', 'textureGrad', 'textureGradOffset', 'textureProjGrad', 'textureProjGradOffset']);

},{"./builtins":96}],96:[function(require,module,exports){
module.exports = [
// Keep this list sorted
'abs', 'acos', 'all', 'any', 'asin', 'atan', 'ceil', 'clamp', 'cos', 'cross', 'dFdx', 'dFdy', 'degrees', 'distance', 'dot', 'equal', 'exp', 'exp2', 'faceforward', 'floor', 'fract', 'gl_BackColor', 'gl_BackLightModelProduct', 'gl_BackLightProduct', 'gl_BackMaterial', 'gl_BackSecondaryColor', 'gl_ClipPlane', 'gl_ClipVertex', 'gl_Color', 'gl_DepthRange', 'gl_DepthRangeParameters', 'gl_EyePlaneQ', 'gl_EyePlaneR', 'gl_EyePlaneS', 'gl_EyePlaneT', 'gl_Fog', 'gl_FogCoord', 'gl_FogFragCoord', 'gl_FogParameters', 'gl_FragColor', 'gl_FragCoord', 'gl_FragData', 'gl_FragDepth', 'gl_FragDepthEXT', 'gl_FrontColor', 'gl_FrontFacing', 'gl_FrontLightModelProduct', 'gl_FrontLightProduct', 'gl_FrontMaterial', 'gl_FrontSecondaryColor', 'gl_LightModel', 'gl_LightModelParameters', 'gl_LightModelProducts', 'gl_LightProducts', 'gl_LightSource', 'gl_LightSourceParameters', 'gl_MaterialParameters', 'gl_MaxClipPlanes', 'gl_MaxCombinedTextureImageUnits', 'gl_MaxDrawBuffers', 'gl_MaxFragmentUniformComponents', 'gl_MaxLights', 'gl_MaxTextureCoords', 'gl_MaxTextureImageUnits', 'gl_MaxTextureUnits', 'gl_MaxVaryingFloats', 'gl_MaxVertexAttribs', 'gl_MaxVertexTextureImageUnits', 'gl_MaxVertexUniformComponents', 'gl_ModelViewMatrix', 'gl_ModelViewMatrixInverse', 'gl_ModelViewMatrixInverseTranspose', 'gl_ModelViewMatrixTranspose', 'gl_ModelViewProjectionMatrix', 'gl_ModelViewProjectionMatrixInverse', 'gl_ModelViewProjectionMatrixInverseTranspose', 'gl_ModelViewProjectionMatrixTranspose', 'gl_MultiTexCoord0', 'gl_MultiTexCoord1', 'gl_MultiTexCoord2', 'gl_MultiTexCoord3', 'gl_MultiTexCoord4', 'gl_MultiTexCoord5', 'gl_MultiTexCoord6', 'gl_MultiTexCoord7', 'gl_Normal', 'gl_NormalMatrix', 'gl_NormalScale', 'gl_ObjectPlaneQ', 'gl_ObjectPlaneR', 'gl_ObjectPlaneS', 'gl_ObjectPlaneT', 'gl_Point', 'gl_PointCoord', 'gl_PointParameters', 'gl_PointSize', 'gl_Position', 'gl_ProjectionMatrix', 'gl_ProjectionMatrixInverse', 'gl_ProjectionMatrixInverseTranspose', 'gl_ProjectionMatrixTranspose', 'gl_SecondaryColor', 'gl_TexCoord', 'gl_TextureEnvColor', 'gl_TextureMatrix', 'gl_TextureMatrixInverse', 'gl_TextureMatrixInverseTranspose', 'gl_TextureMatrixTranspose', 'gl_Vertex', 'greaterThan', 'greaterThanEqual', 'inversesqrt', 'length', 'lessThan', 'lessThanEqual', 'log', 'log2', 'matrixCompMult', 'max', 'min', 'mix', 'mod', 'normalize', 'not', 'notEqual', 'pow', 'radians', 'reflect', 'refract', 'sign', 'sin', 'smoothstep', 'sqrt', 'step', 'tan', 'texture2D', 'texture2DLod', 'texture2DProj', 'texture2DProjLod', 'textureCube', 'textureCubeLod', 'texture2DLodEXT', 'texture2DProjLodEXT', 'textureCubeLodEXT', 'texture2DGradEXT', 'texture2DProjGradEXT', 'textureCubeGradEXT'];

},{}],97:[function(require,module,exports){
var v100 = require('./literals');

module.exports = v100.slice().concat(['layout', 'centroid', 'smooth', 'case', 'mat2x2', 'mat2x3', 'mat2x4', 'mat3x2', 'mat3x3', 'mat3x4', 'mat4x2', 'mat4x3', 'mat4x4', 'uint', 'uvec2', 'uvec3', 'uvec4', 'samplerCubeShadow', 'sampler2DArray', 'sampler2DArrayShadow', 'isampler2D', 'isampler3D', 'isamplerCube', 'isampler2DArray', 'usampler2D', 'usampler3D', 'usamplerCube', 'usampler2DArray', 'coherent', 'restrict', 'readonly', 'writeonly', 'resource', 'atomic_uint', 'noperspective', 'patch', 'sample', 'subroutine', 'common', 'partition', 'active', 'filter', 'image1D', 'image2D', 'image3D', 'imageCube', 'iimage1D', 'iimage2D', 'iimage3D', 'iimageCube', 'uimage1D', 'uimage2D', 'uimage3D', 'uimageCube', 'image1DArray', 'image2DArray', 'iimage1DArray', 'iimage2DArray', 'uimage1DArray', 'uimage2DArray', 'image1DShadow', 'image2DShadow', 'image1DArrayShadow', 'image2DArrayShadow', 'imageBuffer', 'iimageBuffer', 'uimageBuffer', 'sampler1DArray', 'sampler1DArrayShadow', 'isampler1D', 'isampler1DArray', 'usampler1D', 'usampler1DArray', 'isampler2DRect', 'usampler2DRect', 'samplerBuffer', 'isamplerBuffer', 'usamplerBuffer', 'sampler2DMS', 'isampler2DMS', 'usampler2DMS', 'sampler2DMSArray', 'isampler2DMSArray', 'usampler2DMSArray']);

},{"./literals":98}],98:[function(require,module,exports){
module.exports = [
// current
'precision', 'highp', 'mediump', 'lowp', 'attribute', 'const', 'uniform', 'varying', 'break', 'continue', 'do', 'for', 'while', 'if', 'else', 'in', 'out', 'inout', 'float', 'int', 'void', 'bool', 'true', 'false', 'discard', 'return', 'mat2', 'mat3', 'mat4', 'vec2', 'vec3', 'vec4', 'ivec2', 'ivec3', 'ivec4', 'bvec2', 'bvec3', 'bvec4', 'sampler1D', 'sampler2D', 'sampler3D', 'samplerCube', 'sampler1DShadow', 'sampler2DShadow', 'struct'

// future
, 'asm', 'class', 'union', 'enum', 'typedef', 'template', 'this', 'packed', 'goto', 'switch', 'default', 'inline', 'noinline', 'volatile', 'public', 'static', 'extern', 'external', 'interface', 'long', 'short', 'double', 'half', 'fixed', 'unsigned', 'input', 'output', 'hvec2', 'hvec3', 'hvec4', 'dvec2', 'dvec3', 'dvec4', 'fvec2', 'fvec3', 'fvec4', 'sampler2DRect', 'sampler3DRect', 'sampler2DRectShadow', 'sizeof', 'cast', 'namespace', 'using'];

},{}],99:[function(require,module,exports){
module.exports = ['<<=', '>>=', '++', '--', '<<', '>>', '<=', '>=', '==', '!=', '&&', '||', '+=', '-=', '*=', '/=', '%=', '&=', '^^', '^=', '|=', '(', ')', '[', ']', '.', '!', '~', '*', '/', '%', '+', '-', '<', '>', '&', '^', '|', '?', ':', '=', ',', ';', '{', '}'];

},{}],100:[function(require,module,exports){
var tokenize = require('./index');

module.exports = tokenizeString;

function tokenizeString(str, opt) {
  var generator = tokenize(opt);
  var tokens = [];

  tokens = tokens.concat(generator(str));
  tokens = tokens.concat(generator(null));

  return tokens;
}

},{"./index":94}],101:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];

  i += d;

  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
};

},{}],102:[function(require,module,exports){
(function (global){
'use strict';

var cache = {};

function noop() {}

module.exports = !global.document ? noop : insertStyles;

function insertStyles(styles, options) {
  var id = options && options.id || styles;

  var element = cache[id] = cache[id] || createStyle(id);

  if ('textContent' in element) {
    element.textContent = styles;
  } else {
    element.styleSheet.cssText = styles;
  }
}

function createStyle(id) {
  var element = document.getElementById(id);

  if (element) return element;

  element = document.createElement('style');
  element.setAttribute('type', 'text/css');

  document.head.appendChild(element);

  return element;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],103:[function(require,module,exports){
"use strict";

var bounds = require("binary-search-bounds");

var NOT_FOUND = 0;
var SUCCESS = 1;
var EMPTY = 2;

module.exports = createWrapper;

function IntervalTreeNode(mid, left, right, leftPoints, rightPoints) {
  this.mid = mid;
  this.left = left;
  this.right = right;
  this.leftPoints = leftPoints;
  this.rightPoints = rightPoints;
  this.count = (left ? left.count : 0) + (right ? right.count : 0) + leftPoints.length;
}

var proto = IntervalTreeNode.prototype;

function copy(a, b) {
  a.mid = b.mid;
  a.left = b.left;
  a.right = b.right;
  a.leftPoints = b.leftPoints;
  a.rightPoints = b.rightPoints;
  a.count = b.count;
}

function rebuild(node, intervals) {
  var ntree = createIntervalTree(intervals);
  node.mid = ntree.mid;
  node.left = ntree.left;
  node.right = ntree.right;
  node.leftPoints = ntree.leftPoints;
  node.rightPoints = ntree.rightPoints;
  node.count = ntree.count;
}

function rebuildWithInterval(node, interval) {
  var intervals = node.intervals([]);
  intervals.push(interval);
  rebuild(node, intervals);
}

function rebuildWithoutInterval(node, interval) {
  var intervals = node.intervals([]);
  var idx = intervals.indexOf(interval);
  if (idx < 0) {
    return NOT_FOUND;
  }
  intervals.splice(idx, 1);
  rebuild(node, intervals);
  return SUCCESS;
}

proto.intervals = function (result) {
  result.push.apply(result, this.leftPoints);
  if (this.left) {
    this.left.intervals(result);
  }
  if (this.right) {
    this.right.intervals(result);
  }
  return result;
};

proto.insert = function (interval) {
  var weight = this.count - this.leftPoints.length;
  this.count += 1;
  if (interval[1] < this.mid) {
    if (this.left) {
      if (4 * (this.left.count + 1) > 3 * (weight + 1)) {
        rebuildWithInterval(this, interval);
      } else {
        this.left.insert(interval);
      }
    } else {
      this.left = createIntervalTree([interval]);
    }
  } else if (interval[0] > this.mid) {
    if (this.right) {
      if (4 * (this.right.count + 1) > 3 * (weight + 1)) {
        rebuildWithInterval(this, interval);
      } else {
        this.right.insert(interval);
      }
    } else {
      this.right = createIntervalTree([interval]);
    }
  } else {
    var l = bounds.ge(this.leftPoints, interval, compareBegin);
    var r = bounds.ge(this.rightPoints, interval, compareEnd);
    this.leftPoints.splice(l, 0, interval);
    this.rightPoints.splice(r, 0, interval);
  }
};

proto.remove = function (interval) {
  var weight = this.count - this.leftPoints;
  if (interval[1] < this.mid) {
    if (!this.left) {
      return NOT_FOUND;
    }
    var rw = this.right ? this.right.count : 0;
    if (4 * rw > 3 * (weight - 1)) {
      return rebuildWithoutInterval(this, interval);
    }
    var r = this.left.remove(interval);
    if (r === EMPTY) {
      this.left = null;
      this.count -= 1;
      return SUCCESS;
    } else if (r === SUCCESS) {
      this.count -= 1;
    }
    return r;
  } else if (interval[0] > this.mid) {
    if (!this.right) {
      return NOT_FOUND;
    }
    var lw = this.left ? this.left.count : 0;
    if (4 * lw > 3 * (weight - 1)) {
      return rebuildWithoutInterval(this, interval);
    }
    var r = this.right.remove(interval);
    if (r === EMPTY) {
      this.right = null;
      this.count -= 1;
      return SUCCESS;
    } else if (r === SUCCESS) {
      this.count -= 1;
    }
    return r;
  } else {
    if (this.count === 1) {
      if (this.leftPoints[0] === interval) {
        return EMPTY;
      } else {
        return NOT_FOUND;
      }
    }
    if (this.leftPoints.length === 1 && this.leftPoints[0] === interval) {
      if (this.left && this.right) {
        var p = this;
        var n = this.left;
        while (n.right) {
          p = n;
          n = n.right;
        }
        if (p === this) {
          n.right = this.right;
        } else {
          var l = this.left;
          var r = this.right;
          p.count -= n.count;
          p.right = n.left;
          n.left = l;
          n.right = r;
        }
        copy(this, n);
        this.count = (this.left ? this.left.count : 0) + (this.right ? this.right.count : 0) + this.leftPoints.length;
      } else if (this.left) {
        copy(this, this.left);
      } else {
        copy(this, this.right);
      }
      return SUCCESS;
    }
    for (var l = bounds.ge(this.leftPoints, interval, compareBegin); l < this.leftPoints.length; ++l) {
      if (this.leftPoints[l][0] !== interval[0]) {
        break;
      }
      if (this.leftPoints[l] === interval) {
        this.count -= 1;
        this.leftPoints.splice(l, 1);
        for (var r = bounds.ge(this.rightPoints, interval, compareEnd); r < this.rightPoints.length; ++r) {
          if (this.rightPoints[r][1] !== interval[1]) {
            break;
          } else if (this.rightPoints[r] === interval) {
            this.rightPoints.splice(r, 1);
            return SUCCESS;
          }
        }
      }
    }
    return NOT_FOUND;
  }
};

function reportLeftRange(arr, hi, cb) {
  for (var i = 0; i < arr.length && arr[i][0] <= hi; ++i) {
    var r = cb(arr[i]);
    if (r) {
      return r;
    }
  }
}

function reportRightRange(arr, lo, cb) {
  for (var i = arr.length - 1; i >= 0 && arr[i][1] >= lo; --i) {
    var r = cb(arr[i]);
    if (r) {
      return r;
    }
  }
}

function reportRange(arr, cb) {
  for (var i = 0; i < arr.length; ++i) {
    var r = cb(arr[i]);
    if (r) {
      return r;
    }
  }
}

proto.queryPoint = function (x, cb) {
  if (x < this.mid) {
    if (this.left) {
      var r = this.left.queryPoint(x, cb);
      if (r) {
        return r;
      }
    }
    return reportLeftRange(this.leftPoints, x, cb);
  } else if (x > this.mid) {
    if (this.right) {
      var r = this.right.queryPoint(x, cb);
      if (r) {
        return r;
      }
    }
    return reportRightRange(this.rightPoints, x, cb);
  } else {
    return reportRange(this.leftPoints, cb);
  }
};

proto.queryInterval = function (lo, hi, cb) {
  if (lo < this.mid && this.left) {
    var r = this.left.queryInterval(lo, hi, cb);
    if (r) {
      return r;
    }
  }
  if (hi > this.mid && this.right) {
    var r = this.right.queryInterval(lo, hi, cb);
    if (r) {
      return r;
    }
  }
  if (hi < this.mid) {
    return reportLeftRange(this.leftPoints, hi, cb);
  } else if (lo > this.mid) {
    return reportRightRange(this.rightPoints, lo, cb);
  } else {
    return reportRange(this.leftPoints, cb);
  }
};

function compareNumbers(a, b) {
  return a - b;
}

function compareBegin(a, b) {
  var d = a[0] - b[0];
  if (d) {
    return d;
  }
  return a[1] - b[1];
}

function compareEnd(a, b) {
  var d = a[1] - b[1];
  if (d) {
    return d;
  }
  return a[0] - b[0];
}

function createIntervalTree(intervals) {
  if (intervals.length === 0) {
    return null;
  }
  var pts = [];
  for (var i = 0; i < intervals.length; ++i) {
    pts.push(intervals[i][0], intervals[i][1]);
  }
  pts.sort(compareNumbers);

  var mid = pts[pts.length >> 1];

  var leftIntervals = [];
  var rightIntervals = [];
  var centerIntervals = [];
  for (var i = 0; i < intervals.length; ++i) {
    var s = intervals[i];
    if (s[1] < mid) {
      leftIntervals.push(s);
    } else if (mid < s[0]) {
      rightIntervals.push(s);
    } else {
      centerIntervals.push(s);
    }
  }

  //Split center intervals
  var leftPoints = centerIntervals;
  var rightPoints = centerIntervals.slice();
  leftPoints.sort(compareBegin);
  rightPoints.sort(compareEnd);

  return new IntervalTreeNode(mid, createIntervalTree(leftIntervals), createIntervalTree(rightIntervals), leftPoints, rightPoints);
}

//User friendly wrapper that makes it possible to support empty trees
function IntervalTree(root) {
  this.root = root;
}

var tproto = IntervalTree.prototype;

tproto.insert = function (interval) {
  if (this.root) {
    this.root.insert(interval);
  } else {
    this.root = new IntervalTreeNode(interval[0], null, null, [interval], [interval]);
  }
};

tproto.remove = function (interval) {
  if (this.root) {
    var r = this.root.remove(interval);
    if (r === EMPTY) {
      this.root = null;
    }
    return r !== NOT_FOUND;
  }
  return false;
};

tproto.queryPoint = function (p, cb) {
  if (this.root) {
    return this.root.queryPoint(p, cb);
  }
};

tproto.queryInterval = function (lo, hi, cb) {
  if (lo <= hi && this.root) {
    return this.root.queryInterval(lo, hi, cb);
  }
};

Object.defineProperty(tproto, "count", {
  get: function () {
    if (this.root) {
      return this.root.count;
    }
    return 0;
  }
});

Object.defineProperty(tproto, "intervals", {
  get: function () {
    if (this.root) {
      return this.root.intervals([]);
    }
    return [];
  }
});

function createWrapper(intervals) {
  if (!intervals || intervals.length === 0) {
    return new IntervalTree(null);
  }
  return new IntervalTree(createIntervalTree(intervals));
}

},{"binary-search-bounds":104}],104:[function(require,module,exports){
"use strict";

function compileSearch(funcName, predicate, reversed, extraArgs, useNdarray, earlyOut) {
  var code = ["function ", funcName, "(a,l,h,", extraArgs.join(","), "){", earlyOut ? "" : "var i=", reversed ? "l-1" : "h+1", ";while(l<=h){\
var m=(l+h)>>>1,x=a", useNdarray ? ".get(m)" : "[m]"];
  if (earlyOut) {
    if (predicate.indexOf("c") < 0) {
      code.push(";if(x===y){return m}else if(x<=y){");
    } else {
      code.push(";var p=c(x,y);if(p===0){return m}else if(p<=0){");
    }
  } else {
    code.push(";if(", predicate, "){i=m;");
  }
  if (reversed) {
    code.push("l=m+1}else{h=m-1}");
  } else {
    code.push("h=m-1}else{l=m+1}");
  }
  code.push("}");
  if (earlyOut) {
    code.push("return -1};");
  } else {
    code.push("return i};");
  }
  return code.join("");
}

function compileBoundsSearch(predicate, reversed, suffix, earlyOut) {
  var result = new Function([compileSearch("A", "x" + predicate + "y", reversed, ["y"], false, earlyOut), compileSearch("B", "x" + predicate + "y", reversed, ["y"], true, earlyOut), compileSearch("P", "c(x,y)" + predicate + "0", reversed, ["y", "c"], false, earlyOut), compileSearch("Q", "c(x,y)" + predicate + "0", reversed, ["y", "c"], true, earlyOut), "function dispatchBsearch", suffix, "(a,y,c,l,h){\
if(a.shape){\
if(typeof(c)==='function'){\
return Q(a,(l===undefined)?0:l|0,(h===undefined)?a.shape[0]-1:h|0,y,c)\
}else{\
return B(a,(c===undefined)?0:c|0,(l===undefined)?a.shape[0]-1:l|0,y)\
}}else{\
if(typeof(c)==='function'){\
return P(a,(l===undefined)?0:l|0,(h===undefined)?a.length-1:h|0,y,c)\
}else{\
return A(a,(c===undefined)?0:c|0,(l===undefined)?a.length-1:l|0,y)\
}}}\
return dispatchBsearch", suffix].join(""));
  return result();
}

module.exports = {
  ge: compileBoundsSearch(">=", false, "GE"),
  gt: compileBoundsSearch(">", false, "GT"),
  lt: compileBoundsSearch("<", true, "LT"),
  le: compileBoundsSearch("<=", true, "LE"),
  eq: compileBoundsSearch("-", true, "EQ", true)
};

},{}],105:[function(require,module,exports){
"use strict";

function invertPermutation(pi, result) {
  result = result || new Array(pi.length);
  for (var i = 0; i < pi.length; ++i) {
    result[pi[i]] = i;
  }
  return result;
}

module.exports = invertPermutation;

},{}],106:[function(require,module,exports){
"use strict";

function iota(n) {
  var result = new Array(n);
  for (var i = 0; i < n; ++i) {
    result[i] = i;
  }
  return result;
}

module.exports = iota;

},{}],107:[function(require,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
};

function isBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0));
}

},{}],108:[function(require,module,exports){
'use strict';

var toString = Object.prototype.toString;

module.exports = function (x) {
	var prototype;
	return toString.call(x) === '[object Object]' && (prototype = Object.getPrototypeOf(x), prototype === null || prototype === Object.getPrototypeOf({}));
};

},{}],109:[function(require,module,exports){
'use strict';

module.exports = mouseListen;

var mouse = require('mouse-event');

function mouseListen(element, callback) {
  if (!callback) {
    callback = element;
    element = window;
  }

  var buttonState = 0;
  var x = 0;
  var y = 0;
  var mods = {
    shift: false,
    alt: false,
    control: false,
    meta: false
  };
  var attached = false;

  function updateMods(ev) {
    var changed = false;
    if ('altKey' in ev) {
      changed = changed || ev.altKey !== mods.alt;
      mods.alt = !!ev.altKey;
    }
    if ('shiftKey' in ev) {
      changed = changed || ev.shiftKey !== mods.shift;
      mods.shift = !!ev.shiftKey;
    }
    if ('ctrlKey' in ev) {
      changed = changed || ev.ctrlKey !== mods.control;
      mods.control = !!ev.ctrlKey;
    }
    if ('metaKey' in ev) {
      changed = changed || ev.metaKey !== mods.meta;
      mods.meta = !!ev.metaKey;
    }
    return changed;
  }

  function handleEvent(nextButtons, ev) {
    var nextX = mouse.x(ev);
    var nextY = mouse.y(ev);
    if ('buttons' in ev) {
      nextButtons = ev.buttons | 0;
    }
    if (nextButtons !== buttonState || nextX !== x || nextY !== y || updateMods(ev)) {
      buttonState = nextButtons | 0;
      x = nextX || 0;
      y = nextY || 0;
      callback && callback(buttonState, x, y, mods);
    }
  }

  function clearState(ev) {
    handleEvent(0, ev);
  }

  function handleBlur() {
    if (buttonState || x || y || mods.shift || mods.alt || mods.meta || mods.control) {
      x = y = 0;
      buttonState = 0;
      mods.shift = mods.alt = mods.control = mods.meta = false;
      callback && callback(0, 0, 0, mods);
    }
  }

  function handleMods(ev) {
    if (updateMods(ev)) {
      callback && callback(buttonState, x, y, mods);
    }
  }

  function handleMouseMove(ev) {
    if (mouse.buttons(ev) === 0) {
      handleEvent(0, ev);
    } else {
      handleEvent(buttonState, ev);
    }
  }

  function handleMouseDown(ev) {
    handleEvent(buttonState | mouse.buttons(ev), ev);
  }

  function handleMouseUp(ev) {
    handleEvent(buttonState & ~mouse.buttons(ev), ev);
  }

  function attachListeners() {
    if (attached) {
      return;
    }
    attached = true;

    element.addEventListener('mousemove', handleMouseMove);

    element.addEventListener('mousedown', handleMouseDown);

    element.addEventListener('mouseup', handleMouseUp);

    element.addEventListener('mouseleave', clearState);
    element.addEventListener('mouseenter', clearState);
    element.addEventListener('mouseout', clearState);
    element.addEventListener('mouseover', clearState);

    element.addEventListener('blur', handleBlur);

    element.addEventListener('keyup', handleMods);
    element.addEventListener('keydown', handleMods);
    element.addEventListener('keypress', handleMods);

    if (element !== window) {
      window.addEventListener('blur', handleBlur);

      window.addEventListener('keyup', handleMods);
      window.addEventListener('keydown', handleMods);
      window.addEventListener('keypress', handleMods);
    }
  }

  function detachListeners() {
    if (!attached) {
      return;
    }
    attached = false;

    element.removeEventListener('mousemove', handleMouseMove);

    element.removeEventListener('mousedown', handleMouseDown);

    element.removeEventListener('mouseup', handleMouseUp);

    element.removeEventListener('mouseleave', clearState);
    element.removeEventListener('mouseenter', clearState);
    element.removeEventListener('mouseout', clearState);
    element.removeEventListener('mouseover', clearState);

    element.removeEventListener('blur', handleBlur);

    element.removeEventListener('keyup', handleMods);
    element.removeEventListener('keydown', handleMods);
    element.removeEventListener('keypress', handleMods);

    if (element !== window) {
      window.removeEventListener('blur', handleBlur);

      window.removeEventListener('keyup', handleMods);
      window.removeEventListener('keydown', handleMods);
      window.removeEventListener('keypress', handleMods);
    }
  }

  // Attach listeners
  attachListeners();

  var result = {
    element: element
  };

  Object.defineProperties(result, {
    enabled: {
      get: function () {
        return attached;
      },
      set: function (f) {
        if (f) {
          attachListeners();
        } else {
          detachListeners();
        }
      },
      enumerable: true
    },
    buttons: {
      get: function () {
        return buttonState;
      },
      enumerable: true
    },
    x: {
      get: function () {
        return x;
      },
      enumerable: true
    },
    y: {
      get: function () {
        return y;
      },
      enumerable: true
    },
    mods: {
      get: function () {
        return mods;
      },
      enumerable: true
    }
  });

  return result;
}

},{"mouse-event":110}],110:[function(require,module,exports){
'use strict';

function mouseButtons(ev) {
  if (typeof ev === 'object') {
    if ('buttons' in ev) {
      return ev.buttons;
    } else if ('which' in ev) {
      var b = ev.which;
      if (b === 2) {
        return 4;
      } else if (b === 3) {
        return 2;
      } else if (b > 0) {
        return 1 << b - 1;
      }
    } else if ('button' in ev) {
      var b = ev.button;
      if (b === 1) {
        return 4;
      } else if (b === 2) {
        return 2;
      } else if (b >= 0) {
        return 1 << b;
      }
    }
  }
  return 0;
}
exports.buttons = mouseButtons;

function mouseElement(ev) {
  return ev.target || ev.srcElement || window;
}
exports.element = mouseElement;

function mouseRelativeX(ev) {
  if (typeof ev === 'object') {
    if ('offsetX' in ev) {
      return ev.offsetX;
    }
    var target = mouseElement(ev);
    var bounds = target.getBoundingClientRect();
    return ev.clientX - bounds.left;
  }
  return 0;
}
exports.x = mouseRelativeX;

function mouseRelativeY(ev) {
  if (typeof ev === 'object') {
    if ('offsetY' in ev) {
      return ev.offsetY;
    }
    var target = mouseElement(ev);
    var bounds = target.getBoundingClientRect();
    return ev.clientY - bounds.top;
  }
  return 0;
}
exports.y = mouseRelativeY;

},{}],111:[function(require,module,exports){
'use strict';

var toPX = require('to-px');

module.exports = mouseWheelListen;

function mouseWheelListen(element, callback, noScroll) {
  if (typeof element === 'function') {
    noScroll = !!callback;
    callback = element;
    element = window;
  }
  var lineHeight = toPX('ex', element);
  var listener = function (ev) {
    if (noScroll) {
      ev.preventDefault();
    }
    var dx = ev.deltaX || 0;
    var dy = ev.deltaY || 0;
    var dz = ev.deltaZ || 0;
    var mode = ev.deltaMode;
    var scale = 1;
    switch (mode) {
      case 1:
        scale = lineHeight;
        break;
      case 2:
        scale = window.innerHeight;
        break;
    }
    dx *= scale;
    dy *= scale;
    dz *= scale;
    if (dx || dy || dz) {
      return callback(dx, dy, dz, ev);
    }
  };
  element.addEventListener('wheel', listener);
  return listener;
}

},{"to-px":157}],112:[function(require,module,exports){
"use strict";

var pool = require("typedarray-pool");

module.exports = createSurfaceExtractor;

//Helper macros
function array(i) {
  return "a" + i;
}
function data(i) {
  return "d" + i;
}
function cube(i, bitmask) {
  return "c" + i + "_" + bitmask;
}
function shape(i) {
  return "s" + i;
}
function stride(i, j) {
  return "t" + i + "_" + j;
}
function offset(i) {
  return "o" + i;
}
function scalar(i) {
  return "x" + i;
}
function pointer(i) {
  return "p" + i;
}
function delta(i, bitmask) {
  return "d" + i + "_" + bitmask;
}
function index(i) {
  return "i" + i;
}
function step(i, j) {
  return "u" + i + "_" + j;
}
function pcube(bitmask) {
  return "b" + bitmask;
}
function qcube(bitmask) {
  return "y" + bitmask;
}
function pdelta(bitmask) {
  return "e" + bitmask;
}
function vert(i) {
  return "v" + i;
}
var VERTEX_IDS = "V";
var PHASES = "P";
var VERTEX_COUNT = "N";
var POOL_SIZE = "Q";
var POINTER = "X";
var TEMPORARY = "T";

function permBitmask(dimension, mask, order) {
  var r = 0;
  for (var i = 0; i < dimension; ++i) {
    if (mask & 1 << i) {
      r |= 1 << order[i];
    }
  }
  return r;
}

//Generates the surface procedure
function compileSurfaceProcedure(vertexFunc, faceFunc, phaseFunc, scalarArgs, order, typesig) {
  var arrayArgs = typesig.length;
  var dimension = order.length;

  if (dimension < 2) {
    throw new Error("ndarray-extract-contour: Dimension must be at least 2");
  }

  var funcName = "extractContour" + order.join("_");
  var code = [];
  var vars = [];
  var args = [];

  //Assemble arguments
  for (var i = 0; i < arrayArgs; ++i) {
    args.push(array(i));
  }
  for (var i = 0; i < scalarArgs; ++i) {
    args.push(scalar(i));
  }

  //Shape
  for (var i = 0; i < dimension; ++i) {
    vars.push(shape(i) + "=" + array(0) + ".shape[" + i + "]|0");
  }
  //Data, stride, offset pointers
  for (var i = 0; i < arrayArgs; ++i) {
    vars.push(data(i) + "=" + array(i) + ".data", offset(i) + "=" + array(i) + ".offset|0");
    for (var j = 0; j < dimension; ++j) {
      vars.push(stride(i, j) + "=" + array(i) + ".stride[" + j + "]|0");
    }
  }
  //Pointer, delta and cube variables
  for (var i = 0; i < arrayArgs; ++i) {
    vars.push(pointer(i) + "=" + offset(i));
    vars.push(cube(i, 0));
    for (var j = 1; j < 1 << dimension; ++j) {
      var ptrStr = [];
      for (var k = 0; k < dimension; ++k) {
        if (j & 1 << k) {
          ptrStr.push("-" + stride(i, k));
        }
      }
      vars.push(delta(i, j) + "=(" + ptrStr.join("") + ")|0");
      vars.push(cube(i, j) + "=0");
    }
  }
  //Create step variables
  for (var i = 0; i < arrayArgs; ++i) {
    for (var j = 0; j < dimension; ++j) {
      var stepVal = [stride(i, order[j])];
      if (j > 0) {
        stepVal.push(stride(i, order[j - 1]) + "*" + shape(order[j - 1]));
      }
      vars.push(step(i, order[j]) + "=(" + stepVal.join("-") + ")|0");
    }
  }
  //Create index variables
  for (var i = 0; i < dimension; ++i) {
    vars.push(index(i) + "=0");
  }
  //Vertex count
  vars.push(VERTEX_COUNT + "=0"
  //Compute pool size, initialize pool step
  );var sizeVariable = ["2"];
  for (var i = dimension - 2; i >= 0; --i) {
    sizeVariable.push(shape(order[i]));
  }
  //Previous phases and vertex_ids
  vars.push(POOL_SIZE + "=(" + sizeVariable.join("*") + ")|0", PHASES + "=mallocUint32(" + POOL_SIZE + ")", VERTEX_IDS + "=mallocUint32(" + POOL_SIZE + ")", POINTER + "=0"
  //Create cube variables for phases
  );vars.push(pcube(0) + "=0");
  for (var j = 1; j < 1 << dimension; ++j) {
    var cubeDelta = [];
    var cubeStep = [];
    for (var k = 0; k < dimension; ++k) {
      if (j & 1 << k) {
        if (cubeStep.length === 0) {
          cubeDelta.push("1");
        } else {
          cubeDelta.unshift(cubeStep.join("*"));
        }
      }
      cubeStep.push(shape(order[k]));
    }
    var signFlag = "";
    if (cubeDelta[0].indexOf(shape(order[dimension - 2])) < 0) {
      signFlag = "-";
    }
    var jperm = permBitmask(dimension, j, order);
    vars.push(pdelta(jperm) + "=(-" + cubeDelta.join("-") + ")|0", qcube(jperm) + "=(" + signFlag + cubeDelta.join("-") + ")|0", pcube(jperm) + "=0");
  }
  vars.push(vert(0) + "=0", TEMPORARY + "=0");

  function forLoopBegin(i, start) {
    code.push("for(", index(order[i]), "=", start, ";", index(order[i]), "<", shape(order[i]), ";", "++", index(order[i]), "){");
  }

  function forLoopEnd(i) {
    for (var j = 0; j < arrayArgs; ++j) {
      code.push(pointer(j), "+=", step(j, order[i]), ";");
    }
    code.push("}");
  }

  function fillEmptySlice(k) {
    for (var i = k - 1; i >= 0; --i) {
      forLoopBegin(i, 0);
    }
    var phaseFuncArgs = [];
    for (var i = 0; i < arrayArgs; ++i) {
      if (typesig[i]) {
        phaseFuncArgs.push(data(i) + ".get(" + pointer(i) + ")");
      } else {
        phaseFuncArgs.push(data(i) + "[" + pointer(i) + "]");
      }
    }
    for (var i = 0; i < scalarArgs; ++i) {
      phaseFuncArgs.push(scalar(i));
    }
    code.push(PHASES, "[", POINTER, "++]=phase(", phaseFuncArgs.join(), ");");
    for (var i = 0; i < k; ++i) {
      forLoopEnd(i);
    }
    for (var j = 0; j < arrayArgs; ++j) {
      code.push(pointer(j), "+=", step(j, order[k]), ";");
    }
  }

  function processGridCell(mask) {
    //Read in local data
    for (var i = 0; i < arrayArgs; ++i) {
      if (typesig[i]) {
        code.push(cube(i, 0), "=", data(i), ".get(", pointer(i), ");");
      } else {
        code.push(cube(i, 0), "=", data(i), "[", pointer(i), "];");
      }
    }

    //Read in phase
    var phaseFuncArgs = [];
    for (var i = 0; i < arrayArgs; ++i) {
      phaseFuncArgs.push(cube(i, 0));
    }
    for (var i = 0; i < scalarArgs; ++i) {
      phaseFuncArgs.push(scalar(i));
    }

    code.push(pcube(0), "=", PHASES, "[", POINTER, "]=phase(", phaseFuncArgs.join(), ");"

    //Read in other cube data
    );for (var j = 1; j < 1 << dimension; ++j) {
      code.push(pcube(j), "=", PHASES, "[", POINTER, "+", pdelta(j), "];");
    }

    //Check for boundary crossing
    var vertexPredicate = [];
    for (var j = 1; j < 1 << dimension; ++j) {
      vertexPredicate.push("(" + pcube(0) + "!==" + pcube(j) + ")");
    }
    code.push("if(", vertexPredicate.join("||"), "){"

    //Read in boundary data
    );var vertexArgs = [];
    for (var i = 0; i < dimension; ++i) {
      vertexArgs.push(index(i));
    }
    for (var i = 0; i < arrayArgs; ++i) {
      vertexArgs.push(cube(i, 0));
      for (var j = 1; j < 1 << dimension; ++j) {
        if (typesig[i]) {
          code.push(cube(i, j), "=", data(i), ".get(", pointer(i), "+", delta(i, j), ");");
        } else {
          code.push(cube(i, j), "=", data(i), "[", pointer(i), "+", delta(i, j), "];");
        }
        vertexArgs.push(cube(i, j));
      }
    }
    for (var i = 0; i < 1 << dimension; ++i) {
      vertexArgs.push(pcube(i));
    }
    for (var i = 0; i < scalarArgs; ++i) {
      vertexArgs.push(scalar(i));
    }

    //Generate vertex
    code.push("vertex(", vertexArgs.join(), ");", vert(0), "=", VERTEX_IDS, "[", POINTER, "]=", VERTEX_COUNT, "++;"

    //Check for face crossings
    );var base = (1 << dimension) - 1;
    var corner = pcube(base);
    for (var j = 0; j < dimension; ++j) {
      if ((mask & ~(1 << j)) === 0) {
        //Check face
        var subset = base ^ 1 << j;
        var edge = pcube(subset);
        var faceArgs = [];
        for (var k = subset; k > 0; k = k - 1 & subset) {
          faceArgs.push(VERTEX_IDS + "[" + POINTER + "+" + pdelta(k) + "]");
        }
        faceArgs.push(vert(0));
        for (var k = 0; k < arrayArgs; ++k) {
          if (j & 1) {
            faceArgs.push(cube(k, base), cube(k, subset));
          } else {
            faceArgs.push(cube(k, subset), cube(k, base));
          }
        }
        if (j & 1) {
          faceArgs.push(corner, edge);
        } else {
          faceArgs.push(edge, corner);
        }
        for (var k = 0; k < scalarArgs; ++k) {
          faceArgs.push(scalar(k));
        }
        code.push("if(", corner, "!==", edge, "){", "face(", faceArgs.join(), ")}");
      }
    }

    //Increment pointer, close off if statement
    code.push("}", POINTER, "+=1;");
  }

  function flip() {
    for (var j = 1; j < 1 << dimension; ++j) {
      code.push(TEMPORARY, "=", pdelta(j), ";", pdelta(j), "=", qcube(j), ";", qcube(j), "=", TEMPORARY, ";");
    }
  }

  function createLoop(i, mask) {
    if (i < 0) {
      processGridCell(mask);
      return;
    }
    fillEmptySlice(i);
    code.push("if(", shape(order[i]), ">0){", index(order[i]), "=1;");
    createLoop(i - 1, mask | 1 << order[i]);

    for (var j = 0; j < arrayArgs; ++j) {
      code.push(pointer(j), "+=", step(j, order[i]), ";");
    }
    if (i === dimension - 1) {
      code.push(POINTER, "=0;");
      flip();
    }
    forLoopBegin(i, 2);
    createLoop(i - 1, mask);
    if (i === dimension - 1) {
      code.push("if(", index(order[dimension - 1]), "&1){", POINTER, "=0;}");
      flip();
    }
    forLoopEnd(i);
    code.push("}");
  }

  createLoop(dimension - 1, 0

  //Release scratch memory
  );code.push("freeUint32(", VERTEX_IDS, ");freeUint32(", PHASES, ");"

  //Compile and link procedure
  );var procedureCode = ["'use strict';", "function ", funcName, "(", args.join(), "){", "var ", vars.join(), ";", code.join(""), "}", "return ", funcName].join("");

  var proc = new Function("vertex", "face", "phase", "mallocUint32", "freeUint32", procedureCode);
  return proc(vertexFunc, faceFunc, phaseFunc, pool.mallocUint32, pool.freeUint32);
}

function createSurfaceExtractor(args) {
  function error(msg) {
    throw new Error("ndarray-extract-contour: " + msg);
  }
  if (typeof args !== "object") {
    error("Must specify arguments");
  }
  var order = args.order;
  if (!Array.isArray(order)) {
    error("Must specify order");
  }
  var arrays = args.arrayArguments || 1;
  if (arrays < 1) {
    error("Must have at least one array argument");
  }
  var scalars = args.scalarArguments || 0;
  if (scalars < 0) {
    error("Scalar arg count must be > 0");
  }
  if (typeof args.vertex !== "function") {
    error("Must specify vertex creation function");
  }
  if (typeof args.cell !== "function") {
    error("Must specify cell creation function");
  }
  if (typeof args.phase !== "function") {
    error("Must specify phase function");
  }
  var getters = args.getters || [];
  var typesig = new Array(arrays);
  for (var i = 0; i < arrays; ++i) {
    if (getters.indexOf(i) >= 0) {
      typesig[i] = true;
    } else {
      typesig[i] = false;
    }
  }
  return compileSurfaceProcedure(args.vertex, args.cell, args.phase, scalars, order, typesig);
}

},{"typedarray-pool":162}],113:[function(require,module,exports){
"use strict";

var compile = require("cwise-compiler");

var EmptyProc = {
  body: "",
  args: [],
  thisVars: [],
  localVars: []
};

function fixup(x) {
  if (!x) {
    return EmptyProc;
  }
  for (var i = 0; i < x.args.length; ++i) {
    var a = x.args[i];
    if (i === 0) {
      x.args[i] = { name: a, lvalue: true, rvalue: !!x.rvalue, count: x.count || 1 };
    } else {
      x.args[i] = { name: a, lvalue: false, rvalue: true, count: 1 };
    }
  }
  if (!x.thisVars) {
    x.thisVars = [];
  }
  if (!x.localVars) {
    x.localVars = [];
  }
  return x;
}

function pcompile(user_args) {
  return compile({
    args: user_args.args,
    pre: fixup(user_args.pre),
    body: fixup(user_args.body),
    post: fixup(user_args.proc),
    funcName: user_args.funcName
  });
}

function makeOp(user_args) {
  var args = [];
  for (var i = 0; i < user_args.args.length; ++i) {
    args.push("a" + i);
  }
  var wrapper = new Function("P", ["return function ", user_args.funcName, "_ndarrayops(", args.join(","), ") {P(", args.join(","), ");return a0}"].join(""));
  return wrapper(pcompile(user_args));
}

var assign_ops = {
  add: "+",
  sub: "-",
  mul: "*",
  div: "/",
  mod: "%",
  band: "&",
  bor: "|",
  bxor: "^",
  lshift: "<<",
  rshift: ">>",
  rrshift: ">>>"
};(function () {
  for (var id in assign_ops) {
    var op = assign_ops[id];
    exports[id] = makeOp({
      args: ["array", "array", "array"],
      body: { args: ["a", "b", "c"],
        body: "a=b" + op + "c" },
      funcName: id
    });
    exports[id + "eq"] = makeOp({
      args: ["array", "array"],
      body: { args: ["a", "b"],
        body: "a" + op + "=b" },
      rvalue: true,
      funcName: id + "eq"
    });
    exports[id + "s"] = makeOp({
      args: ["array", "array", "scalar"],
      body: { args: ["a", "b", "s"],
        body: "a=b" + op + "s" },
      funcName: id + "s"
    });
    exports[id + "seq"] = makeOp({
      args: ["array", "scalar"],
      body: { args: ["a", "s"],
        body: "a" + op + "=s" },
      rvalue: true,
      funcName: id + "seq"
    });
  }
})();

var unary_ops = {
  not: "!",
  bnot: "~",
  neg: "-",
  recip: "1.0/"
};(function () {
  for (var id in unary_ops) {
    var op = unary_ops[id];
    exports[id] = makeOp({
      args: ["array", "array"],
      body: { args: ["a", "b"],
        body: "a=" + op + "b" },
      funcName: id
    });
    exports[id + "eq"] = makeOp({
      args: ["array"],
      body: { args: ["a"],
        body: "a=" + op + "a" },
      rvalue: true,
      count: 2,
      funcName: id + "eq"
    });
  }
})();

var binary_ops = {
  and: "&&",
  or: "||",
  eq: "===",
  neq: "!==",
  lt: "<",
  gt: ">",
  leq: "<=",
  geq: ">="
};(function () {
  for (var id in binary_ops) {
    var op = binary_ops[id];
    exports[id] = makeOp({
      args: ["array", "array", "array"],
      body: { args: ["a", "b", "c"],
        body: "a=b" + op + "c" },
      funcName: id
    });
    exports[id + "s"] = makeOp({
      args: ["array", "array", "scalar"],
      body: { args: ["a", "b", "s"],
        body: "a=b" + op + "s" },
      funcName: id + "s"
    });
    exports[id + "eq"] = makeOp({
      args: ["array", "array"],
      body: { args: ["a", "b"],
        body: "a=a" + op + "b" },
      rvalue: true,
      count: 2,
      funcName: id + "eq"
    });
    exports[id + "seq"] = makeOp({
      args: ["array", "scalar"],
      body: { args: ["a", "s"],
        body: "a=a" + op + "s" },
      rvalue: true,
      count: 2,
      funcName: id + "seq"
    });
  }
})();

var math_unary = ["abs", "acos", "asin", "atan", "ceil", "cos", "exp", "floor", "log", "round", "sin", "sqrt", "tan"];(function () {
  for (var i = 0; i < math_unary.length; ++i) {
    var f = math_unary[i];
    exports[f] = makeOp({
      args: ["array", "array"],
      pre: { args: [], body: "this_f=Math." + f, thisVars: ["this_f"] },
      body: { args: ["a", "b"], body: "a=this_f(b)", thisVars: ["this_f"] },
      funcName: f
    });
    exports[f + "eq"] = makeOp({
      args: ["array"],
      pre: { args: [], body: "this_f=Math." + f, thisVars: ["this_f"] },
      body: { args: ["a"], body: "a=this_f(a)", thisVars: ["this_f"] },
      rvalue: true,
      count: 2,
      funcName: f + "eq"
    });
  }
})();

var math_comm = ["max", "min", "atan2", "pow"];(function () {
  for (var i = 0; i < math_comm.length; ++i) {
    var f = math_comm[i];
    exports[f] = makeOp({
      args: ["array", "array", "array"],
      pre: { args: [], body: "this_f=Math." + f, thisVars: ["this_f"] },
      body: { args: ["a", "b", "c"], body: "a=this_f(b,c)", thisVars: ["this_f"] },
      funcName: f
    });
    exports[f + "s"] = makeOp({
      args: ["array", "array", "scalar"],
      pre: { args: [], body: "this_f=Math." + f, thisVars: ["this_f"] },
      body: { args: ["a", "b", "c"], body: "a=this_f(b,c)", thisVars: ["this_f"] },
      funcName: f + "s"
    });
    exports[f + "eq"] = makeOp({ args: ["array", "array"],
      pre: { args: [], body: "this_f=Math." + f, thisVars: ["this_f"] },
      body: { args: ["a", "b"], body: "a=this_f(a,b)", thisVars: ["this_f"] },
      rvalue: true,
      count: 2,
      funcName: f + "eq"
    });
    exports[f + "seq"] = makeOp({ args: ["array", "scalar"],
      pre: { args: [], body: "this_f=Math." + f, thisVars: ["this_f"] },
      body: { args: ["a", "b"], body: "a=this_f(a,b)", thisVars: ["this_f"] },
      rvalue: true,
      count: 2,
      funcName: f + "seq"
    });
  }
})();

var math_noncomm = ["atan2", "pow"];(function () {
  for (var i = 0; i < math_noncomm.length; ++i) {
    var f = math_noncomm[i];
    exports[f + "op"] = makeOp({
      args: ["array", "array", "array"],
      pre: { args: [], body: "this_f=Math." + f, thisVars: ["this_f"] },
      body: { args: ["a", "b", "c"], body: "a=this_f(c,b)", thisVars: ["this_f"] },
      funcName: f + "op"
    });
    exports[f + "ops"] = makeOp({
      args: ["array", "array", "scalar"],
      pre: { args: [], body: "this_f=Math." + f, thisVars: ["this_f"] },
      body: { args: ["a", "b", "c"], body: "a=this_f(c,b)", thisVars: ["this_f"] },
      funcName: f + "ops"
    });
    exports[f + "opeq"] = makeOp({ args: ["array", "array"],
      pre: { args: [], body: "this_f=Math." + f, thisVars: ["this_f"] },
      body: { args: ["a", "b"], body: "a=this_f(b,a)", thisVars: ["this_f"] },
      rvalue: true,
      count: 2,
      funcName: f + "opeq"
    });
    exports[f + "opseq"] = makeOp({ args: ["array", "scalar"],
      pre: { args: [], body: "this_f=Math." + f, thisVars: ["this_f"] },
      body: { args: ["a", "b"], body: "a=this_f(b,a)", thisVars: ["this_f"] },
      rvalue: true,
      count: 2,
      funcName: f + "opseq"
    });
  }
})();

exports.any = compile({
  args: ["array"],
  pre: EmptyProc,
  body: { args: [{ name: "a", lvalue: false, rvalue: true, count: 1 }], body: "if(a){return true}", localVars: [], thisVars: [] },
  post: { args: [], localVars: [], thisVars: [], body: "return false" },
  funcName: "any"
});

exports.all = compile({
  args: ["array"],
  pre: EmptyProc,
  body: { args: [{ name: "x", lvalue: false, rvalue: true, count: 1 }], body: "if(!x){return false}", localVars: [], thisVars: [] },
  post: { args: [], localVars: [], thisVars: [], body: "return true" },
  funcName: "all"
});

exports.sum = compile({
  args: ["array"],
  pre: { args: [], localVars: [], thisVars: ["this_s"], body: "this_s=0" },
  body: { args: [{ name: "a", lvalue: false, rvalue: true, count: 1 }], body: "this_s+=a", localVars: [], thisVars: ["this_s"] },
  post: { args: [], localVars: [], thisVars: ["this_s"], body: "return this_s" },
  funcName: "sum"
});

exports.prod = compile({
  args: ["array"],
  pre: { args: [], localVars: [], thisVars: ["this_s"], body: "this_s=1" },
  body: { args: [{ name: "a", lvalue: false, rvalue: true, count: 1 }], body: "this_s*=a", localVars: [], thisVars: ["this_s"] },
  post: { args: [], localVars: [], thisVars: ["this_s"], body: "return this_s" },
  funcName: "prod"
});

exports.norm2squared = compile({
  args: ["array"],
  pre: { args: [], localVars: [], thisVars: ["this_s"], body: "this_s=0" },
  body: { args: [{ name: "a", lvalue: false, rvalue: true, count: 2 }], body: "this_s+=a*a", localVars: [], thisVars: ["this_s"] },
  post: { args: [], localVars: [], thisVars: ["this_s"], body: "return this_s" },
  funcName: "norm2squared"
});

exports.norm2 = compile({
  args: ["array"],
  pre: { args: [], localVars: [], thisVars: ["this_s"], body: "this_s=0" },
  body: { args: [{ name: "a", lvalue: false, rvalue: true, count: 2 }], body: "this_s+=a*a", localVars: [], thisVars: ["this_s"] },
  post: { args: [], localVars: [], thisVars: ["this_s"], body: "return Math.sqrt(this_s)" },
  funcName: "norm2"
});

exports.norminf = compile({
  args: ["array"],
  pre: { args: [], localVars: [], thisVars: ["this_s"], body: "this_s=0" },
  body: { args: [{ name: "a", lvalue: false, rvalue: true, count: 4 }], body: "if(-a>this_s){this_s=-a}else if(a>this_s){this_s=a}", localVars: [], thisVars: ["this_s"] },
  post: { args: [], localVars: [], thisVars: ["this_s"], body: "return this_s" },
  funcName: "norminf"
});

exports.norm1 = compile({
  args: ["array"],
  pre: { args: [], localVars: [], thisVars: ["this_s"], body: "this_s=0" },
  body: { args: [{ name: "a", lvalue: false, rvalue: true, count: 3 }], body: "this_s+=a<0?-a:a", localVars: [], thisVars: ["this_s"] },
  post: { args: [], localVars: [], thisVars: ["this_s"], body: "return this_s" },
  funcName: "norm1"
});

exports.sup = compile({
  args: ["array"],
  pre: { body: "this_h=-Infinity",
    args: [],
    thisVars: ["this_h"],
    localVars: [] },
  body: { body: "if(_inline_1_arg0_>this_h)this_h=_inline_1_arg0_",
    args: [{ "name": "_inline_1_arg0_", "lvalue": false, "rvalue": true, "count": 2 }],
    thisVars: ["this_h"],
    localVars: [] },
  post: { body: "return this_h",
    args: [],
    thisVars: ["this_h"],
    localVars: [] }
});

exports.inf = compile({
  args: ["array"],
  pre: { body: "this_h=Infinity",
    args: [],
    thisVars: ["this_h"],
    localVars: [] },
  body: { body: "if(_inline_1_arg0_<this_h)this_h=_inline_1_arg0_",
    args: [{ "name": "_inline_1_arg0_", "lvalue": false, "rvalue": true, "count": 2 }],
    thisVars: ["this_h"],
    localVars: [] },
  post: { body: "return this_h",
    args: [],
    thisVars: ["this_h"],
    localVars: [] }
});

exports.argmin = compile({
  args: ["index", "array", "shape"],
  pre: {
    body: "{this_v=Infinity;this_i=_inline_0_arg2_.slice(0)}",
    args: [{ name: "_inline_0_arg0_", lvalue: false, rvalue: false, count: 0 }, { name: "_inline_0_arg1_", lvalue: false, rvalue: false, count: 0 }, { name: "_inline_0_arg2_", lvalue: false, rvalue: true, count: 1 }],
    thisVars: ["this_i", "this_v"],
    localVars: [] },
  body: {
    body: "{if(_inline_1_arg1_<this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}",
    args: [{ name: "_inline_1_arg0_", lvalue: false, rvalue: true, count: 2 }, { name: "_inline_1_arg1_", lvalue: false, rvalue: true, count: 2 }],
    thisVars: ["this_i", "this_v"],
    localVars: ["_inline_1_k"] },
  post: {
    body: "{return this_i}",
    args: [],
    thisVars: ["this_i"],
    localVars: [] }
});

exports.argmax = compile({
  args: ["index", "array", "shape"],
  pre: {
    body: "{this_v=-Infinity;this_i=_inline_0_arg2_.slice(0)}",
    args: [{ name: "_inline_0_arg0_", lvalue: false, rvalue: false, count: 0 }, { name: "_inline_0_arg1_", lvalue: false, rvalue: false, count: 0 }, { name: "_inline_0_arg2_", lvalue: false, rvalue: true, count: 1 }],
    thisVars: ["this_i", "this_v"],
    localVars: [] },
  body: {
    body: "{if(_inline_1_arg1_>this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}",
    args: [{ name: "_inline_1_arg0_", lvalue: false, rvalue: true, count: 2 }, { name: "_inline_1_arg1_", lvalue: false, rvalue: true, count: 2 }],
    thisVars: ["this_i", "this_v"],
    localVars: ["_inline_1_k"] },
  post: {
    body: "{return this_i}",
    args: [],
    thisVars: ["this_i"],
    localVars: [] }
});

exports.random = makeOp({
  args: ["array"],
  pre: { args: [], body: "this_f=Math.random", thisVars: ["this_f"] },
  body: { args: ["a"], body: "a=this_f()", thisVars: ["this_f"] },
  funcName: "random"
});

exports.assign = makeOp({
  args: ["array", "array"],
  body: { args: ["a", "b"], body: "a=b" },
  funcName: "assign" });

exports.assigns = makeOp({
  args: ["array", "scalar"],
  body: { args: ["a", "b"], body: "a=b" },
  funcName: "assigns" });

exports.equals = compile({
  args: ["array", "array"],
  pre: EmptyProc,
  body: { args: [{ name: "x", lvalue: false, rvalue: true, count: 1 }, { name: "y", lvalue: false, rvalue: true, count: 1 }],
    body: "if(x!==y){return false}",
    localVars: [],
    thisVars: [] },
  post: { args: [], localVars: [], thisVars: [], body: "return true" },
  funcName: "equals"
});

},{"cwise-compiler":54}],114:[function(require,module,exports){
var iota = require("iota-array");
var isBuffer = require("is-buffer");

var hasTypedArrays = typeof Float64Array !== "undefined";

function compare1st(a, b) {
  return a[0] - b[0];
}

function order() {
  var stride = this.stride;
  var terms = new Array(stride.length);
  var i;
  for (i = 0; i < terms.length; ++i) {
    terms[i] = [Math.abs(stride[i]), i];
  }
  terms.sort(compare1st);
  var result = new Array(terms.length);
  for (i = 0; i < result.length; ++i) {
    result[i] = terms[i][1];
  }
  return result;
}

function compileConstructor(dtype, dimension) {
  var className = ["View", dimension, "d", dtype].join("");
  if (dimension < 0) {
    className = "View_Nil" + dtype;
  }
  var useGetters = dtype === "generic";

  if (dimension === -1) {
    //Special case for trivial arrays
    var code = "function " + className + "(a){this.data=a;};\
var proto=" + className + ".prototype;\
proto.dtype='" + dtype + "';\
proto.index=function(){return -1};\
proto.size=0;\
proto.dimension=-1;\
proto.shape=proto.stride=proto.order=[];\
proto.lo=proto.hi=proto.transpose=proto.step=\
function(){return new " + className + "(this.data);};\
proto.get=proto.set=function(){};\
proto.pick=function(){return null};\
return function construct_" + className + "(a){return new " + className + "(a);}";
    var procedure = new Function(code);
    return procedure();
  } else if (dimension === 0) {
    //Special case for 0d arrays
    var code = "function " + className + "(a,d) {\
this.data = a;\
this.offset = d\
};\
var proto=" + className + ".prototype;\
proto.dtype='" + dtype + "';\
proto.index=function(){return this.offset};\
proto.dimension=0;\
proto.size=1;\
proto.shape=\
proto.stride=\
proto.order=[];\
proto.lo=\
proto.hi=\
proto.transpose=\
proto.step=function " + className + "_copy() {\
return new " + className + "(this.data,this.offset)\
};\
proto.pick=function " + className + "_pick(){\
return TrivialArray(this.data);\
};\
proto.valueOf=proto.get=function " + className + "_get(){\
return " + (useGetters ? "this.data.get(this.offset)" : "this.data[this.offset]") + "};\
proto.set=function " + className + "_set(v){\
return " + (useGetters ? "this.data.set(this.offset,v)" : "this.data[this.offset]=v") + "\
};\
return function construct_" + className + "(a,b,c,d){return new " + className + "(a,d)}";
    var procedure = new Function("TrivialArray", code);
    return procedure(CACHED_CONSTRUCTORS[dtype][0]);
  }

  var code = ["'use strict'"];

  //Create constructor for view
  var indices = iota(dimension);
  var args = indices.map(function (i) {
    return "i" + i;
  });
  var index_str = "this.offset+" + indices.map(function (i) {
    return "this.stride[" + i + "]*i" + i;
  }).join("+");
  var shapeArg = indices.map(function (i) {
    return "b" + i;
  }).join(",");
  var strideArg = indices.map(function (i) {
    return "c" + i;
  }).join(",");
  code.push("function " + className + "(a," + shapeArg + "," + strideArg + ",d){this.data=a", "this.shape=[" + shapeArg + "]", "this.stride=[" + strideArg + "]", "this.offset=d|0}", "var proto=" + className + ".prototype", "proto.dtype='" + dtype + "'", "proto.dimension=" + dimension

  //view.size:
  );code.push("Object.defineProperty(proto,'size',{get:function " + className + "_size(){\
return " + indices.map(function (i) {
    return "this.shape[" + i + "]";
  }).join("*"), "}})"

  //view.order:
  );if (dimension === 1) {
    code.push("proto.order=[0]");
  } else {
    code.push("Object.defineProperty(proto,'order',{get:");
    if (dimension < 4) {
      code.push("function " + className + "_order(){");
      if (dimension === 2) {
        code.push("return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})");
      } else if (dimension === 3) {
        code.push("var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);\
if(s0>s1){\
if(s1>s2){\
return [2,1,0];\
}else if(s0>s2){\
return [1,2,0];\
}else{\
return [1,0,2];\
}\
}else if(s0>s2){\
return [2,0,1];\
}else if(s2>s1){\
return [0,1,2];\
}else{\
return [0,2,1];\
}}})");
      }
    } else {
      code.push("ORDER})");
    }
  }

  //view.set(i0, ..., v):
  code.push("proto.set=function " + className + "_set(" + args.join(",") + ",v){");
  if (useGetters) {
    code.push("return this.data.set(" + index_str + ",v)}");
  } else {
    code.push("return this.data[" + index_str + "]=v}");
  }

  //view.get(i0, ...):
  code.push("proto.get=function " + className + "_get(" + args.join(",") + "){");
  if (useGetters) {
    code.push("return this.data.get(" + index_str + ")}");
  } else {
    code.push("return this.data[" + index_str + "]}");
  }

  //view.index:
  code.push("proto.index=function " + className + "_index(", args.join(), "){return " + index_str + "}"

  //view.hi():
  );code.push("proto.hi=function " + className + "_hi(" + args.join(",") + "){return new " + className + "(this.data," + indices.map(function (i) {
    return ["(typeof i", i, "!=='number'||i", i, "<0)?this.shape[", i, "]:i", i, "|0"].join("");
  }).join(",") + "," + indices.map(function (i) {
    return "this.stride[" + i + "]";
  }).join(",") + ",this.offset)}"

  //view.lo():
  );var a_vars = indices.map(function (i) {
    return "a" + i + "=this.shape[" + i + "]";
  });
  var c_vars = indices.map(function (i) {
    return "c" + i + "=this.stride[" + i + "]";
  });
  code.push("proto.lo=function " + className + "_lo(" + args.join(",") + "){var b=this.offset,d=0," + a_vars.join(",") + "," + c_vars.join(","));
  for (var i = 0; i < dimension; ++i) {
    code.push("if(typeof i" + i + "==='number'&&i" + i + ">=0){\
d=i" + i + "|0;\
b+=c" + i + "*d;\
a" + i + "-=d}");
  }
  code.push("return new " + className + "(this.data," + indices.map(function (i) {
    return "a" + i;
  }).join(",") + "," + indices.map(function (i) {
    return "c" + i;
  }).join(",") + ",b)}"

  //view.step():
  );code.push("proto.step=function " + className + "_step(" + args.join(",") + "){var " + indices.map(function (i) {
    return "a" + i + "=this.shape[" + i + "]";
  }).join(",") + "," + indices.map(function (i) {
    return "b" + i + "=this.stride[" + i + "]";
  }).join(",") + ",c=this.offset,d=0,ceil=Math.ceil");
  for (var i = 0; i < dimension; ++i) {
    code.push("if(typeof i" + i + "==='number'){\
d=i" + i + "|0;\
if(d<0){\
c+=b" + i + "*(a" + i + "-1);\
a" + i + "=ceil(-a" + i + "/d)\
}else{\
a" + i + "=ceil(a" + i + "/d)\
}\
b" + i + "*=d\
}");
  }
  code.push("return new " + className + "(this.data," + indices.map(function (i) {
    return "a" + i;
  }).join(",") + "," + indices.map(function (i) {
    return "b" + i;
  }).join(",") + ",c)}"

  //view.transpose():
  );var tShape = new Array(dimension);
  var tStride = new Array(dimension);
  for (var i = 0; i < dimension; ++i) {
    tShape[i] = "a[i" + i + "]";
    tStride[i] = "b[i" + i + "]";
  }
  code.push("proto.transpose=function " + className + "_transpose(" + args + "){" + args.map(function (n, idx) {
    return n + "=(" + n + "===undefined?" + idx + ":" + n + "|0)";
  }).join(";"), "var a=this.shape,b=this.stride;return new " + className + "(this.data," + tShape.join(",") + "," + tStride.join(",") + ",this.offset)}"

  //view.pick():
  );code.push("proto.pick=function " + className + "_pick(" + args + "){var a=[],b=[],c=this.offset");
  for (var i = 0; i < dimension; ++i) {
    code.push("if(typeof i" + i + "==='number'&&i" + i + ">=0){c=(c+this.stride[" + i + "]*i" + i + ")|0}else{a.push(this.shape[" + i + "]);b.push(this.stride[" + i + "])}");
  }
  code.push("var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}"

  //Add return statement
  );code.push("return function construct_" + className + "(data,shape,stride,offset){return new " + className + "(data," + indices.map(function (i) {
    return "shape[" + i + "]";
  }).join(",") + "," + indices.map(function (i) {
    return "stride[" + i + "]";
  }).join(",") + ",offset)}"

  //Compile procedure
  );var procedure = new Function("CTOR_LIST", "ORDER", code.join("\n"));
  return procedure(CACHED_CONSTRUCTORS[dtype], order);
}

function arrayDType(data) {
  if (isBuffer(data)) {
    return "buffer";
  }
  if (hasTypedArrays) {
    switch (Object.prototype.toString.call(data)) {
      case "[object Float64Array]":
        return "float64";
      case "[object Float32Array]":
        return "float32";
      case "[object Int8Array]":
        return "int8";
      case "[object Int16Array]":
        return "int16";
      case "[object Int32Array]":
        return "int32";
      case "[object Uint8Array]":
        return "uint8";
      case "[object Uint16Array]":
        return "uint16";
      case "[object Uint32Array]":
        return "uint32";
      case "[object Uint8ClampedArray]":
        return "uint8_clamped";
    }
  }
  if (Array.isArray(data)) {
    return "array";
  }
  return "generic";
}

var CACHED_CONSTRUCTORS = {
  "float32": [],
  "float64": [],
  "int8": [],
  "int16": [],
  "int32": [],
  "uint8": [],
  "uint16": [],
  "uint32": [],
  "array": [],
  "uint8_clamped": [],
  "buffer": [],
  "generic": []
};(function () {
  for (var id in CACHED_CONSTRUCTORS) {
    CACHED_CONSTRUCTORS[id].push(compileConstructor(id, -1));
  }
});

function wrappedNDArrayCtor(data, shape, stride, offset) {
  if (data === undefined) {
    var ctor = CACHED_CONSTRUCTORS.array[0];
    return ctor([]);
  } else if (typeof data === "number") {
    data = [data];
  }
  if (shape === undefined) {
    shape = [data.length];
  }
  var d = shape.length;
  if (stride === undefined) {
    stride = new Array(d);
    for (var i = d - 1, sz = 1; i >= 0; --i) {
      stride[i] = sz;
      sz *= shape[i];
    }
  }
  if (offset === undefined) {
    offset = 0;
    for (var i = 0; i < d; ++i) {
      if (stride[i] < 0) {
        offset -= (shape[i] - 1) * stride[i];
      }
    }
  }
  var dtype = arrayDType(data);
  var ctor_list = CACHED_CONSTRUCTORS[dtype];
  while (ctor_list.length <= d + 1) {
    ctor_list.push(compileConstructor(dtype, ctor_list.length - 1));
  }
  var ctor = ctor_list[d + 1];
  return ctor(data, shape, stride, offset);
}

module.exports = wrappedNDArrayCtor;

},{"iota-array":106,"is-buffer":107}],115:[function(require,module,exports){
"use strict";

var doubleBits = require("double-bits");

var SMALLEST_DENORM = Math.pow(2, -1074);
var UINT_MAX = -1 >>> 0;

module.exports = nextafter;

function nextafter(x, y) {
  if (isNaN(x) || isNaN(y)) {
    return NaN;
  }
  if (x === y) {
    return x;
  }
  if (x === 0) {
    if (y < 0) {
      return -SMALLEST_DENORM;
    } else {
      return SMALLEST_DENORM;
    }
  }
  var hi = doubleBits.hi(x);
  var lo = doubleBits.lo(x);
  if (y > x === x > 0) {
    if (lo === UINT_MAX) {
      hi += 1;
      lo = 0;
    } else {
      lo += 1;
    }
  } else {
    if (lo === 0) {
      lo = UINT_MAX;
      hi -= 1;
    } else {
      lo -= 1;
    }
  }
  return doubleBits.pack(lo, hi);
}

},{"double-bits":58}],116:[function(require,module,exports){
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/

'use strict';
/* eslint-disable no-unused-vars */

var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc'); // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

},{}],117:[function(require,module,exports){
/*!
 * pad-left <https://github.com/jonschlinkert/pad-left>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT license.
 */

'use strict';

var repeat = require('repeat-string');

module.exports = function padLeft(str, num, ch) {
  ch = typeof ch !== 'undefined' ? ch + '' : ' ';
  return repeat(ch, num) + str;
};

},{"repeat-string":134}],118:[function(require,module,exports){
module.exports = function parseUnit(str, out) {
    if (!out) out = [0, ''];

    str = String(str);
    var num = parseFloat(str, 10);
    out[0] = num;
    out[1] = str.match(/[\d.\-\+]*\s*(.*)/)[1] || '';
    return out;
};

},{}],119:[function(require,module,exports){
(function (process){
// Generated by CoffeeScript 1.12.2
(function () {
  var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;

  if (typeof performance !== "undefined" && performance !== null && performance.now) {
    module.exports = function () {
      return performance.now();
    };
  } else if (typeof process !== "undefined" && process !== null && process.hrtime) {
    module.exports = function () {
      return (getNanoSeconds() - nodeLoadTime) / 1e6;
    };
    hrtime = process.hrtime;
    getNanoSeconds = function () {
      var hr;
      hr = hrtime();
      return hr[0] * 1e9 + hr[1];
    };
    moduleLoadTime = getNanoSeconds();
    upTime = process.uptime() * 1e9;
    nodeLoadTime = moduleLoadTime - upTime;
  } else if (Date.now) {
    module.exports = function () {
      return Date.now() - loadTime;
    };
    loadTime = Date.now();
  } else {
    module.exports = function () {
      return new Date().getTime() - loadTime;
    };
    loadTime = new Date().getTime();
  }
}).call(this);



}).call(this,require('_process'))
},{"_process":127}],120:[function(require,module,exports){
"use strict";

module.exports = permutationSign;

var BRUTE_FORCE_CUTOFF = 32;

var pool = require("typedarray-pool");

function permutationSign(p) {
  var n = p.length;
  if (n < BRUTE_FORCE_CUTOFF) {
    //Use quadratic algorithm for small n
    var sgn = 1;
    for (var i = 0; i < n; ++i) {
      for (var j = 0; j < i; ++j) {
        if (p[i] < p[j]) {
          sgn = -sgn;
        } else if (p[i] === p[j]) {
          return 0;
        }
      }
    }
    return sgn;
  } else {
    //Otherwise use linear time algorithm
    var visited = pool.mallocUint8(n);
    for (var i = 0; i < n; ++i) {
      visited[i] = 0;
    }
    var sgn = 1;
    for (var i = 0; i < n; ++i) {
      if (!visited[i]) {
        var count = 1;
        visited[i] = 1;
        for (var j = p[i]; j !== i; j = p[j]) {
          if (visited[j]) {
            pool.freeUint8(visited);
            return 0;
          }
          count += 1;
          visited[j] = 1;
        }
        if (!(count & 1)) {
          sgn = -sgn;
        }
      }
    }
    pool.freeUint8(visited);
    return sgn;
  }
}

},{"typedarray-pool":162}],121:[function(require,module,exports){
"use strict";

var pool = require("typedarray-pool");
var inverse = require("invert-permutation");

function rank(permutation) {
  var n = permutation.length;
  switch (n) {
    case 0:
    case 1:
      return 0;
    case 2:
      return permutation[1];
    default:
      break;
  }
  var p = pool.mallocUint32(n);
  var pinv = pool.mallocUint32(n);
  var r = 0,
      s,
      t,
      i;
  inverse(permutation, pinv);
  for (i = 0; i < n; ++i) {
    p[i] = permutation[i];
  }
  for (i = n - 1; i > 0; --i) {
    t = pinv[i];
    s = p[i];
    p[i] = p[t];
    p[t] = s;
    pinv[i] = pinv[s];
    pinv[s] = t;
    r = (r + s) * i;
  }
  pool.freeUint32(pinv);
  pool.freeUint32(p);
  return r;
}

function unrank(n, r, p) {
  switch (n) {
    case 0:
      if (p) {
        return p;
      }
      return [];
    case 1:
      if (p) {
        p[0] = 0;
        return p;
      } else {
        return [0];
      }
    case 2:
      if (p) {
        if (r) {
          p[0] = 0;
          p[1] = 1;
        } else {
          p[0] = 1;
          p[1] = 0;
        }
        return p;
      } else {
        return r ? [0, 1] : [1, 0];
      }
    default:
      break;
  }
  p = p || new Array(n);
  var s,
      t,
      i,
      nf = 1;
  p[0] = 0;
  for (i = 1; i < n; ++i) {
    p[i] = i;
    nf = nf * i | 0;
  }
  for (i = n - 1; i > 0; --i) {
    s = r / nf | 0;
    r = r - s * nf | 0;
    nf = nf / i | 0;
    t = p[i] | 0;
    p[i] = p[s] | 0;
    p[s] = t | 0;
  }
  return p;
}

exports.rank = rank;
exports.unrank = unrank;

},{"invert-permutation":105,"typedarray-pool":162}],122:[function(require,module,exports){
"use strict";

module.exports = planarDual;

var compareAngle = require("compare-angle");

function planarDual(cells, positions) {

  var numVertices = positions.length | 0;
  var numEdges = cells.length;
  var adj = [new Array(numVertices), new Array(numVertices)];
  for (var i = 0; i < numVertices; ++i) {
    adj[0][i] = [];
    adj[1][i] = [];
  }
  for (var i = 0; i < numEdges; ++i) {
    var c = cells[i];
    adj[0][c[0]].push(c);
    adj[1][c[1]].push(c);
  }

  var cycles = [];

  //Add isolated vertices as trivial case
  for (var i = 0; i < numVertices; ++i) {
    if (adj[0][i].length + adj[1][i].length === 0) {
      cycles.push([i]);
    }
  }

  //Remove a half edge
  function cut(c, i) {
    var a = adj[i][c[i]];
    a.splice(a.indexOf(c), 1);
  }

  //Find next vertex and cut edge
  function next(a, b, noCut) {
    var nextCell, nextVertex, nextDir;
    for (var i = 0; i < 2; ++i) {
      if (adj[i][b].length > 0) {
        nextCell = adj[i][b][0];
        nextDir = i;
        break;
      }
    }
    nextVertex = nextCell[nextDir ^ 1];

    for (var dir = 0; dir < 2; ++dir) {
      var nbhd = adj[dir][b];
      for (var k = 0; k < nbhd.length; ++k) {
        var e = nbhd[k];
        var p = e[dir ^ 1];
        var cmp = compareAngle(positions[a], positions[b], positions[nextVertex], positions[p]);
        if (cmp > 0) {
          nextCell = e;
          nextVertex = p;
          nextDir = dir;
        }
      }
    }
    if (noCut) {
      return nextVertex;
    }
    if (nextCell) {
      cut(nextCell, nextDir);
    }
    return nextVertex;
  }

  function extractCycle(v, dir) {
    var e0 = adj[dir][v][0];
    var cycle = [v];
    cut(e0, dir);
    var u = e0[dir ^ 1];
    var d0 = dir;
    while (true) {
      while (u !== v) {
        cycle.push(u);
        u = next(cycle[cycle.length - 2], u, false);
      }
      if (adj[0][v].length + adj[1][v].length === 0) {
        break;
      }
      var a = cycle[cycle.length - 1];
      var b = v;
      var c = cycle[1];
      var d = next(a, b, true);
      if (compareAngle(positions[a], positions[b], positions[c], positions[d]) < 0) {
        break;
      }
      cycle.push(v);
      u = next(a, b);
    }
    return cycle;
  }

  function shouldGlue(pcycle, ncycle) {
    return ncycle[1] === ncycle[ncycle.length - 1];
  }

  for (var i = 0; i < numVertices; ++i) {
    for (var j = 0; j < 2; ++j) {
      var pcycle = [];
      while (adj[j][i].length > 0) {
        var ni = adj[0][i].length;
        var ncycle = extractCycle(i, j);
        if (shouldGlue(pcycle, ncycle)) {
          //Glue together trivial cycles
          pcycle.push.apply(pcycle, ncycle);
        } else {
          if (pcycle.length > 0) {
            cycles.push(pcycle);
          }
          pcycle = ncycle;
        }
      }
      if (pcycle.length > 0) {
        cycles.push(pcycle);
      }
    }
  }

  //Combine paths and loops together
  return cycles;
}

},{"compare-angle":52}],123:[function(require,module,exports){
'use strict';

module.exports = trimLeaves;

var e2a = require('edges-to-adjacency-list');

function trimLeaves(edges, positions) {
  var adj = e2a(edges, positions.length);
  var live = new Array(positions.length);
  var nbhd = new Array(positions.length);

  var dead = [];
  for (var i = 0; i < positions.length; ++i) {
    var count = adj[i].length;
    nbhd[i] = count;
    live[i] = true;
    if (count <= 1) {
      dead.push(i);
    }
  }

  while (dead.length > 0) {
    var v = dead.pop();
    live[v] = false;
    var n = adj[v];
    for (var i = 0; i < n.length; ++i) {
      var u = n[i];
      if (--nbhd[u] === 0) {
        dead.push(u);
      }
    }
  }

  var newIndex = new Array(positions.length);
  var npositions = [];
  for (var i = 0; i < positions.length; ++i) {
    if (live[i]) {
      var v = npositions.length;
      newIndex[i] = v;
      npositions.push(positions[i]);
    } else {
      newIndex[i] = -1;
    }
  }

  var nedges = [];
  for (var i = 0; i < edges.length; ++i) {
    var e = edges[i];
    if (live[e[0]] && live[e[1]]) {
      nedges.push([newIndex[e[0]], newIndex[e[1]]]);
    }
  }

  return [nedges, npositions];
}

},{"edges-to-adjacency-list":60}],124:[function(require,module,exports){
'use strict';

module.exports = planarGraphToPolyline;

var e2a = require('edges-to-adjacency-list');
var planarDual = require('planar-dual');
var preprocessPolygon = require('point-in-big-polygon');
var twoProduct = require('two-product');
var robustSum = require('robust-sum');
var uniq = require('uniq');
var trimLeaves = require('./lib/trim-leaves');

function makeArray(length, fill) {
  var result = new Array(length);
  for (var i = 0; i < length; ++i) {
    result[i] = fill;
  }
  return result;
}

function makeArrayOfArrays(length) {
  var result = new Array(length);
  for (var i = 0; i < length; ++i) {
    result[i] = [];
  }
  return result;
}

function planarGraphToPolyline(edges, positions) {

  //Trim leaves
  var result = trimLeaves(edges, positions);
  edges = result[0];
  positions = result[1];

  var numVertices = positions.length;
  var numEdges = edges.length;

  //Calculate adjacency list, check manifold
  var adj = e2a(edges, positions.length);
  for (var i = 0; i < numVertices; ++i) {
    if (adj[i].length % 2 === 1) {
      throw new Error('planar-graph-to-polyline: graph must be manifold');
    }
  }

  //Get faces
  var faces = planarDual(edges, positions

  //Check orientation of a polygon using exact arithmetic
  );function ccw(c) {
    var n = c.length;
    var area = [0];
    for (var j = 0; j < n; ++j) {
      var a = positions[c[j]];
      var b = positions[c[(j + 1) % n]];
      var t00 = twoProduct(-a[0], a[1]);
      var t01 = twoProduct(-a[0], b[1]);
      var t10 = twoProduct(b[0], a[1]);
      var t11 = twoProduct(b[0], b[1]);
      area = robustSum(area, robustSum(robustSum(t00, t01), robustSum(t10, t11)));
    }
    return area[area.length - 1] > 0;
  }

  //Extract all clockwise faces
  faces = faces.filter(ccw

  //Detect which loops are contained in one another to handle parent-of relation
  );var numFaces = faces.length;
  var parent = new Array(numFaces);
  var containment = new Array(numFaces);
  for (var i = 0; i < numFaces; ++i) {
    parent[i] = i;
    var row = new Array(numFaces);
    var loopVertices = faces[i].map(function (v) {
      return positions[v];
    });
    var pmc = preprocessPolygon([loopVertices]);
    var count = 0;
    outer: for (var j = 0; j < numFaces; ++j) {
      row[j] = 0;
      if (i === j) {
        continue;
      }
      var c = faces[j];
      var n = c.length;
      for (var k = 0; k < n; ++k) {
        var d = pmc(positions[c[k]]);
        if (d !== 0) {
          if (d < 0) {
            row[j] = 1;
            count += 1;
          }
          continue outer;
        }
      }
      row[j] = 1;
      count += 1;
    }
    containment[i] = [count, i, row];
  }
  containment.sort(function (a, b) {
    return b[0] - a[0];
  });
  for (var i = 0; i < numFaces; ++i) {
    var row = containment[i];
    var idx = row[1];
    var children = row[2];
    for (var j = 0; j < numFaces; ++j) {
      if (children[j]) {
        parent[j] = idx;
      }
    }
  }

  //Initialize face adjacency list
  var fadj = makeArrayOfArrays(numFaces);
  for (var i = 0; i < numFaces; ++i) {
    fadj[i].push(parent[i]);
    fadj[parent[i]].push(i);
  }

  //Build adjacency matrix for edges
  var edgeAdjacency = {};
  var internalVertices = makeArray(numVertices, false);
  for (var i = 0; i < numFaces; ++i) {
    var c = faces[i];
    var n = c.length;
    for (var j = 0; j < n; ++j) {
      var a = c[j];
      var b = c[(j + 1) % n];
      var key = Math.min(a, b) + ":" + Math.max(a, b);
      if (key in edgeAdjacency) {
        var neighbor = edgeAdjacency[key];
        fadj[neighbor].push(i);
        fadj[i].push(neighbor);
        internalVertices[a] = internalVertices[b] = true;
      } else {
        edgeAdjacency[key] = i;
      }
    }
  }

  function sharedBoundary(c) {
    var n = c.length;
    for (var i = 0; i < n; ++i) {
      if (!internalVertices[c[i]]) {
        return false;
      }
    }
    return true;
  }

  var toVisit = [];
  var parity = makeArray(numFaces, -1);
  for (var i = 0; i < numFaces; ++i) {
    if (parent[i] === i && !sharedBoundary(faces[i])) {
      toVisit.push(i);
      parity[i] = 0;
    } else {
      parity[i] = -1;
    }
  }

  //Using face adjacency, classify faces as in/out
  var result = [];
  while (toVisit.length > 0) {
    var top = toVisit.pop();
    var nbhd = fadj[top];
    uniq(nbhd, function (a, b) {
      return a - b;
    });
    var nnbhr = nbhd.length;
    var p = parity[top];
    var polyline;
    if (p === 0) {
      var c = faces[top];
      polyline = [c];
    }
    for (var i = 0; i < nnbhr; ++i) {
      var f = nbhd[i];
      if (parity[f] >= 0) {
        continue;
      }
      parity[f] = p ^ 1;
      toVisit.push(f);
      if (p === 0) {
        var c = faces[f];
        if (!sharedBoundary(c)) {
          c.reverse();
          polyline.push(c);
        }
      }
    }
    if (p === 0) {
      result.push(polyline);
    }
  }

  return result;
}

},{"./lib/trim-leaves":123,"edges-to-adjacency-list":60,"planar-dual":122,"point-in-big-polygon":126,"robust-sum":142,"two-product":159,"uniq":164}],125:[function(require,module,exports){
arguments[4][104][0].apply(exports,arguments)
},{"dup":104}],126:[function(require,module,exports){
module.exports = preprocessPolygon;

var orient = require('robust-orientation')[3];
var makeSlabs = require('slab-decomposition');
var makeIntervalTree = require('interval-tree-1d');
var bsearch = require('binary-search-bounds');

function visitInterval() {
  return true;
}

function intervalSearch(table) {
  return function (x, y) {
    var tree = table[x];
    if (tree) {
      return !!tree.queryPoint(y, visitInterval);
    }
    return false;
  };
}

function buildVerticalIndex(segments) {
  var table = {};
  for (var i = 0; i < segments.length; ++i) {
    var s = segments[i];
    var x = s[0][0];
    var y0 = s[0][1];
    var y1 = s[1][1];
    var p = [Math.min(y0, y1), Math.max(y0, y1)];
    if (x in table) {
      table[x].push(p);
    } else {
      table[x] = [p];
    }
  }
  var intervalTable = {};
  var keys = Object.keys(table);
  for (var i = 0; i < keys.length; ++i) {
    var segs = table[keys[i]];
    intervalTable[keys[i]] = makeIntervalTree(segs);
  }
  return intervalSearch(intervalTable);
}

function buildSlabSearch(slabs, coordinates) {
  return function (p) {
    var bucket = bsearch.le(coordinates, p[0]);
    if (bucket < 0) {
      return 1;
    }
    var root = slabs[bucket];
    if (!root) {
      if (bucket > 0 && coordinates[bucket] === p[0]) {
        root = slabs[bucket - 1];
      } else {
        return 1;
      }
    }
    var lastOrientation = 1;
    while (root) {
      var s = root.key;
      var o = orient(p, s[0], s[1]);
      if (s[0][0] < s[1][0]) {
        if (o < 0) {
          root = root.left;
        } else if (o > 0) {
          lastOrientation = -1;
          root = root.right;
        } else {
          return 0;
        }
      } else {
        if (o > 0) {
          root = root.left;
        } else if (o < 0) {
          lastOrientation = 1;
          root = root.right;
        } else {
          return 0;
        }
      }
    }
    return lastOrientation;
  };
}

function classifyEmpty(p) {
  return 1;
}

function createClassifyVertical(testVertical) {
  return function classify(p) {
    if (testVertical(p[0], p[1])) {
      return 0;
    }
    return 1;
  };
}

function createClassifyPointDegen(testVertical, testNormal) {
  return function classify(p) {
    if (testVertical(p[0], p[1])) {
      return 0;
    }
    return testNormal(p);
  };
}

function preprocessPolygon(loops) {
  //Compute number of loops
  var numLoops = loops.length;

  //Unpack segments
  var segments = [];
  var vsegments = [];
  var ptr = 0;
  for (var i = 0; i < numLoops; ++i) {
    var loop = loops[i];
    var numVertices = loop.length;
    for (var s = numVertices - 1, t = 0; t < numVertices; s = t++) {
      var a = loop[s];
      var b = loop[t];
      if (a[0] === b[0]) {
        vsegments.push([a, b]);
      } else {
        segments.push([a, b]);
      }
    }
  }

  //Degenerate case: All loops are empty
  if (segments.length === 0) {
    if (vsegments.length === 0) {
      return classifyEmpty;
    } else {
      return createClassifyVertical(buildVerticalIndex(vsegments));
    }
  }

  //Build slab decomposition
  var slabs = makeSlabs(segments);
  var testSlab = buildSlabSearch(slabs.slabs, slabs.coordinates);

  if (vsegments.length === 0) {
    return testSlab;
  } else {
    return createClassifyPointDegen(buildVerticalIndex(vsegments), testSlab);
  }
}

},{"binary-search-bounds":125,"interval-tree-1d":103,"robust-orientation":137,"slab-decomposition":149}],127:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
    return [];
};

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () {
    return '/';
};
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function () {
    return 0;
};

},{}],128:[function(require,module,exports){
(function (global){
var now = require('performance-now'),
    root = typeof window === 'undefined' ? global : window,
    vendors = ['moz', 'webkit'],
    suffix = 'AnimationFrame',
    raf = root['request' + suffix],
    caf = root['cancel' + suffix] || root['cancelRequest' + suffix];

for (var i = 0; !raf && i < vendors.length; i++) {
  raf = root[vendors[i] + 'Request' + suffix];
  caf = root[vendors[i] + 'Cancel' + suffix] || root[vendors[i] + 'CancelRequest' + suffix];
}

// Some versions of FF have rAF but not cAF
if (!raf || !caf) {
  var last = 0,
      id = 0,
      queue = [],
      frameDuration = 1000 / 60;

  raf = function (callback) {
    if (queue.length === 0) {
      var _now = now(),
          next = Math.max(0, frameDuration - (_now - last));
      last = next + _now;
      setTimeout(function () {
        var cp = queue.slice(0
        // Clear queue here to prevent
        // callbacks from appending listeners
        // to the current frame's queue
        );queue.length = 0;
        for (var i = 0; i < cp.length; i++) {
          if (!cp[i].cancelled) {
            try {
              cp[i].callback(last);
            } catch (e) {
              setTimeout(function () {
                throw e;
              }, 0);
            }
          }
        }
      }, Math.round(next));
    }
    queue.push({
      handle: ++id,
      callback: callback,
      cancelled: false
    });
    return id;
  };

  caf = function (handle) {
    for (var i = 0; i < queue.length; i++) {
      if (queue[i].handle === handle) {
        queue[i].cancelled = true;
      }
    }
  };
}

module.exports = function (fn) {
  // Wrap in a new function to prevent
  // `cancel` potentially being assigned
  // to the native rAF function
  return raf.call(root, fn);
};
module.exports.cancel = function () {
  caf.apply(root, arguments);
};
module.exports.polyfill = function () {
  root.requestAnimationFrame = raf;
  root.cancelAnimationFrame = caf;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"performance-now":119}],129:[function(require,module,exports){
'use strict';

var bnadd = require('big-rat/add');

module.exports = add;

function add(a, b) {
  var n = a.length;
  var r = new Array(n);
  for (var i = 0; i < n; ++i) {
    r[i] = bnadd(a[i], b[i]);
  }
  return r;
}

},{"big-rat/add":10}],130:[function(require,module,exports){
'use strict';

module.exports = float2rat;

var rat = require('big-rat');

function float2rat(v) {
  var result = new Array(v.length);
  for (var i = 0; i < v.length; ++i) {
    result[i] = rat(v[i]);
  }
  return result;
}

},{"big-rat":13}],131:[function(require,module,exports){
'use strict';

var rat = require('big-rat');
var mul = require('big-rat/mul');

module.exports = muls;

function muls(a, x) {
  var s = rat(x);
  var n = a.length;
  var r = new Array(n);
  for (var i = 0; i < n; ++i) {
    r[i] = mul(a[i], s);
  }
  return r;
}

},{"big-rat":13,"big-rat/mul":22}],132:[function(require,module,exports){
'use strict';

var bnsub = require('big-rat/sub');

module.exports = sub;

function sub(a, b) {
  var n = a.length;
  var r = new Array(n);
  for (var i = 0; i < n; ++i) {
    r[i] = bnsub(a[i], b[i]);
  }
  return r;
}

},{"big-rat/sub":24}],133:[function(require,module,exports){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.createREGL = factory();
})(this, function () {
  'use strict';

  var arrayTypes = {
    "[object Int8Array]": 5120,
    "[object Int16Array]": 5122,
    "[object Int32Array]": 5124,
    "[object Uint8Array]": 5121,
    "[object Uint8ClampedArray]": 5121,
    "[object Uint16Array]": 5123,
    "[object Uint32Array]": 5125,
    "[object Float32Array]": 5126,
    "[object Float64Array]": 5121,
    "[object ArrayBuffer]": 5121
  };

  var isTypedArray = function (x) {
    return Object.prototype.toString.call(x) in arrayTypes;
  };

  var extend = function (base, opts) {
    var keys = Object.keys(opts);
    for (var i = 0; i < keys.length; ++i) {
      base[keys[i]] = opts[keys[i]];
    }
    return base;
  };

  // Error checking and parameter validation.
  //
  // Statements for the form `check.someProcedure(...)` get removed by
  // a browserify transform for optimized/minified bundles.
  //
  /* globals btoa */
  // only used for extracting shader names.  if btoa not present, then errors
  // will be slightly crappier
  function decodeB64(str) {
    if (typeof btoa !== 'undefined') {
      return btoa(str);
    }
    return 'base64:' + str;
  }

  function raise(message) {
    var error = new Error('(regl) ' + message);
    console.error(error);
    throw error;
  }

  function check(pred, message) {
    if (!pred) {
      raise(message);
    }
  }

  function encolon(message) {
    if (message) {
      return ': ' + message;
    }
    return '';
  }

  function checkParameter(param, possibilities, message) {
    if (!(param in possibilities)) {
      raise('unknown parameter (' + param + ')' + encolon(message) + '. possible values: ' + Object.keys(possibilities).join());
    }
  }

  function checkIsTypedArray(data, message) {
    if (!isTypedArray(data)) {
      raise('invalid parameter type' + encolon(message) + '. must be a typed array');
    }
  }

  function checkTypeOf(value, type, message) {
    if (typeof value !== type) {
      raise('invalid parameter type' + encolon(message) + '. expected ' + type + ', got ' + typeof value);
    }
  }

  function checkNonNegativeInt(value, message) {
    if (!(value >= 0 && (value | 0) === value)) {
      raise('invalid parameter type, (' + value + ')' + encolon(message) + '. must be a nonnegative integer');
    }
  }

  function checkOneOf(value, list, message) {
    if (list.indexOf(value) < 0) {
      raise('invalid value' + encolon(message) + '. must be one of: ' + list);
    }
  }

  var constructorKeys = ['gl', 'canvas', 'container', 'attributes', 'pixelRatio', 'extensions', 'optionalExtensions', 'profile', 'onDone'];

  function checkConstructor(obj) {
    Object.keys(obj).forEach(function (key) {
      if (constructorKeys.indexOf(key) < 0) {
        raise('invalid regl constructor argument "' + key + '". must be one of ' + constructorKeys);
      }
    });
  }

  function leftPad(str, n) {
    str = str + '';
    while (str.length < n) {
      str = ' ' + str;
    }
    return str;
  }

  function ShaderFile() {
    this.name = 'unknown';
    this.lines = [];
    this.index = {};
    this.hasErrors = false;
  }

  function ShaderLine(number, line) {
    this.number = number;
    this.line = line;
    this.errors = [];
  }

  function ShaderError(fileNumber, lineNumber, message) {
    this.file = fileNumber;
    this.line = lineNumber;
    this.message = message;
  }

  function guessCommand() {
    var error = new Error();
    var stack = (error.stack || error).toString();
    var pat = /compileProcedure.*\n\s*at.*\((.*)\)/.exec(stack);
    if (pat) {
      return pat[1];
    }
    var pat2 = /compileProcedure.*\n\s*at\s+(.*)(\n|$)/.exec(stack);
    if (pat2) {
      return pat2[1];
    }
    return 'unknown';
  }

  function guessCallSite() {
    var error = new Error();
    var stack = (error.stack || error).toString();
    var pat = /at REGLCommand.*\n\s+at.*\((.*)\)/.exec(stack);
    if (pat) {
      return pat[1];
    }
    var pat2 = /at REGLCommand.*\n\s+at\s+(.*)\n/.exec(stack);
    if (pat2) {
      return pat2[1];
    }
    return 'unknown';
  }

  function parseSource(source, command) {
    var lines = source.split('\n');
    var lineNumber = 1;
    var fileNumber = 0;
    var files = {
      unknown: new ShaderFile(),
      0: new ShaderFile()
    };
    files.unknown.name = files[0].name = command || guessCommand();
    files.unknown.lines.push(new ShaderLine(0, ''));
    for (var i = 0; i < lines.length; ++i) {
      var line = lines[i];
      var parts = /^\s*\#\s*(\w+)\s+(.+)\s*$/.exec(line);
      if (parts) {
        switch (parts[1]) {
          case 'line':
            var lineNumberInfo = /(\d+)(\s+\d+)?/.exec(parts[2]);
            if (lineNumberInfo) {
              lineNumber = lineNumberInfo[1] | 0;
              if (lineNumberInfo[2]) {
                fileNumber = lineNumberInfo[2] | 0;
                if (!(fileNumber in files)) {
                  files[fileNumber] = new ShaderFile();
                }
              }
            }
            break;
          case 'define':
            var nameInfo = /SHADER_NAME(_B64)?\s+(.*)$/.exec(parts[2]);
            if (nameInfo) {
              files[fileNumber].name = nameInfo[1] ? decodeB64(nameInfo[2]) : nameInfo[2];
            }
            break;
        }
      }
      files[fileNumber].lines.push(new ShaderLine(lineNumber++, line));
    }
    Object.keys(files).forEach(function (fileNumber) {
      var file = files[fileNumber];
      file.lines.forEach(function (line) {
        file.index[line.number] = line;
      });
    });
    return files;
  }

  function parseErrorLog(errLog) {
    var result = [];
    errLog.split('\n').forEach(function (errMsg) {
      if (errMsg.length < 5) {
        return;
      }
      var parts = /^ERROR\:\s+(\d+)\:(\d+)\:\s*(.*)$/.exec(errMsg);
      if (parts) {
        result.push(new ShaderError(parts[1] | 0, parts[2] | 0, parts[3].trim()));
      } else if (errMsg.length > 0) {
        result.push(new ShaderError('unknown', 0, errMsg));
      }
    });
    return result;
  }

  function annotateFiles(files, errors) {
    errors.forEach(function (error) {
      var file = files[error.file];
      if (file) {
        var line = file.index[error.line];
        if (line) {
          line.errors.push(error);
          file.hasErrors = true;
          return;
        }
      }
      files.unknown.hasErrors = true;
      files.unknown.lines[0].errors.push(error);
    });
  }

  function checkShaderError(gl, shader, source, type, command) {
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      var errLog = gl.getShaderInfoLog(shader);
      var typeName = type === gl.FRAGMENT_SHADER ? 'fragment' : 'vertex';
      checkCommandType(source, 'string', typeName + ' shader source must be a string', command);
      var files = parseSource(source, command);
      var errors = parseErrorLog(errLog);
      annotateFiles(files, errors);

      Object.keys(files).forEach(function (fileNumber) {
        var file = files[fileNumber];
        if (!file.hasErrors) {
          return;
        }

        var strings = [''];
        var styles = [''];

        function push(str, style) {
          strings.push(str);
          styles.push(style || '');
        }

        push('file number ' + fileNumber + ': ' + file.name + '\n', 'color:red;text-decoration:underline;font-weight:bold');

        file.lines.forEach(function (line) {
          if (line.errors.length > 0) {
            push(leftPad(line.number, 4) + '|  ', 'background-color:yellow; font-weight:bold');
            push(line.line + '\n', 'color:red; background-color:yellow; font-weight:bold');

            // try to guess token
            var offset = 0;
            line.errors.forEach(function (error) {
              var message = error.message;
              var token = /^\s*\'(.*)\'\s*\:\s*(.*)$/.exec(message);
              if (token) {
                var tokenPat = token[1];
                message = token[2];
                switch (tokenPat) {
                  case 'assign':
                    tokenPat = '=';
                    break;
                }
                offset = Math.max(line.line.indexOf(tokenPat, offset), 0);
              } else {
                offset = 0;
              }

              push(leftPad('| ', 6));
              push(leftPad('^^^', offset + 3) + '\n', 'font-weight:bold');
              push(leftPad('| ', 6));
              push(message + '\n', 'font-weight:bold');
            });
            push(leftPad('| ', 6) + '\n');
          } else {
            push(leftPad(line.number, 4) + '|  ');
            push(line.line + '\n', 'color:red');
          }
        });
        if (typeof document !== 'undefined') {
          styles[0] = strings.join('%c');
          console.log.apply(console, styles);
        } else {
          console.log(strings.join(''));
        }
      });

      check.raise('Error compiling ' + typeName + ' shader, ' + files[0].name);
    }
  }

  function checkLinkError(gl, program, fragShader, vertShader, command) {
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      var errLog = gl.getProgramInfoLog(program);
      var fragParse = parseSource(fragShader, command);
      var vertParse = parseSource(vertShader, command);

      var header = 'Error linking program with vertex shader, "' + vertParse[0].name + '", and fragment shader "' + fragParse[0].name + '"';

      if (typeof document !== 'undefined') {
        console.log('%c' + header + '\n%c' + errLog, 'color:red;text-decoration:underline;font-weight:bold', 'color:red');
      } else {
        console.log(header + '\n' + errLog);
      }
      check.raise(header);
    }
  }

  function saveCommandRef(object) {
    object._commandRef = guessCommand();
  }

  function saveDrawCommandInfo(opts, uniforms, attributes, stringStore) {
    saveCommandRef(opts);

    function id(str) {
      if (str) {
        return stringStore.id(str);
      }
      return 0;
    }
    opts._fragId = id(opts.static.frag);
    opts._vertId = id(opts.static.vert);

    function addProps(dict, set) {
      Object.keys(set).forEach(function (u) {
        dict[stringStore.id(u)] = true;
      });
    }

    var uniformSet = opts._uniformSet = {};
    addProps(uniformSet, uniforms.static);
    addProps(uniformSet, uniforms.dynamic);

    var attributeSet = opts._attributeSet = {};
    addProps(attributeSet, attributes.static);
    addProps(attributeSet, attributes.dynamic);

    opts._hasCount = 'count' in opts.static || 'count' in opts.dynamic || 'elements' in opts.static || 'elements' in opts.dynamic;
  }

  function commandRaise(message, command) {
    var callSite = guessCallSite();
    raise(message + ' in command ' + (command || guessCommand()) + (callSite === 'unknown' ? '' : ' called from ' + callSite));
  }

  function checkCommand(pred, message, command) {
    if (!pred) {
      commandRaise(message, command || guessCommand());
    }
  }

  function checkParameterCommand(param, possibilities, message, command) {
    if (!(param in possibilities)) {
      commandRaise('unknown parameter (' + param + ')' + encolon(message) + '. possible values: ' + Object.keys(possibilities).join(), command || guessCommand());
    }
  }

  function checkCommandType(value, type, message, command) {
    if (typeof value !== type) {
      commandRaise('invalid parameter type' + encolon(message) + '. expected ' + type + ', got ' + typeof value, command || guessCommand());
    }
  }

  function checkOptional(block) {
    block();
  }

  function checkFramebufferFormat(attachment, texFormats, rbFormats) {
    if (attachment.texture) {
      checkOneOf(attachment.texture._texture.internalformat, texFormats, 'unsupported texture format for attachment');
    } else {
      checkOneOf(attachment.renderbuffer._renderbuffer.format, rbFormats, 'unsupported renderbuffer format for attachment');
    }
  }

  var GL_CLAMP_TO_EDGE = 0x812F;

  var GL_NEAREST = 0x2600;
  var GL_NEAREST_MIPMAP_NEAREST = 0x2700;
  var GL_LINEAR_MIPMAP_NEAREST = 0x2701;
  var GL_NEAREST_MIPMAP_LINEAR = 0x2702;
  var GL_LINEAR_MIPMAP_LINEAR = 0x2703;

  var GL_BYTE = 5120;
  var GL_UNSIGNED_BYTE = 5121;
  var GL_SHORT = 5122;
  var GL_UNSIGNED_SHORT = 5123;
  var GL_INT = 5124;
  var GL_UNSIGNED_INT = 5125;
  var GL_FLOAT = 5126;

  var GL_UNSIGNED_SHORT_4_4_4_4 = 0x8033;
  var GL_UNSIGNED_SHORT_5_5_5_1 = 0x8034;
  var GL_UNSIGNED_SHORT_5_6_5 = 0x8363;
  var GL_UNSIGNED_INT_24_8_WEBGL = 0x84FA;

  var GL_HALF_FLOAT_OES = 0x8D61;

  var TYPE_SIZE = {};

  TYPE_SIZE[GL_BYTE] = TYPE_SIZE[GL_UNSIGNED_BYTE] = 1;

  TYPE_SIZE[GL_SHORT] = TYPE_SIZE[GL_UNSIGNED_SHORT] = TYPE_SIZE[GL_HALF_FLOAT_OES] = TYPE_SIZE[GL_UNSIGNED_SHORT_5_6_5] = TYPE_SIZE[GL_UNSIGNED_SHORT_4_4_4_4] = TYPE_SIZE[GL_UNSIGNED_SHORT_5_5_5_1] = 2;

  TYPE_SIZE[GL_INT] = TYPE_SIZE[GL_UNSIGNED_INT] = TYPE_SIZE[GL_FLOAT] = TYPE_SIZE[GL_UNSIGNED_INT_24_8_WEBGL] = 4;

  function pixelSize(type, channels) {
    if (type === GL_UNSIGNED_SHORT_5_5_5_1 || type === GL_UNSIGNED_SHORT_4_4_4_4 || type === GL_UNSIGNED_SHORT_5_6_5) {
      return 2;
    } else if (type === GL_UNSIGNED_INT_24_8_WEBGL) {
      return 4;
    } else {
      return TYPE_SIZE[type] * channels;
    }
  }

  function isPow2(v) {
    return !(v & v - 1) && !!v;
  }

  function checkTexture2D(info, mipData, limits) {
    var i;
    var w = mipData.width;
    var h = mipData.height;
    var c = mipData.channels;

    // Check texture shape
    check(w > 0 && w <= limits.maxTextureSize && h > 0 && h <= limits.maxTextureSize, 'invalid texture shape');

    // check wrap mode
    if (info.wrapS !== GL_CLAMP_TO_EDGE || info.wrapT !== GL_CLAMP_TO_EDGE) {
      check(isPow2(w) && isPow2(h), 'incompatible wrap mode for texture, both width and height must be power of 2');
    }

    if (mipData.mipmask === 1) {
      if (w !== 1 && h !== 1) {
        check(info.minFilter !== GL_NEAREST_MIPMAP_NEAREST && info.minFilter !== GL_NEAREST_MIPMAP_LINEAR && info.minFilter !== GL_LINEAR_MIPMAP_NEAREST && info.minFilter !== GL_LINEAR_MIPMAP_LINEAR, 'min filter requires mipmap');
      }
    } else {
      // texture must be power of 2
      check(isPow2(w) && isPow2(h), 'texture must be a square power of 2 to support mipmapping');
      check(mipData.mipmask === (w << 1) - 1, 'missing or incomplete mipmap data');
    }

    if (mipData.type === GL_FLOAT) {
      if (limits.extensions.indexOf('oes_texture_float_linear') < 0) {
        check(info.minFilter === GL_NEAREST && info.magFilter === GL_NEAREST, 'filter not supported, must enable oes_texture_float_linear');
      }
      check(!info.genMipmaps, 'mipmap generation not supported with float textures');
    }

    // check image complete
    var mipimages = mipData.images;
    for (i = 0; i < 16; ++i) {
      if (mipimages[i]) {
        var mw = w >> i;
        var mh = h >> i;
        check(mipData.mipmask & 1 << i, 'missing mipmap data');

        var img = mipimages[i];

        check(img.width === mw && img.height === mh, 'invalid shape for mip images');

        check(img.format === mipData.format && img.internalformat === mipData.internalformat && img.type === mipData.type, 'incompatible type for mip image');

        if (img.compressed) {
          // TODO: check size for compressed images
        } else if (img.data) {
          // check(img.data.byteLength === mw * mh *
          // Math.max(pixelSize(img.type, c), img.unpackAlignment),
          var rowSize = Math.ceil(pixelSize(img.type, c) * mw / img.unpackAlignment) * img.unpackAlignment;
          check(img.data.byteLength === rowSize * mh, 'invalid data for image, buffer size is inconsistent with image format');
        } else if (img.element) {
          // TODO: check element can be loaded
        } else if (img.copy) {
          // TODO: check compatible format and type
        }
      } else if (!info.genMipmaps) {
        check((mipData.mipmask & 1 << i) === 0, 'extra mipmap data');
      }
    }

    if (mipData.compressed) {
      check(!info.genMipmaps, 'mipmap generation for compressed images not supported');
    }
  }

  function checkTextureCube(texture, info, faces, limits) {
    var w = texture.width;
    var h = texture.height;
    var c = texture.channels;

    // Check texture shape
    check(w > 0 && w <= limits.maxTextureSize && h > 0 && h <= limits.maxTextureSize, 'invalid texture shape');
    check(w === h, 'cube map must be square');
    check(info.wrapS === GL_CLAMP_TO_EDGE && info.wrapT === GL_CLAMP_TO_EDGE, 'wrap mode not supported by cube map');

    for (var i = 0; i < faces.length; ++i) {
      var face = faces[i];
      check(face.width === w && face.height === h, 'inconsistent cube map face shape');

      if (info.genMipmaps) {
        check(!face.compressed, 'can not generate mipmap for compressed textures');
        check(face.mipmask === 1, 'can not specify mipmaps and generate mipmaps');
      } else {
        // TODO: check mip and filter mode
      }

      var mipmaps = face.images;
      for (var j = 0; j < 16; ++j) {
        var img = mipmaps[j];
        if (img) {
          var mw = w >> j;
          var mh = h >> j;
          check(face.mipmask & 1 << j, 'missing mipmap data');
          check(img.width === mw && img.height === mh, 'invalid shape for mip images');
          check(img.format === texture.format && img.internalformat === texture.internalformat && img.type === texture.type, 'incompatible type for mip image');

          if (img.compressed) {
            // TODO: check size for compressed images
          } else if (img.data) {
            check(img.data.byteLength === mw * mh * Math.max(pixelSize(img.type, c), img.unpackAlignment), 'invalid data for image, buffer size is inconsistent with image format');
          } else if (img.element) {
            // TODO: check element can be loaded
          } else if (img.copy) {
            // TODO: check compatible format and type
          }
        }
      }
    }
  }

  var check$1 = extend(check, {
    optional: checkOptional,
    raise: raise,
    commandRaise: commandRaise,
    command: checkCommand,
    parameter: checkParameter,
    commandParameter: checkParameterCommand,
    constructor: checkConstructor,
    type: checkTypeOf,
    commandType: checkCommandType,
    isTypedArray: checkIsTypedArray,
    nni: checkNonNegativeInt,
    oneOf: checkOneOf,
    shaderError: checkShaderError,
    linkError: checkLinkError,
    callSite: guessCallSite,
    saveCommandRef: saveCommandRef,
    saveDrawInfo: saveDrawCommandInfo,
    framebufferFormat: checkFramebufferFormat,
    guessCommand: guessCommand,
    texture2D: checkTexture2D,
    textureCube: checkTextureCube
  });

  var VARIABLE_COUNTER = 0;

  var DYN_FUNC = 0;

  function DynamicVariable(type, data) {
    this.id = VARIABLE_COUNTER++;
    this.type = type;
    this.data = data;
  }

  function escapeStr(str) {
    return str.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
  }

  function splitParts(str) {
    if (str.length === 0) {
      return [];
    }

    var firstChar = str.charAt(0);
    var lastChar = str.charAt(str.length - 1);

    if (str.length > 1 && firstChar === lastChar && (firstChar === '"' || firstChar === "'")) {
      return ['"' + escapeStr(str.substr(1, str.length - 2)) + '"'];
    }

    var parts = /\[(false|true|null|\d+|'[^']*'|"[^"]*")\]/.exec(str);
    if (parts) {
      return splitParts(str.substr(0, parts.index)).concat(splitParts(parts[1])).concat(splitParts(str.substr(parts.index + parts[0].length)));
    }

    var subparts = str.split('.');
    if (subparts.length === 1) {
      return ['"' + escapeStr(str) + '"'];
    }

    var result = [];
    for (var i = 0; i < subparts.length; ++i) {
      result = result.concat(splitParts(subparts[i]));
    }
    return result;
  }

  function toAccessorString(str) {
    return '[' + splitParts(str).join('][') + ']';
  }

  function defineDynamic(type, data) {
    return new DynamicVariable(type, toAccessorString(data + ''));
  }

  function isDynamic(x) {
    return typeof x === 'function' && !x._reglType || x instanceof DynamicVariable;
  }

  function unbox(x, path) {
    if (typeof x === 'function') {
      return new DynamicVariable(DYN_FUNC, x);
    }
    return x;
  }

  var dynamic = {
    DynamicVariable: DynamicVariable,
    define: defineDynamic,
    isDynamic: isDynamic,
    unbox: unbox,
    accessor: toAccessorString
  };

  /* globals requestAnimationFrame, cancelAnimationFrame */
  var raf = {
    next: typeof requestAnimationFrame === 'function' ? function (cb) {
      return requestAnimationFrame(cb);
    } : function (cb) {
      return setTimeout(cb, 16);
    },
    cancel: typeof cancelAnimationFrame === 'function' ? function (raf) {
      return cancelAnimationFrame(raf);
    } : clearTimeout
  };

  /* globals performance */
  var clock = typeof performance !== 'undefined' && performance.now ? function () {
    return performance.now();
  } : function () {
    return +new Date();
  };

  function createStringStore() {
    var stringIds = { '': 0 };
    var stringValues = [''];
    return {
      id: function (str) {
        var result = stringIds[str];
        if (result) {
          return result;
        }
        result = stringIds[str] = stringValues.length;
        stringValues.push(str);
        return result;
      },

      str: function (id) {
        return stringValues[id];
      }
    };
  }

  // Context and canvas creation helper functions
  function createCanvas(element, onDone, pixelRatio) {
    var canvas = document.createElement('canvas');
    extend(canvas.style, {
      border: 0,
      margin: 0,
      padding: 0,
      top: 0,
      left: 0
    });
    element.appendChild(canvas);

    if (element === document.body) {
      canvas.style.position = 'absolute';
      extend(element.style, {
        margin: 0,
        padding: 0
      });
    }

    function resize() {
      var w = window.innerWidth;
      var h = window.innerHeight;
      if (element !== document.body) {
        var bounds = element.getBoundingClientRect();
        w = bounds.right - bounds.left;
        h = bounds.bottom - bounds.top;
      }
      canvas.width = pixelRatio * w;
      canvas.height = pixelRatio * h;
      extend(canvas.style, {
        width: w + 'px',
        height: h + 'px'
      });
    }

    window.addEventListener('resize', resize, false);

    function onDestroy() {
      window.removeEventListener('resize', resize);
      element.removeChild(canvas);
    }

    resize();

    return {
      canvas: canvas,
      onDestroy: onDestroy
    };
  }

  function createContext(canvas, contexAttributes) {
    function get(name) {
      try {
        return canvas.getContext(name, contexAttributes);
      } catch (e) {
        return null;
      }
    }
    return get('webgl') || get('experimental-webgl') || get('webgl-experimental');
  }

  function isHTMLElement(obj) {
    return typeof obj.nodeName === 'string' && typeof obj.appendChild === 'function' && typeof obj.getBoundingClientRect === 'function';
  }

  function isWebGLContext(obj) {
    return typeof obj.drawArrays === 'function' || typeof obj.drawElements === 'function';
  }

  function parseExtensions(input) {
    if (typeof input === 'string') {
      return input.split();
    }
    check$1(Array.isArray(input), 'invalid extension array');
    return input;
  }

  function getElement(desc) {
    if (typeof desc === 'string') {
      check$1(typeof document !== 'undefined', 'not supported outside of DOM');
      return document.querySelector(desc);
    }
    return desc;
  }

  function parseArgs(args_) {
    var args = args_ || {};
    var element, container, canvas, gl;
    var contextAttributes = {};
    var extensions = [];
    var optionalExtensions = [];
    var pixelRatio = typeof window === 'undefined' ? 1 : window.devicePixelRatio;
    var profile = false;
    var onDone = function (err) {
      if (err) {
        check$1.raise(err);
      }
    };
    var onDestroy = function () {};
    if (typeof args === 'string') {
      check$1(typeof document !== 'undefined', 'selector queries only supported in DOM enviroments');
      element = document.querySelector(args);
      check$1(element, 'invalid query string for element');
    } else if (typeof args === 'object') {
      if (isHTMLElement(args)) {
        element = args;
      } else if (isWebGLContext(args)) {
        gl = args;
        canvas = gl.canvas;
      } else {
        check$1.constructor(args);
        if ('gl' in args) {
          gl = args.gl;
        } else if ('canvas' in args) {
          canvas = getElement(args.canvas);
        } else if ('container' in args) {
          container = getElement(args.container);
        }
        if ('attributes' in args) {
          contextAttributes = args.attributes;
          check$1.type(contextAttributes, 'object', 'invalid context attributes');
        }
        if ('extensions' in args) {
          extensions = parseExtensions(args.extensions);
        }
        if ('optionalExtensions' in args) {
          optionalExtensions = parseExtensions(args.optionalExtensions);
        }
        if ('onDone' in args) {
          check$1.type(args.onDone, 'function', 'invalid or missing onDone callback');
          onDone = args.onDone;
        }
        if ('profile' in args) {
          profile = !!args.profile;
        }
        if ('pixelRatio' in args) {
          pixelRatio = +args.pixelRatio;
          check$1(pixelRatio > 0, 'invalid pixel ratio');
        }
      }
    } else {
      check$1.raise('invalid arguments to regl');
    }

    if (element) {
      if (element.nodeName.toLowerCase() === 'canvas') {
        canvas = element;
      } else {
        container = element;
      }
    }

    if (!gl) {
      if (!canvas) {
        check$1(typeof document !== 'undefined', 'must manually specify webgl context outside of DOM environments');
        var result = createCanvas(container || document.body, onDone, pixelRatio);
        if (!result) {
          return null;
        }
        canvas = result.canvas;
        onDestroy = result.onDestroy;
      }
      gl = createContext(canvas, contextAttributes);
    }

    if (!gl) {
      onDestroy();
      onDone('webgl not supported, try upgrading your browser or graphics drivers http://get.webgl.org');
      return null;
    }

    return {
      gl: gl,
      canvas: canvas,
      container: container,
      extensions: extensions,
      optionalExtensions: optionalExtensions,
      pixelRatio: pixelRatio,
      profile: profile,
      onDone: onDone,
      onDestroy: onDestroy
    };
  }

  function createExtensionCache(gl, config) {
    var extensions = {};

    function tryLoadExtension(name_) {
      check$1.type(name_, 'string', 'extension name must be string');
      var name = name_.toLowerCase();
      var ext;
      try {
        ext = extensions[name] = gl.getExtension(name);
      } catch (e) {}
      return !!ext;
    }

    for (var i = 0; i < config.extensions.length; ++i) {
      var name = config.extensions[i];
      if (!tryLoadExtension(name)) {
        config.onDestroy();
        config.onDone('"' + name + '" extension is not supported by the current WebGL context, try upgrading your system or a different browser');
        return null;
      }
    }

    config.optionalExtensions.forEach(tryLoadExtension);

    return {
      extensions: extensions,
      restore: function () {
        Object.keys(extensions).forEach(function (name) {
          if (!tryLoadExtension(name)) {
            throw new Error('(regl): error restoring extension ' + name);
          }
        });
      }
    };
  }

  var GL_SUBPIXEL_BITS = 0x0D50;
  var GL_RED_BITS = 0x0D52;
  var GL_GREEN_BITS = 0x0D53;
  var GL_BLUE_BITS = 0x0D54;
  var GL_ALPHA_BITS = 0x0D55;
  var GL_DEPTH_BITS = 0x0D56;
  var GL_STENCIL_BITS = 0x0D57;

  var GL_ALIASED_POINT_SIZE_RANGE = 0x846D;
  var GL_ALIASED_LINE_WIDTH_RANGE = 0x846E;

  var GL_MAX_TEXTURE_SIZE = 0x0D33;
  var GL_MAX_VIEWPORT_DIMS = 0x0D3A;
  var GL_MAX_VERTEX_ATTRIBS = 0x8869;
  var GL_MAX_VERTEX_UNIFORM_VECTORS = 0x8DFB;
  var GL_MAX_VARYING_VECTORS = 0x8DFC;
  var GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS = 0x8B4D;
  var GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS = 0x8B4C;
  var GL_MAX_TEXTURE_IMAGE_UNITS = 0x8872;
  var GL_MAX_FRAGMENT_UNIFORM_VECTORS = 0x8DFD;
  var GL_MAX_CUBE_MAP_TEXTURE_SIZE = 0x851C;
  var GL_MAX_RENDERBUFFER_SIZE = 0x84E8;

  var GL_VENDOR = 0x1F00;
  var GL_RENDERER = 0x1F01;
  var GL_VERSION = 0x1F02;
  var GL_SHADING_LANGUAGE_VERSION = 0x8B8C;

  var GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT = 0x84FF;

  var GL_MAX_COLOR_ATTACHMENTS_WEBGL = 0x8CDF;
  var GL_MAX_DRAW_BUFFERS_WEBGL = 0x8824;

  var wrapLimits = function (gl, extensions) {
    var maxAnisotropic = 1;
    if (extensions.ext_texture_filter_anisotropic) {
      maxAnisotropic = gl.getParameter(GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    }

    var maxDrawbuffers = 1;
    var maxColorAttachments = 1;
    if (extensions.webgl_draw_buffers) {
      maxDrawbuffers = gl.getParameter(GL_MAX_DRAW_BUFFERS_WEBGL);
      maxColorAttachments = gl.getParameter(GL_MAX_COLOR_ATTACHMENTS_WEBGL);
    }

    return {
      // drawing buffer bit depth
      colorBits: [gl.getParameter(GL_RED_BITS), gl.getParameter(GL_GREEN_BITS), gl.getParameter(GL_BLUE_BITS), gl.getParameter(GL_ALPHA_BITS)],
      depthBits: gl.getParameter(GL_DEPTH_BITS),
      stencilBits: gl.getParameter(GL_STENCIL_BITS),
      subpixelBits: gl.getParameter(GL_SUBPIXEL_BITS),

      // supported extensions
      extensions: Object.keys(extensions).filter(function (ext) {
        return !!extensions[ext];
      }),

      // max aniso samples
      maxAnisotropic: maxAnisotropic,

      // max draw buffers
      maxDrawbuffers: maxDrawbuffers,
      maxColorAttachments: maxColorAttachments,

      // point and line size ranges
      pointSizeDims: gl.getParameter(GL_ALIASED_POINT_SIZE_RANGE),
      lineWidthDims: gl.getParameter(GL_ALIASED_LINE_WIDTH_RANGE),
      maxViewportDims: gl.getParameter(GL_MAX_VIEWPORT_DIMS),
      maxCombinedTextureUnits: gl.getParameter(GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS),
      maxCubeMapSize: gl.getParameter(GL_MAX_CUBE_MAP_TEXTURE_SIZE),
      maxRenderbufferSize: gl.getParameter(GL_MAX_RENDERBUFFER_SIZE),
      maxTextureUnits: gl.getParameter(GL_MAX_TEXTURE_IMAGE_UNITS),
      maxTextureSize: gl.getParameter(GL_MAX_TEXTURE_SIZE),
      maxAttributes: gl.getParameter(GL_MAX_VERTEX_ATTRIBS),
      maxVertexUniforms: gl.getParameter(GL_MAX_VERTEX_UNIFORM_VECTORS),
      maxVertexTextureUnits: gl.getParameter(GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS),
      maxVaryingVectors: gl.getParameter(GL_MAX_VARYING_VECTORS),
      maxFragmentUniforms: gl.getParameter(GL_MAX_FRAGMENT_UNIFORM_VECTORS),

      // vendor info
      glsl: gl.getParameter(GL_SHADING_LANGUAGE_VERSION),
      renderer: gl.getParameter(GL_RENDERER),
      vendor: gl.getParameter(GL_VENDOR),
      version: gl.getParameter(GL_VERSION)
    };
  };

  function isNDArrayLike(obj) {
    return !!obj && typeof obj === 'object' && Array.isArray(obj.shape) && Array.isArray(obj.stride) && typeof obj.offset === 'number' && obj.shape.length === obj.stride.length && (Array.isArray(obj.data) || isTypedArray(obj.data));
  }

  var values = function (obj) {
    return Object.keys(obj).map(function (key) {
      return obj[key];
    });
  };

  function loop(n, f) {
    var result = Array(n);
    for (var i = 0; i < n; ++i) {
      result[i] = f(i);
    }
    return result;
  }

  var GL_BYTE$1 = 5120;
  var GL_UNSIGNED_BYTE$2 = 5121;
  var GL_SHORT$1 = 5122;
  var GL_UNSIGNED_SHORT$1 = 5123;
  var GL_INT$1 = 5124;
  var GL_UNSIGNED_INT$1 = 5125;
  var GL_FLOAT$2 = 5126;

  var bufferPool = loop(8, function () {
    return [];
  });

  function nextPow16(v) {
    for (var i = 16; i <= 1 << 28; i *= 16) {
      if (v <= i) {
        return i;
      }
    }
    return 0;
  }

  function log2(v) {
    var r, shift;
    r = (v > 0xFFFF) << 4;
    v >>>= r;
    shift = (v > 0xFF) << 3;
    v >>>= shift;r |= shift;
    shift = (v > 0xF) << 2;
    v >>>= shift;r |= shift;
    shift = (v > 0x3) << 1;
    v >>>= shift;r |= shift;
    return r | v >> 1;
  }

  function alloc(n) {
    var sz = nextPow16(n);
    var bin = bufferPool[log2(sz) >> 2];
    if (bin.length > 0) {
      return bin.pop();
    }
    return new ArrayBuffer(sz);
  }

  function free(buf) {
    bufferPool[log2(buf.byteLength) >> 2].push(buf);
  }

  function allocType(type, n) {
    var result = null;
    switch (type) {
      case GL_BYTE$1:
        result = new Int8Array(alloc(n), 0, n);
        break;
      case GL_UNSIGNED_BYTE$2:
        result = new Uint8Array(alloc(n), 0, n);
        break;
      case GL_SHORT$1:
        result = new Int16Array(alloc(2 * n), 0, n);
        break;
      case GL_UNSIGNED_SHORT$1:
        result = new Uint16Array(alloc(2 * n), 0, n);
        break;
      case GL_INT$1:
        result = new Int32Array(alloc(4 * n), 0, n);
        break;
      case GL_UNSIGNED_INT$1:
        result = new Uint32Array(alloc(4 * n), 0, n);
        break;
      case GL_FLOAT$2:
        result = new Float32Array(alloc(4 * n), 0, n);
        break;
      default:
        return null;
    }
    if (result.length !== n) {
      return result.subarray(0, n);
    }
    return result;
  }

  function freeType(array) {
    free(array.buffer);
  }

  var pool = {
    alloc: alloc,
    free: free,
    allocType: allocType,
    freeType: freeType
  };

  var flattenUtils = {
    shape: arrayShape$1,
    flatten: flattenArray
  };

  function flatten1D(array, nx, out) {
    for (var i = 0; i < nx; ++i) {
      out[i] = array[i];
    }
  }

  function flatten2D(array, nx, ny, out) {
    var ptr = 0;
    for (var i = 0; i < nx; ++i) {
      var row = array[i];
      for (var j = 0; j < ny; ++j) {
        out[ptr++] = row[j];
      }
    }
  }

  function flatten3D(array, nx, ny, nz, out, ptr_) {
    var ptr = ptr_;
    for (var i = 0; i < nx; ++i) {
      var row = array[i];
      for (var j = 0; j < ny; ++j) {
        var col = row[j];
        for (var k = 0; k < nz; ++k) {
          out[ptr++] = col[k];
        }
      }
    }
  }

  function flattenRec(array, shape, level, out, ptr) {
    var stride = 1;
    for (var i = level + 1; i < shape.length; ++i) {
      stride *= shape[i];
    }
    var n = shape[level];
    if (shape.length - level === 4) {
      var nx = shape[level + 1];
      var ny = shape[level + 2];
      var nz = shape[level + 3];
      for (i = 0; i < n; ++i) {
        flatten3D(array[i], nx, ny, nz, out, ptr);
        ptr += stride;
      }
    } else {
      for (i = 0; i < n; ++i) {
        flattenRec(array[i], shape, level + 1, out, ptr);
        ptr += stride;
      }
    }
  }

  function flattenArray(array, shape, type, out_) {
    var sz = 1;
    if (shape.length) {
      for (var i = 0; i < shape.length; ++i) {
        sz *= shape[i];
      }
    } else {
      sz = 0;
    }
    var out = out_ || pool.allocType(type, sz);
    switch (shape.length) {
      case 0:
        break;
      case 1:
        flatten1D(array, shape[0], out);
        break;
      case 2:
        flatten2D(array, shape[0], shape[1], out);
        break;
      case 3:
        flatten3D(array, shape[0], shape[1], shape[2], out, 0);
        break;
      default:
        flattenRec(array, shape, 0, out, 0);
    }
    return out;
  }

  function arrayShape$1(array_) {
    var shape = [];
    for (var array = array_; array.length; array = array[0]) {
      shape.push(array.length);
    }
    return shape;
  }

  var int8 = 5120;
  var int16 = 5122;
  var int32 = 5124;
  var uint8 = 5121;
  var uint16 = 5123;
  var uint32 = 5125;
  var float = 5126;
  var float32 = 5126;
  var glTypes = {
    int8: int8,
    int16: int16,
    int32: int32,
    uint8: uint8,
    uint16: uint16,
    uint32: uint32,
    float: float,
    float32: float32
  };

  var dynamic$1 = 35048;
  var stream = 35040;
  var usageTypes = {
    dynamic: dynamic$1,
    stream: stream,
    "static": 35044
  };

  var arrayFlatten = flattenUtils.flatten;
  var arrayShape = flattenUtils.shape;

  var GL_STATIC_DRAW = 0x88E4;
  var GL_STREAM_DRAW = 0x88E0;

  var GL_UNSIGNED_BYTE$1 = 5121;
  var GL_FLOAT$1 = 5126;

  var DTYPES_SIZES = [];
  DTYPES_SIZES[5120] = 1; // int8
  DTYPES_SIZES[5122] = 2; // int16
  DTYPES_SIZES[5124] = 4; // int32
  DTYPES_SIZES[5121] = 1; // uint8
  DTYPES_SIZES[5123] = 2; // uint16
  DTYPES_SIZES[5125] = 4; // uint32
  DTYPES_SIZES[5126] = 4; // float32

  function typedArrayCode(data) {
    return arrayTypes[Object.prototype.toString.call(data)] | 0;
  }

  function copyArray(out, inp) {
    for (var i = 0; i < inp.length; ++i) {
      out[i] = inp[i];
    }
  }

  function transpose(result, data, shapeX, shapeY, strideX, strideY, offset) {
    var ptr = 0;
    for (var i = 0; i < shapeX; ++i) {
      for (var j = 0; j < shapeY; ++j) {
        result[ptr++] = data[strideX * i + strideY * j + offset];
      }
    }
  }

  function wrapBufferState(gl, stats, config) {
    var bufferCount = 0;
    var bufferSet = {};

    function REGLBuffer(type) {
      this.id = bufferCount++;
      this.buffer = gl.createBuffer();
      this.type = type;
      this.usage = GL_STATIC_DRAW;
      this.byteLength = 0;
      this.dimension = 1;
      this.dtype = GL_UNSIGNED_BYTE$1;

      this.persistentData = null;

      if (config.profile) {
        this.stats = { size: 0 };
      }
    }

    REGLBuffer.prototype.bind = function () {
      gl.bindBuffer(this.type, this.buffer);
    };

    REGLBuffer.prototype.destroy = function () {
      destroy(this);
    };

    var streamPool = [];

    function createStream(type, data) {
      var buffer = streamPool.pop();
      if (!buffer) {
        buffer = new REGLBuffer(type);
      }
      buffer.bind();
      initBufferFromData(buffer, data, GL_STREAM_DRAW, 0, 1, false);
      return buffer;
    }

    function destroyStream(stream$$1) {
      streamPool.push(stream$$1);
    }

    function initBufferFromTypedArray(buffer, data, usage) {
      buffer.byteLength = data.byteLength;
      gl.bufferData(buffer.type, data, usage);
    }

    function initBufferFromData(buffer, data, usage, dtype, dimension, persist) {
      var shape;
      buffer.usage = usage;
      if (Array.isArray(data)) {
        buffer.dtype = dtype || GL_FLOAT$1;
        if (data.length > 0) {
          var flatData;
          if (Array.isArray(data[0])) {
            shape = arrayShape(data);
            var dim = 1;
            for (var i = 1; i < shape.length; ++i) {
              dim *= shape[i];
            }
            buffer.dimension = dim;
            flatData = arrayFlatten(data, shape, buffer.dtype);
            initBufferFromTypedArray(buffer, flatData, usage);
            if (persist) {
              buffer.persistentData = flatData;
            } else {
              pool.freeType(flatData);
            }
          } else if (typeof data[0] === 'number') {
            buffer.dimension = dimension;
            var typedData = pool.allocType(buffer.dtype, data.length);
            copyArray(typedData, data);
            initBufferFromTypedArray(buffer, typedData, usage);
            if (persist) {
              buffer.persistentData = typedData;
            } else {
              pool.freeType(typedData);
            }
          } else if (isTypedArray(data[0])) {
            buffer.dimension = data[0].length;
            buffer.dtype = dtype || typedArrayCode(data[0]) || GL_FLOAT$1;
            flatData = arrayFlatten(data, [data.length, data[0].length], buffer.dtype);
            initBufferFromTypedArray(buffer, flatData, usage);
            if (persist) {
              buffer.persistentData = flatData;
            } else {
              pool.freeType(flatData);
            }
          } else {
            check$1.raise('invalid buffer data');
          }
        }
      } else if (isTypedArray(data)) {
        buffer.dtype = dtype || typedArrayCode(data);
        buffer.dimension = dimension;
        initBufferFromTypedArray(buffer, data, usage);
        if (persist) {
          buffer.persistentData = new Uint8Array(new Uint8Array(data.buffer));
        }
      } else if (isNDArrayLike(data)) {
        shape = data.shape;
        var stride = data.stride;
        var offset = data.offset;

        var shapeX = 0;
        var shapeY = 0;
        var strideX = 0;
        var strideY = 0;
        if (shape.length === 1) {
          shapeX = shape[0];
          shapeY = 1;
          strideX = stride[0];
          strideY = 0;
        } else if (shape.length === 2) {
          shapeX = shape[0];
          shapeY = shape[1];
          strideX = stride[0];
          strideY = stride[1];
        } else {
          check$1.raise('invalid shape');
        }

        buffer.dtype = dtype || typedArrayCode(data.data) || GL_FLOAT$1;
        buffer.dimension = shapeY;

        var transposeData = pool.allocType(buffer.dtype, shapeX * shapeY);
        transpose(transposeData, data.data, shapeX, shapeY, strideX, strideY, offset);
        initBufferFromTypedArray(buffer, transposeData, usage);
        if (persist) {
          buffer.persistentData = transposeData;
        } else {
          pool.freeType(transposeData);
        }
      } else {
        check$1.raise('invalid buffer data');
      }
    }

    function destroy(buffer) {
      stats.bufferCount--;

      var handle = buffer.buffer;
      check$1(handle, 'buffer must not be deleted already');
      gl.deleteBuffer(handle);
      buffer.buffer = null;
      delete bufferSet[buffer.id];
    }

    function createBuffer(options, type, deferInit, persistent) {
      stats.bufferCount++;

      var buffer = new REGLBuffer(type);
      bufferSet[buffer.id] = buffer;

      function reglBuffer(options) {
        var usage = GL_STATIC_DRAW;
        var data = null;
        var byteLength = 0;
        var dtype = 0;
        var dimension = 1;
        if (Array.isArray(options) || isTypedArray(options) || isNDArrayLike(options)) {
          data = options;
        } else if (typeof options === 'number') {
          byteLength = options | 0;
        } else if (options) {
          check$1.type(options, 'object', 'buffer arguments must be an object, a number or an array');

          if ('data' in options) {
            check$1(data === null || Array.isArray(data) || isTypedArray(data) || isNDArrayLike(data), 'invalid data for buffer');
            data = options.data;
          }

          if ('usage' in options) {
            check$1.parameter(options.usage, usageTypes, 'invalid buffer usage');
            usage = usageTypes[options.usage];
          }

          if ('type' in options) {
            check$1.parameter(options.type, glTypes, 'invalid buffer type');
            dtype = glTypes[options.type];
          }

          if ('dimension' in options) {
            check$1.type(options.dimension, 'number', 'invalid dimension');
            dimension = options.dimension | 0;
          }

          if ('length' in options) {
            check$1.nni(byteLength, 'buffer length must be a nonnegative integer');
            byteLength = options.length | 0;
          }
        }

        buffer.bind();
        if (!data) {
          gl.bufferData(buffer.type, byteLength, usage);
          buffer.dtype = dtype || GL_UNSIGNED_BYTE$1;
          buffer.usage = usage;
          buffer.dimension = dimension;
          buffer.byteLength = byteLength;
        } else {
          initBufferFromData(buffer, data, usage, dtype, dimension, persistent);
        }

        if (config.profile) {
          buffer.stats.size = buffer.byteLength * DTYPES_SIZES[buffer.dtype];
        }

        return reglBuffer;
      }

      function setSubData(data, offset) {
        check$1(offset + data.byteLength <= buffer.byteLength, 'invalid buffer subdata call, buffer is too small. ' + ' Can\'t write data of size ' + data.byteLength + ' starting from offset ' + offset + ' to a buffer of size ' + buffer.byteLength);

        gl.bufferSubData(buffer.type, offset, data);
      }

      function subdata(data, offset_) {
        var offset = (offset_ || 0) | 0;
        var shape;
        buffer.bind();
        if (Array.isArray(data)) {
          if (data.length > 0) {
            if (typeof data[0] === 'number') {
              var converted = pool.allocType(buffer.dtype, data.length);
              copyArray(converted, data);
              setSubData(converted, offset);
              pool.freeType(converted);
            } else if (Array.isArray(data[0]) || isTypedArray(data[0])) {
              shape = arrayShape(data);
              var flatData = arrayFlatten(data, shape, buffer.dtype);
              setSubData(flatData, offset);
              pool.freeType(flatData);
            } else {
              check$1.raise('invalid buffer data');
            }
          }
        } else if (isTypedArray(data)) {
          setSubData(data, offset);
        } else if (isNDArrayLike(data)) {
          shape = data.shape;
          var stride = data.stride;

          var shapeX = 0;
          var shapeY = 0;
          var strideX = 0;
          var strideY = 0;
          if (shape.length === 1) {
            shapeX = shape[0];
            shapeY = 1;
            strideX = stride[0];
            strideY = 0;
          } else if (shape.length === 2) {
            shapeX = shape[0];
            shapeY = shape[1];
            strideX = stride[0];
            strideY = stride[1];
          } else {
            check$1.raise('invalid shape');
          }
          var dtype = Array.isArray(data.data) ? buffer.dtype : typedArrayCode(data.data);

          var transposeData = pool.allocType(dtype, shapeX * shapeY);
          transpose(transposeData, data.data, shapeX, shapeY, strideX, strideY, data.offset);
          setSubData(transposeData, offset);
          pool.freeType(transposeData);
        } else {
          check$1.raise('invalid data for buffer subdata');
        }
        return reglBuffer;
      }

      if (!deferInit) {
        reglBuffer(options);
      }

      reglBuffer._reglType = 'buffer';
      reglBuffer._buffer = buffer;
      reglBuffer.subdata = subdata;
      if (config.profile) {
        reglBuffer.stats = buffer.stats;
      }
      reglBuffer.destroy = function () {
        destroy(buffer);
      };

      return reglBuffer;
    }

    function restoreBuffers() {
      values(bufferSet).forEach(function (buffer) {
        buffer.buffer = gl.createBuffer();
        gl.bindBuffer(buffer.type, buffer.buffer);
        gl.bufferData(buffer.type, buffer.persistentData || buffer.byteLength, buffer.usage);
      });
    }

    if (config.profile) {
      stats.getTotalBufferSize = function () {
        var total = 0;
        // TODO: Right now, the streams are not part of the total count.
        Object.keys(bufferSet).forEach(function (key) {
          total += bufferSet[key].stats.size;
        });
        return total;
      };
    }

    return {
      create: createBuffer,

      createStream: createStream,
      destroyStream: destroyStream,

      clear: function () {
        values(bufferSet).forEach(destroy);
        streamPool.forEach(destroy);
      },

      getBuffer: function (wrapper) {
        if (wrapper && wrapper._buffer instanceof REGLBuffer) {
          return wrapper._buffer;
        }
        return null;
      },

      restore: restoreBuffers,

      _initBuffer: initBufferFromData
    };
  }

  var points = 0;
  var point = 0;
  var lines = 1;
  var line = 1;
  var triangles = 4;
  var triangle = 4;
  var primTypes = {
    points: points,
    point: point,
    lines: lines,
    line: line,
    triangles: triangles,
    triangle: triangle,
    "line loop": 2,
    "line strip": 3,
    "triangle strip": 5,
    "triangle fan": 6
  };

  var GL_POINTS = 0;
  var GL_LINES = 1;
  var GL_TRIANGLES = 4;

  var GL_BYTE$2 = 5120;
  var GL_UNSIGNED_BYTE$3 = 5121;
  var GL_SHORT$2 = 5122;
  var GL_UNSIGNED_SHORT$2 = 5123;
  var GL_INT$2 = 5124;
  var GL_UNSIGNED_INT$2 = 5125;

  var GL_ELEMENT_ARRAY_BUFFER = 34963;

  var GL_STREAM_DRAW$1 = 0x88E0;
  var GL_STATIC_DRAW$1 = 0x88E4;

  function wrapElementsState(gl, extensions, bufferState, stats) {
    var elementSet = {};
    var elementCount = 0;

    var elementTypes = {
      'uint8': GL_UNSIGNED_BYTE$3,
      'uint16': GL_UNSIGNED_SHORT$2
    };

    if (extensions.oes_element_index_uint) {
      elementTypes.uint32 = GL_UNSIGNED_INT$2;
    }

    function REGLElementBuffer(buffer) {
      this.id = elementCount++;
      elementSet[this.id] = this;
      this.buffer = buffer;
      this.primType = GL_TRIANGLES;
      this.vertCount = 0;
      this.type = 0;
    }

    REGLElementBuffer.prototype.bind = function () {
      this.buffer.bind();
    };

    var bufferPool = [];

    function createElementStream(data) {
      var result = bufferPool.pop();
      if (!result) {
        result = new REGLElementBuffer(bufferState.create(null, GL_ELEMENT_ARRAY_BUFFER, true, false)._buffer);
      }
      initElements(result, data, GL_STREAM_DRAW$1, -1, -1, 0, 0);
      return result;
    }

    function destroyElementStream(elements) {
      bufferPool.push(elements);
    }

    function initElements(elements, data, usage, prim, count, byteLength, type) {
      elements.buffer.bind();
      if (data) {
        var predictedType = type;
        if (!type && (!isTypedArray(data) || isNDArrayLike(data) && !isTypedArray(data.data))) {
          predictedType = extensions.oes_element_index_uint ? GL_UNSIGNED_INT$2 : GL_UNSIGNED_SHORT$2;
        }
        bufferState._initBuffer(elements.buffer, data, usage, predictedType, 3);
      } else {
        gl.bufferData(GL_ELEMENT_ARRAY_BUFFER, byteLength, usage);
        elements.buffer.dtype = dtype || GL_UNSIGNED_BYTE$3;
        elements.buffer.usage = usage;
        elements.buffer.dimension = 3;
        elements.buffer.byteLength = byteLength;
      }

      var dtype = type;
      if (!type) {
        switch (elements.buffer.dtype) {
          case GL_UNSIGNED_BYTE$3:
          case GL_BYTE$2:
            dtype = GL_UNSIGNED_BYTE$3;
            break;

          case GL_UNSIGNED_SHORT$2:
          case GL_SHORT$2:
            dtype = GL_UNSIGNED_SHORT$2;
            break;

          case GL_UNSIGNED_INT$2:
          case GL_INT$2:
            dtype = GL_UNSIGNED_INT$2;
            break;

          default:
            check$1.raise('unsupported type for element array');
        }
        elements.buffer.dtype = dtype;
      }
      elements.type = dtype;

      // Check oes_element_index_uint extension
      check$1(dtype !== GL_UNSIGNED_INT$2 || !!extensions.oes_element_index_uint, '32 bit element buffers not supported, enable oes_element_index_uint first');

      // try to guess default primitive type and arguments
      var vertCount = count;
      if (vertCount < 0) {
        vertCount = elements.buffer.byteLength;
        if (dtype === GL_UNSIGNED_SHORT$2) {
          vertCount >>= 1;
        } else if (dtype === GL_UNSIGNED_INT$2) {
          vertCount >>= 2;
        }
      }
      elements.vertCount = vertCount;

      // try to guess primitive type from cell dimension
      var primType = prim;
      if (prim < 0) {
        primType = GL_TRIANGLES;
        var dimension = elements.buffer.dimension;
        if (dimension === 1) primType = GL_POINTS;
        if (dimension === 2) primType = GL_LINES;
        if (dimension === 3) primType = GL_TRIANGLES;
      }
      elements.primType = primType;
    }

    function destroyElements(elements) {
      stats.elementsCount--;

      check$1(elements.buffer !== null, 'must not double destroy elements');
      delete elementSet[elements.id];
      elements.buffer.destroy();
      elements.buffer = null;
    }

    function createElements(options, persistent) {
      var buffer = bufferState.create(null, GL_ELEMENT_ARRAY_BUFFER, true);
      var elements = new REGLElementBuffer(buffer._buffer);
      stats.elementsCount++;

      function reglElements(options) {
        if (!options) {
          buffer();
          elements.primType = GL_TRIANGLES;
          elements.vertCount = 0;
          elements.type = GL_UNSIGNED_BYTE$3;
        } else if (typeof options === 'number') {
          buffer(options);
          elements.primType = GL_TRIANGLES;
          elements.vertCount = options | 0;
          elements.type = GL_UNSIGNED_BYTE$3;
        } else {
          var data = null;
          var usage = GL_STATIC_DRAW$1;
          var primType = -1;
          var vertCount = -1;
          var byteLength = 0;
          var dtype = 0;
          if (Array.isArray(options) || isTypedArray(options) || isNDArrayLike(options)) {
            data = options;
          } else {
            check$1.type(options, 'object', 'invalid arguments for elements');
            if ('data' in options) {
              data = options.data;
              check$1(Array.isArray(data) || isTypedArray(data) || isNDArrayLike(data), 'invalid data for element buffer');
            }
            if ('usage' in options) {
              check$1.parameter(options.usage, usageTypes, 'invalid element buffer usage');
              usage = usageTypes[options.usage];
            }
            if ('primitive' in options) {
              check$1.parameter(options.primitive, primTypes, 'invalid element buffer primitive');
              primType = primTypes[options.primitive];
            }
            if ('count' in options) {
              check$1(typeof options.count === 'number' && options.count >= 0, 'invalid vertex count for elements');
              vertCount = options.count | 0;
            }
            if ('type' in options) {
              check$1.parameter(options.type, elementTypes, 'invalid buffer type');
              dtype = elementTypes[options.type];
            }
            if ('length' in options) {
              byteLength = options.length | 0;
            } else {
              byteLength = vertCount;
              if (dtype === GL_UNSIGNED_SHORT$2 || dtype === GL_SHORT$2) {
                byteLength *= 2;
              } else if (dtype === GL_UNSIGNED_INT$2 || dtype === GL_INT$2) {
                byteLength *= 4;
              }
            }
          }
          initElements(elements, data, usage, primType, vertCount, byteLength, dtype);
        }

        return reglElements;
      }

      reglElements(options);

      reglElements._reglType = 'elements';
      reglElements._elements = elements;
      reglElements.subdata = function (data, offset) {
        buffer.subdata(data, offset);
        return reglElements;
      };
      reglElements.destroy = function () {
        destroyElements(elements);
      };

      return reglElements;
    }

    return {
      create: createElements,
      createStream: createElementStream,
      destroyStream: destroyElementStream,
      getElements: function (elements) {
        if (typeof elements === 'function' && elements._elements instanceof REGLElementBuffer) {
          return elements._elements;
        }
        return null;
      },
      clear: function () {
        values(elementSet).forEach(destroyElements);
      }
    };
  }

  var FLOAT = new Float32Array(1);
  var INT = new Uint32Array(FLOAT.buffer);

  var GL_UNSIGNED_SHORT$4 = 5123;

  function convertToHalfFloat(array) {
    var ushorts = pool.allocType(GL_UNSIGNED_SHORT$4, array.length);

    for (var i = 0; i < array.length; ++i) {
      if (isNaN(array[i])) {
        ushorts[i] = 0xffff;
      } else if (array[i] === Infinity) {
        ushorts[i] = 0x7c00;
      } else if (array[i] === -Infinity) {
        ushorts[i] = 0xfc00;
      } else {
        FLOAT[0] = array[i];
        var x = INT[0];

        var sgn = x >>> 31 << 15;
        var exp = (x << 1 >>> 24) - 127;
        var frac = x >> 13 & (1 << 10) - 1;

        if (exp < -24) {
          // round non-representable denormals to 0
          ushorts[i] = sgn;
        } else if (exp < -14) {
          // handle denormals
          var s = -14 - exp;
          ushorts[i] = sgn + (frac + (1 << 10) >> s);
        } else if (exp > 15) {
          // round overflow to +/- Infinity
          ushorts[i] = sgn + 0x7c00;
        } else {
          // otherwise convert directly
          ushorts[i] = sgn + (exp + 15 << 10) + frac;
        }
      }
    }

    return ushorts;
  }

  function isArrayLike(s) {
    return Array.isArray(s) || isTypedArray(s);
  }

  var GL_COMPRESSED_TEXTURE_FORMATS = 0x86A3;

  var GL_TEXTURE_2D = 0x0DE1;
  var GL_TEXTURE_CUBE_MAP = 0x8513;
  var GL_TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515;

  var GL_RGBA = 0x1908;
  var GL_ALPHA = 0x1906;
  var GL_RGB = 0x1907;
  var GL_LUMINANCE = 0x1909;
  var GL_LUMINANCE_ALPHA = 0x190A;

  var GL_RGBA4 = 0x8056;
  var GL_RGB5_A1 = 0x8057;
  var GL_RGB565 = 0x8D62;

  var GL_UNSIGNED_SHORT_4_4_4_4$1 = 0x8033;
  var GL_UNSIGNED_SHORT_5_5_5_1$1 = 0x8034;
  var GL_UNSIGNED_SHORT_5_6_5$1 = 0x8363;
  var GL_UNSIGNED_INT_24_8_WEBGL$1 = 0x84FA;

  var GL_DEPTH_COMPONENT = 0x1902;
  var GL_DEPTH_STENCIL = 0x84F9;

  var GL_SRGB_EXT = 0x8C40;
  var GL_SRGB_ALPHA_EXT = 0x8C42;

  var GL_HALF_FLOAT_OES$1 = 0x8D61;

  var GL_COMPRESSED_RGB_S3TC_DXT1_EXT = 0x83F0;
  var GL_COMPRESSED_RGBA_S3TC_DXT1_EXT = 0x83F1;
  var GL_COMPRESSED_RGBA_S3TC_DXT3_EXT = 0x83F2;
  var GL_COMPRESSED_RGBA_S3TC_DXT5_EXT = 0x83F3;

  var GL_COMPRESSED_RGB_ATC_WEBGL = 0x8C92;
  var GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 0x8C93;
  var GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 0x87EE;

  var GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 0x8C00;
  var GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 0x8C01;
  var GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 0x8C02;
  var GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 0x8C03;

  var GL_COMPRESSED_RGB_ETC1_WEBGL = 0x8D64;

  var GL_UNSIGNED_BYTE$4 = 0x1401;
  var GL_UNSIGNED_SHORT$3 = 0x1403;
  var GL_UNSIGNED_INT$3 = 0x1405;
  var GL_FLOAT$3 = 0x1406;

  var GL_TEXTURE_WRAP_S = 0x2802;
  var GL_TEXTURE_WRAP_T = 0x2803;

  var GL_REPEAT = 0x2901;
  var GL_CLAMP_TO_EDGE$1 = 0x812F;
  var GL_MIRRORED_REPEAT = 0x8370;

  var GL_TEXTURE_MAG_FILTER = 0x2800;
  var GL_TEXTURE_MIN_FILTER = 0x2801;

  var GL_NEAREST$1 = 0x2600;
  var GL_LINEAR = 0x2601;
  var GL_NEAREST_MIPMAP_NEAREST$1 = 0x2700;
  var GL_LINEAR_MIPMAP_NEAREST$1 = 0x2701;
  var GL_NEAREST_MIPMAP_LINEAR$1 = 0x2702;
  var GL_LINEAR_MIPMAP_LINEAR$1 = 0x2703;

  var GL_GENERATE_MIPMAP_HINT = 0x8192;
  var GL_DONT_CARE = 0x1100;
  var GL_FASTEST = 0x1101;
  var GL_NICEST = 0x1102;

  var GL_TEXTURE_MAX_ANISOTROPY_EXT = 0x84FE;

  var GL_UNPACK_ALIGNMENT = 0x0CF5;
  var GL_UNPACK_FLIP_Y_WEBGL = 0x9240;
  var GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL = 0x9241;
  var GL_UNPACK_COLORSPACE_CONVERSION_WEBGL = 0x9243;

  var GL_BROWSER_DEFAULT_WEBGL = 0x9244;

  var GL_TEXTURE0 = 0x84C0;

  var MIPMAP_FILTERS = [GL_NEAREST_MIPMAP_NEAREST$1, GL_NEAREST_MIPMAP_LINEAR$1, GL_LINEAR_MIPMAP_NEAREST$1, GL_LINEAR_MIPMAP_LINEAR$1];

  var CHANNELS_FORMAT = [0, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_RGBA];

  var FORMAT_CHANNELS = {};
  FORMAT_CHANNELS[GL_LUMINANCE] = FORMAT_CHANNELS[GL_ALPHA] = FORMAT_CHANNELS[GL_DEPTH_COMPONENT] = 1;
  FORMAT_CHANNELS[GL_DEPTH_STENCIL] = FORMAT_CHANNELS[GL_LUMINANCE_ALPHA] = 2;
  FORMAT_CHANNELS[GL_RGB] = FORMAT_CHANNELS[GL_SRGB_EXT] = 3;
  FORMAT_CHANNELS[GL_RGBA] = FORMAT_CHANNELS[GL_SRGB_ALPHA_EXT] = 4;

  function objectName(str) {
    return '[object ' + str + ']';
  }

  var CANVAS_CLASS = objectName('HTMLCanvasElement');
  var CONTEXT2D_CLASS = objectName('CanvasRenderingContext2D');
  var IMAGE_CLASS = objectName('HTMLImageElement');
  var VIDEO_CLASS = objectName('HTMLVideoElement');

  var PIXEL_CLASSES = Object.keys(arrayTypes).concat([CANVAS_CLASS, CONTEXT2D_CLASS, IMAGE_CLASS, VIDEO_CLASS]);

  // for every texture type, store
  // the size in bytes.
  var TYPE_SIZES = [];
  TYPE_SIZES[GL_UNSIGNED_BYTE$4] = 1;
  TYPE_SIZES[GL_FLOAT$3] = 4;
  TYPE_SIZES[GL_HALF_FLOAT_OES$1] = 2;

  TYPE_SIZES[GL_UNSIGNED_SHORT$3] = 2;
  TYPE_SIZES[GL_UNSIGNED_INT$3] = 4;

  var FORMAT_SIZES_SPECIAL = [];
  FORMAT_SIZES_SPECIAL[GL_RGBA4] = 2;
  FORMAT_SIZES_SPECIAL[GL_RGB5_A1] = 2;
  FORMAT_SIZES_SPECIAL[GL_RGB565] = 2;
  FORMAT_SIZES_SPECIAL[GL_DEPTH_STENCIL] = 4;

  FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_S3TC_DXT1_EXT] = 0.5;
  FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_S3TC_DXT1_EXT] = 0.5;
  FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_S3TC_DXT3_EXT] = 1;
  FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_S3TC_DXT5_EXT] = 1;

  FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_ATC_WEBGL] = 0.5;
  FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL] = 1;
  FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL] = 1;

  FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG] = 0.5;
  FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG] = 0.25;
  FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG] = 0.5;
  FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG] = 0.25;

  FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_ETC1_WEBGL] = 0.5;

  function isNumericArray(arr) {
    return Array.isArray(arr) && (arr.length === 0 || typeof arr[0] === 'number');
  }

  function isRectArray(arr) {
    if (!Array.isArray(arr)) {
      return false;
    }
    var width = arr.length;
    if (width === 0 || !isArrayLike(arr[0])) {
      return false;
    }
    return true;
  }

  function classString(x) {
    return Object.prototype.toString.call(x);
  }

  function isCanvasElement(object) {
    return classString(object) === CANVAS_CLASS;
  }

  function isContext2D(object) {
    return classString(object) === CONTEXT2D_CLASS;
  }

  function isImageElement(object) {
    return classString(object) === IMAGE_CLASS;
  }

  function isVideoElement(object) {
    return classString(object) === VIDEO_CLASS;
  }

  function isPixelData(object) {
    if (!object) {
      return false;
    }
    var className = classString(object);
    if (PIXEL_CLASSES.indexOf(className) >= 0) {
      return true;
    }
    return isNumericArray(object) || isRectArray(object) || isNDArrayLike(object);
  }

  function typedArrayCode$1(data) {
    return arrayTypes[Object.prototype.toString.call(data)] | 0;
  }

  function convertData(result, data) {
    var n = data.length;
    switch (result.type) {
      case GL_UNSIGNED_BYTE$4:
      case GL_UNSIGNED_SHORT$3:
      case GL_UNSIGNED_INT$3:
      case GL_FLOAT$3:
        var converted = pool.allocType(result.type, n);
        converted.set(data);
        result.data = converted;
        break;

      case GL_HALF_FLOAT_OES$1:
        result.data = convertToHalfFloat(data);
        break;

      default:
        check$1.raise('unsupported texture type, must specify a typed array');
    }
  }

  function preConvert(image, n) {
    return pool.allocType(image.type === GL_HALF_FLOAT_OES$1 ? GL_FLOAT$3 : image.type, n);
  }

  function postConvert(image, data) {
    if (image.type === GL_HALF_FLOAT_OES$1) {
      image.data = convertToHalfFloat(data);
      pool.freeType(data);
    } else {
      image.data = data;
    }
  }

  function transposeData(image, array, strideX, strideY, strideC, offset) {
    var w = image.width;
    var h = image.height;
    var c = image.channels;
    var n = w * h * c;
    var data = preConvert(image, n);

    var p = 0;
    for (var i = 0; i < h; ++i) {
      for (var j = 0; j < w; ++j) {
        for (var k = 0; k < c; ++k) {
          data[p++] = array[strideX * j + strideY * i + strideC * k + offset];
        }
      }
    }

    postConvert(image, data);
  }

  function getTextureSize(format, type, width, height, isMipmap, isCube) {
    var s;
    if (typeof FORMAT_SIZES_SPECIAL[format] !== 'undefined') {
      // we have a special array for dealing with weird color formats such as RGB5A1
      s = FORMAT_SIZES_SPECIAL[format];
    } else {
      s = FORMAT_CHANNELS[format] * TYPE_SIZES[type];
    }

    if (isCube) {
      s *= 6;
    }

    if (isMipmap) {
      // compute the total size of all the mipmaps.
      var total = 0;

      var w = width;
      while (w >= 1) {
        // we can only use mipmaps on a square image,
        // so we can simply use the width and ignore the height:
        total += s * w * w;
        w /= 2;
      }
      return total;
    } else {
      return s * width * height;
    }
  }

  function createTextureSet(gl, extensions, limits, reglPoll, contextState, stats, config) {
    // -------------------------------------------------------
    // Initialize constants and parameter tables here
    // -------------------------------------------------------
    var mipmapHint = {
      "don't care": GL_DONT_CARE,
      'dont care': GL_DONT_CARE,
      'nice': GL_NICEST,
      'fast': GL_FASTEST
    };

    var wrapModes = {
      'repeat': GL_REPEAT,
      'clamp': GL_CLAMP_TO_EDGE$1,
      'mirror': GL_MIRRORED_REPEAT
    };

    var magFilters = {
      'nearest': GL_NEAREST$1,
      'linear': GL_LINEAR
    };

    var minFilters = extend({
      'mipmap': GL_LINEAR_MIPMAP_LINEAR$1,
      'nearest mipmap nearest': GL_NEAREST_MIPMAP_NEAREST$1,
      'linear mipmap nearest': GL_LINEAR_MIPMAP_NEAREST$1,
      'nearest mipmap linear': GL_NEAREST_MIPMAP_LINEAR$1,
      'linear mipmap linear': GL_LINEAR_MIPMAP_LINEAR$1
    }, magFilters);

    var colorSpace = {
      'none': 0,
      'browser': GL_BROWSER_DEFAULT_WEBGL
    };

    var textureTypes = {
      'uint8': GL_UNSIGNED_BYTE$4,
      'rgba4': GL_UNSIGNED_SHORT_4_4_4_4$1,
      'rgb565': GL_UNSIGNED_SHORT_5_6_5$1,
      'rgb5 a1': GL_UNSIGNED_SHORT_5_5_5_1$1
    };

    var textureFormats = {
      'alpha': GL_ALPHA,
      'luminance': GL_LUMINANCE,
      'luminance alpha': GL_LUMINANCE_ALPHA,
      'rgb': GL_RGB,
      'rgba': GL_RGBA,
      'rgba4': GL_RGBA4,
      'rgb5 a1': GL_RGB5_A1,
      'rgb565': GL_RGB565
    };

    var compressedTextureFormats = {};

    if (extensions.ext_srgb) {
      textureFormats.srgb = GL_SRGB_EXT;
      textureFormats.srgba = GL_SRGB_ALPHA_EXT;
    }

    if (extensions.oes_texture_float) {
      textureTypes.float32 = textureTypes.float = GL_FLOAT$3;
    }

    if (extensions.oes_texture_half_float) {
      textureTypes['float16'] = textureTypes['half float'] = GL_HALF_FLOAT_OES$1;
    }

    if (extensions.webgl_depth_texture) {
      extend(textureFormats, {
        'depth': GL_DEPTH_COMPONENT,
        'depth stencil': GL_DEPTH_STENCIL
      });

      extend(textureTypes, {
        'uint16': GL_UNSIGNED_SHORT$3,
        'uint32': GL_UNSIGNED_INT$3,
        'depth stencil': GL_UNSIGNED_INT_24_8_WEBGL$1
      });
    }

    if (extensions.webgl_compressed_texture_s3tc) {
      extend(compressedTextureFormats, {
        'rgb s3tc dxt1': GL_COMPRESSED_RGB_S3TC_DXT1_EXT,
        'rgba s3tc dxt1': GL_COMPRESSED_RGBA_S3TC_DXT1_EXT,
        'rgba s3tc dxt3': GL_COMPRESSED_RGBA_S3TC_DXT3_EXT,
        'rgba s3tc dxt5': GL_COMPRESSED_RGBA_S3TC_DXT5_EXT
      });
    }

    if (extensions.webgl_compressed_texture_atc) {
      extend(compressedTextureFormats, {
        'rgb atc': GL_COMPRESSED_RGB_ATC_WEBGL,
        'rgba atc explicit alpha': GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL,
        'rgba atc interpolated alpha': GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL
      });
    }

    if (extensions.webgl_compressed_texture_pvrtc) {
      extend(compressedTextureFormats, {
        'rgb pvrtc 4bppv1': GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG,
        'rgb pvrtc 2bppv1': GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG,
        'rgba pvrtc 4bppv1': GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG,
        'rgba pvrtc 2bppv1': GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
      });
    }

    if (extensions.webgl_compressed_texture_etc1) {
      compressedTextureFormats['rgb etc1'] = GL_COMPRESSED_RGB_ETC1_WEBGL;
    }

    // Copy over all texture formats
    var supportedCompressedFormats = Array.prototype.slice.call(gl.getParameter(GL_COMPRESSED_TEXTURE_FORMATS));
    Object.keys(compressedTextureFormats).forEach(function (name) {
      var format = compressedTextureFormats[name];
      if (supportedCompressedFormats.indexOf(format) >= 0) {
        textureFormats[name] = format;
      }
    });

    var supportedFormats = Object.keys(textureFormats);
    limits.textureFormats = supportedFormats;

    // associate with every format string its
    // corresponding GL-value.
    var textureFormatsInvert = [];
    Object.keys(textureFormats).forEach(function (key) {
      var val = textureFormats[key];
      textureFormatsInvert[val] = key;
    });

    // associate with every type string its
    // corresponding GL-value.
    var textureTypesInvert = [];
    Object.keys(textureTypes).forEach(function (key) {
      var val = textureTypes[key];
      textureTypesInvert[val] = key;
    });

    var magFiltersInvert = [];
    Object.keys(magFilters).forEach(function (key) {
      var val = magFilters[key];
      magFiltersInvert[val] = key;
    });

    var minFiltersInvert = [];
    Object.keys(minFilters).forEach(function (key) {
      var val = minFilters[key];
      minFiltersInvert[val] = key;
    });

    var wrapModesInvert = [];
    Object.keys(wrapModes).forEach(function (key) {
      var val = wrapModes[key];
      wrapModesInvert[val] = key;
    });

    // colorFormats[] gives the format (channels) associated to an
    // internalformat
    var colorFormats = supportedFormats.reduce(function (color, key) {
      var glenum = textureFormats[key];
      if (glenum === GL_LUMINANCE || glenum === GL_ALPHA || glenum === GL_LUMINANCE || glenum === GL_LUMINANCE_ALPHA || glenum === GL_DEPTH_COMPONENT || glenum === GL_DEPTH_STENCIL) {
        color[glenum] = glenum;
      } else if (glenum === GL_RGB5_A1 || key.indexOf('rgba') >= 0) {
        color[glenum] = GL_RGBA;
      } else {
        color[glenum] = GL_RGB;
      }
      return color;
    }, {});

    function TexFlags() {
      // format info
      this.internalformat = GL_RGBA;
      this.format = GL_RGBA;
      this.type = GL_UNSIGNED_BYTE$4;
      this.compressed = false;

      // pixel storage
      this.premultiplyAlpha = false;
      this.flipY = false;
      this.unpackAlignment = 1;
      this.colorSpace = 0;

      // shape info
      this.width = 0;
      this.height = 0;
      this.channels = 0;
    }

    function copyFlags(result, other) {
      result.internalformat = other.internalformat;
      result.format = other.format;
      result.type = other.type;
      result.compressed = other.compressed;

      result.premultiplyAlpha = other.premultiplyAlpha;
      result.flipY = other.flipY;
      result.unpackAlignment = other.unpackAlignment;
      result.colorSpace = other.colorSpace;

      result.width = other.width;
      result.height = other.height;
      result.channels = other.channels;
    }

    function parseFlags(flags, options) {
      if (typeof options !== 'object' || !options) {
        return;
      }

      if ('premultiplyAlpha' in options) {
        check$1.type(options.premultiplyAlpha, 'boolean', 'invalid premultiplyAlpha');
        flags.premultiplyAlpha = options.premultiplyAlpha;
      }

      if ('flipY' in options) {
        check$1.type(options.flipY, 'boolean', 'invalid texture flip');
        flags.flipY = options.flipY;
      }

      if ('alignment' in options) {
        check$1.oneOf(options.alignment, [1, 2, 4, 8], 'invalid texture unpack alignment');
        flags.unpackAlignment = options.alignment;
      }

      if ('colorSpace' in options) {
        check$1.parameter(options.colorSpace, colorSpace, 'invalid colorSpace');
        flags.colorSpace = colorSpace[options.colorSpace];
      }

      if ('type' in options) {
        var type = options.type;
        check$1(extensions.oes_texture_float || !(type === 'float' || type === 'float32'), 'you must enable the OES_texture_float extension in order to use floating point textures.');
        check$1(extensions.oes_texture_half_float || !(type === 'half float' || type === 'float16'), 'you must enable the OES_texture_half_float extension in order to use 16-bit floating point textures.');
        check$1(extensions.webgl_depth_texture || !(type === 'uint16' || type === 'uint32' || type === 'depth stencil'), 'you must enable the WEBGL_depth_texture extension in order to use depth/stencil textures.');
        check$1.parameter(type, textureTypes, 'invalid texture type');
        flags.type = textureTypes[type];
      }

      var w = flags.width;
      var h = flags.height;
      var c = flags.channels;
      var hasChannels = false;
      if ('shape' in options) {
        check$1(Array.isArray(options.shape) && options.shape.length >= 2, 'shape must be an array');
        w = options.shape[0];
        h = options.shape[1];
        if (options.shape.length === 3) {
          c = options.shape[2];
          check$1(c > 0 && c <= 4, 'invalid number of channels');
          hasChannels = true;
        }
        check$1(w >= 0 && w <= limits.maxTextureSize, 'invalid width');
        check$1(h >= 0 && h <= limits.maxTextureSize, 'invalid height');
      } else {
        if ('radius' in options) {
          w = h = options.radius;
          check$1(w >= 0 && w <= limits.maxTextureSize, 'invalid radius');
        }
        if ('width' in options) {
          w = options.width;
          check$1(w >= 0 && w <= limits.maxTextureSize, 'invalid width');
        }
        if ('height' in options) {
          h = options.height;
          check$1(h >= 0 && h <= limits.maxTextureSize, 'invalid height');
        }
        if ('channels' in options) {
          c = options.channels;
          check$1(c > 0 && c <= 4, 'invalid number of channels');
          hasChannels = true;
        }
      }
      flags.width = w | 0;
      flags.height = h | 0;
      flags.channels = c | 0;

      var hasFormat = false;
      if ('format' in options) {
        var formatStr = options.format;
        check$1(extensions.webgl_depth_texture || !(formatStr === 'depth' || formatStr === 'depth stencil'), 'you must enable the WEBGL_depth_texture extension in order to use depth/stencil textures.');
        check$1.parameter(formatStr, textureFormats, 'invalid texture format');
        var internalformat = flags.internalformat = textureFormats[formatStr];
        flags.format = colorFormats[internalformat];
        if (formatStr in textureTypes) {
          if (!('type' in options)) {
            flags.type = textureTypes[formatStr];
          }
        }
        if (formatStr in compressedTextureFormats) {
          flags.compressed = true;
        }
        hasFormat = true;
      }

      // Reconcile channels and format
      if (!hasChannels && hasFormat) {
        flags.channels = FORMAT_CHANNELS[flags.format];
      } else if (hasChannels && !hasFormat) {
        if (flags.channels !== CHANNELS_FORMAT[flags.format]) {
          flags.format = flags.internalformat = CHANNELS_FORMAT[flags.channels];
        }
      } else if (hasFormat && hasChannels) {
        check$1(flags.channels === FORMAT_CHANNELS[flags.format], 'number of channels inconsistent with specified format');
      }
    }

    function setFlags(flags) {
      gl.pixelStorei(GL_UNPACK_FLIP_Y_WEBGL, flags.flipY);
      gl.pixelStorei(GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL, flags.premultiplyAlpha);
      gl.pixelStorei(GL_UNPACK_COLORSPACE_CONVERSION_WEBGL, flags.colorSpace);
      gl.pixelStorei(GL_UNPACK_ALIGNMENT, flags.unpackAlignment);
    }

    // -------------------------------------------------------
    // Tex image data
    // -------------------------------------------------------
    function TexImage() {
      TexFlags.call(this);

      this.xOffset = 0;
      this.yOffset = 0;

      // data
      this.data = null;
      this.needsFree = false;

      // html element
      this.element = null;

      // copyTexImage info
      this.needsCopy = false;
    }

    function parseImage(image, options) {
      var data = null;
      if (isPixelData(options)) {
        data = options;
      } else if (options) {
        check$1.type(options, 'object', 'invalid pixel data type');
        parseFlags(image, options);
        if ('x' in options) {
          image.xOffset = options.x | 0;
        }
        if ('y' in options) {
          image.yOffset = options.y | 0;
        }
        if (isPixelData(options.data)) {
          data = options.data;
        }
      }

      check$1(!image.compressed || data instanceof Uint8Array, 'compressed texture data must be stored in a uint8array');

      if (options.copy) {
        check$1(!data, 'can not specify copy and data field for the same texture');
        var viewW = contextState.viewportWidth;
        var viewH = contextState.viewportHeight;
        image.width = image.width || viewW - image.xOffset;
        image.height = image.height || viewH - image.yOffset;
        image.needsCopy = true;
        check$1(image.xOffset >= 0 && image.xOffset < viewW && image.yOffset >= 0 && image.yOffset < viewH && image.width > 0 && image.width <= viewW && image.height > 0 && image.height <= viewH, 'copy texture read out of bounds');
      } else if (!data) {
        image.width = image.width || 1;
        image.height = image.height || 1;
        image.channels = image.channels || 4;
      } else if (isTypedArray(data)) {
        image.channels = image.channels || 4;
        image.data = data;
        if (!('type' in options) && image.type === GL_UNSIGNED_BYTE$4) {
          image.type = typedArrayCode$1(data);
        }
      } else if (isNumericArray(data)) {
        image.channels = image.channels || 4;
        convertData(image, data);
        image.alignment = 1;
        image.needsFree = true;
      } else if (isNDArrayLike(data)) {
        var array = data.data;
        if (!Array.isArray(array) && image.type === GL_UNSIGNED_BYTE$4) {
          image.type = typedArrayCode$1(array);
        }
        var shape = data.shape;
        var stride = data.stride;
        var shapeX, shapeY, shapeC, strideX, strideY, strideC;
        if (shape.length === 3) {
          shapeC = shape[2];
          strideC = stride[2];
        } else {
          check$1(shape.length === 2, 'invalid ndarray pixel data, must be 2 or 3D');
          shapeC = 1;
          strideC = 1;
        }
        shapeX = shape[0];
        shapeY = shape[1];
        strideX = stride[0];
        strideY = stride[1];
        image.alignment = 1;
        image.width = shapeX;
        image.height = shapeY;
        image.channels = shapeC;
        image.format = image.internalformat = CHANNELS_FORMAT[shapeC];
        image.needsFree = true;
        transposeData(image, array, strideX, strideY, strideC, data.offset);
      } else if (isCanvasElement(data) || isContext2D(data)) {
        if (isCanvasElement(data)) {
          image.element = data;
        } else {
          image.element = data.canvas;
        }
        image.width = image.element.width;
        image.height = image.element.height;
        image.channels = 4;
      } else if (isImageElement(data)) {
        image.element = data;
        image.width = data.naturalWidth;
        image.height = data.naturalHeight;
        image.channels = 4;
      } else if (isVideoElement(data)) {
        image.element = data;
        image.width = data.videoWidth;
        image.height = data.videoHeight;
        image.channels = 4;
      } else if (isRectArray(data)) {
        var w = image.width || data[0].length;
        var h = image.height || data.length;
        var c = image.channels;
        if (isArrayLike(data[0][0])) {
          c = c || data[0][0].length;
        } else {
          c = c || 1;
        }
        var arrayShape = flattenUtils.shape(data);
        var n = 1;
        for (var dd = 0; dd < arrayShape.length; ++dd) {
          n *= arrayShape[dd];
        }
        var allocData = preConvert(image, n);
        flattenUtils.flatten(data, arrayShape, '', allocData);
        postConvert(image, allocData);
        image.alignment = 1;
        image.width = w;
        image.height = h;
        image.channels = c;
        image.format = image.internalformat = CHANNELS_FORMAT[c];
        image.needsFree = true;
      }

      if (image.type === GL_FLOAT$3) {
        check$1(limits.extensions.indexOf('oes_texture_float') >= 0, 'oes_texture_float extension not enabled');
      } else if (image.type === GL_HALF_FLOAT_OES$1) {
        check$1(limits.extensions.indexOf('oes_texture_half_float') >= 0, 'oes_texture_half_float extension not enabled');
      }

      // do compressed texture  validation here.
    }

    function setImage(info, target, miplevel) {
      var element = info.element;
      var data = info.data;
      var internalformat = info.internalformat;
      var format = info.format;
      var type = info.type;
      var width = info.width;
      var height = info.height;

      setFlags(info);

      if (element) {
        gl.texImage2D(target, miplevel, format, format, type, element);
      } else if (info.compressed) {
        gl.compressedTexImage2D(target, miplevel, internalformat, width, height, 0, data);
      } else if (info.needsCopy) {
        reglPoll();
        gl.copyTexImage2D(target, miplevel, format, info.xOffset, info.yOffset, width, height, 0);
      } else {
        gl.texImage2D(target, miplevel, format, width, height, 0, format, type, data);
      }
    }

    function setSubImage(info, target, x, y, miplevel) {
      var element = info.element;
      var data = info.data;
      var internalformat = info.internalformat;
      var format = info.format;
      var type = info.type;
      var width = info.width;
      var height = info.height;

      setFlags(info);

      if (element) {
        gl.texSubImage2D(target, miplevel, x, y, format, type, element);
      } else if (info.compressed) {
        gl.compressedTexSubImage2D(target, miplevel, x, y, internalformat, width, height, data);
      } else if (info.needsCopy) {
        reglPoll();
        gl.copyTexSubImage2D(target, miplevel, x, y, info.xOffset, info.yOffset, width, height);
      } else {
        gl.texSubImage2D(target, miplevel, x, y, width, height, format, type, data);
      }
    }

    // texImage pool
    var imagePool = [];

    function allocImage() {
      return imagePool.pop() || new TexImage();
    }

    function freeImage(image) {
      if (image.needsFree) {
        pool.freeType(image.data);
      }
      TexImage.call(image);
      imagePool.push(image);
    }

    // -------------------------------------------------------
    // Mip map
    // -------------------------------------------------------
    function MipMap() {
      TexFlags.call(this);

      this.genMipmaps = false;
      this.mipmapHint = GL_DONT_CARE;
      this.mipmask = 0;
      this.images = Array(16);
    }

    function parseMipMapFromShape(mipmap, width, height) {
      var img = mipmap.images[0] = allocImage();
      mipmap.mipmask = 1;
      img.width = mipmap.width = width;
      img.height = mipmap.height = height;
      img.channels = mipmap.channels = 4;
    }

    function parseMipMapFromObject(mipmap, options) {
      var imgData = null;
      if (isPixelData(options)) {
        imgData = mipmap.images[0] = allocImage();
        copyFlags(imgData, mipmap);
        parseImage(imgData, options);
        mipmap.mipmask = 1;
      } else {
        parseFlags(mipmap, options);
        if (Array.isArray(options.mipmap)) {
          var mipData = options.mipmap;
          for (var i = 0; i < mipData.length; ++i) {
            imgData = mipmap.images[i] = allocImage();
            copyFlags(imgData, mipmap);
            imgData.width >>= i;
            imgData.height >>= i;
            parseImage(imgData, mipData[i]);
            mipmap.mipmask |= 1 << i;
          }
        } else {
          imgData = mipmap.images[0] = allocImage();
          copyFlags(imgData, mipmap);
          parseImage(imgData, options);
          mipmap.mipmask = 1;
        }
      }
      copyFlags(mipmap, mipmap.images[0]);

      // For textures of the compressed format WEBGL_compressed_texture_s3tc
      // we must have that
      //
      // "When level equals zero width and height must be a multiple of 4.
      // When level is greater than 0 width and height must be 0, 1, 2 or a multiple of 4. "
      //
      // but we do not yet support having multiple mipmap levels for compressed textures,
      // so we only test for level zero.

      if (mipmap.compressed && mipmap.internalformat === GL_COMPRESSED_RGB_S3TC_DXT1_EXT || mipmap.internalformat === GL_COMPRESSED_RGBA_S3TC_DXT1_EXT || mipmap.internalformat === GL_COMPRESSED_RGBA_S3TC_DXT3_EXT || mipmap.internalformat === GL_COMPRESSED_RGBA_S3TC_DXT5_EXT) {
        check$1(mipmap.width % 4 === 0 && mipmap.height % 4 === 0, 'for compressed texture formats, mipmap level 0 must have width and height that are a multiple of 4');
      }
    }

    function setMipMap(mipmap, target) {
      var images = mipmap.images;
      for (var i = 0; i < images.length; ++i) {
        if (!images[i]) {
          return;
        }
        setImage(images[i], target, i);
      }
    }

    var mipPool = [];

    function allocMipMap() {
      var result = mipPool.pop() || new MipMap();
      TexFlags.call(result);
      result.mipmask = 0;
      for (var i = 0; i < 16; ++i) {
        result.images[i] = null;
      }
      return result;
    }

    function freeMipMap(mipmap) {
      var images = mipmap.images;
      for (var i = 0; i < images.length; ++i) {
        if (images[i]) {
          freeImage(images[i]);
        }
        images[i] = null;
      }
      mipPool.push(mipmap);
    }

    // -------------------------------------------------------
    // Tex info
    // -------------------------------------------------------
    function TexInfo() {
      this.minFilter = GL_NEAREST$1;
      this.magFilter = GL_NEAREST$1;

      this.wrapS = GL_CLAMP_TO_EDGE$1;
      this.wrapT = GL_CLAMP_TO_EDGE$1;

      this.anisotropic = 1;

      this.genMipmaps = false;
      this.mipmapHint = GL_DONT_CARE;
    }

    function parseTexInfo(info, options) {
      if ('min' in options) {
        var minFilter = options.min;
        check$1.parameter(minFilter, minFilters);
        info.minFilter = minFilters[minFilter];
        if (MIPMAP_FILTERS.indexOf(info.minFilter) >= 0) {
          info.genMipmaps = true;
        }
      }

      if ('mag' in options) {
        var magFilter = options.mag;
        check$1.parameter(magFilter, magFilters);
        info.magFilter = magFilters[magFilter];
      }

      var wrapS = info.wrapS;
      var wrapT = info.wrapT;
      if ('wrap' in options) {
        var wrap = options.wrap;
        if (typeof wrap === 'string') {
          check$1.parameter(wrap, wrapModes);
          wrapS = wrapT = wrapModes[wrap];
        } else if (Array.isArray(wrap)) {
          check$1.parameter(wrap[0], wrapModes);
          check$1.parameter(wrap[1], wrapModes);
          wrapS = wrapModes[wrap[0]];
          wrapT = wrapModes[wrap[1]];
        }
      } else {
        if ('wrapS' in options) {
          var optWrapS = options.wrapS;
          check$1.parameter(optWrapS, wrapModes);
          wrapS = wrapModes[optWrapS];
        }
        if ('wrapT' in options) {
          var optWrapT = options.wrapT;
          check$1.parameter(optWrapT, wrapModes);
          wrapT = wrapModes[optWrapT];
        }
      }
      info.wrapS = wrapS;
      info.wrapT = wrapT;

      if ('anisotropic' in options) {
        var anisotropic = options.anisotropic;
        check$1(typeof anisotropic === 'number' && anisotropic >= 1 && anisotropic <= limits.maxAnisotropic, 'aniso samples must be between 1 and ');
        info.anisotropic = options.anisotropic;
      }

      if ('mipmap' in options) {
        var hasMipMap = false;
        switch (typeof options.mipmap) {
          case 'string':
            check$1.parameter(options.mipmap, mipmapHint, 'invalid mipmap hint');
            info.mipmapHint = mipmapHint[options.mipmap];
            info.genMipmaps = true;
            hasMipMap = true;
            break;

          case 'boolean':
            hasMipMap = info.genMipmaps = options.mipmap;
            break;

          case 'object':
            check$1(Array.isArray(options.mipmap), 'invalid mipmap type');
            info.genMipmaps = false;
            hasMipMap = true;
            break;

          default:
            check$1.raise('invalid mipmap type');
        }
        if (hasMipMap && !('min' in options)) {
          info.minFilter = GL_NEAREST_MIPMAP_NEAREST$1;
        }
      }
    }

    function setTexInfo(info, target) {
      gl.texParameteri(target, GL_TEXTURE_MIN_FILTER, info.minFilter);
      gl.texParameteri(target, GL_TEXTURE_MAG_FILTER, info.magFilter);
      gl.texParameteri(target, GL_TEXTURE_WRAP_S, info.wrapS);
      gl.texParameteri(target, GL_TEXTURE_WRAP_T, info.wrapT);
      if (extensions.ext_texture_filter_anisotropic) {
        gl.texParameteri(target, GL_TEXTURE_MAX_ANISOTROPY_EXT, info.anisotropic);
      }
      if (info.genMipmaps) {
        gl.hint(GL_GENERATE_MIPMAP_HINT, info.mipmapHint);
        gl.generateMipmap(target);
      }
    }

    // -------------------------------------------------------
    // Full texture object
    // -------------------------------------------------------
    var textureCount = 0;
    var textureSet = {};
    var numTexUnits = limits.maxTextureUnits;
    var textureUnits = Array(numTexUnits).map(function () {
      return null;
    });

    function REGLTexture(target) {
      TexFlags.call(this);
      this.mipmask = 0;
      this.internalformat = GL_RGBA;

      this.id = textureCount++;

      this.refCount = 1;

      this.target = target;
      this.texture = gl.createTexture();

      this.unit = -1;
      this.bindCount = 0;

      this.texInfo = new TexInfo();

      if (config.profile) {
        this.stats = { size: 0 };
      }
    }

    function tempBind(texture) {
      gl.activeTexture(GL_TEXTURE0);
      gl.bindTexture(texture.target, texture.texture);
    }

    function tempRestore() {
      var prev = textureUnits[0];
      if (prev) {
        gl.bindTexture(prev.target, prev.texture);
      } else {
        gl.bindTexture(GL_TEXTURE_2D, null);
      }
    }

    function destroy(texture) {
      var handle = texture.texture;
      check$1(handle, 'must not double destroy texture');
      var unit = texture.unit;
      var target = texture.target;
      if (unit >= 0) {
        gl.activeTexture(GL_TEXTURE0 + unit);
        gl.bindTexture(target, null);
        textureUnits[unit] = null;
      }
      gl.deleteTexture(handle);
      texture.texture = null;
      texture.params = null;
      texture.pixels = null;
      texture.refCount = 0;
      delete textureSet[texture.id];
      stats.textureCount--;
    }

    extend(REGLTexture.prototype, {
      bind: function () {
        var texture = this;
        texture.bindCount += 1;
        var unit = texture.unit;
        if (unit < 0) {
          for (var i = 0; i < numTexUnits; ++i) {
            var other = textureUnits[i];
            if (other) {
              if (other.bindCount > 0) {
                continue;
              }
              other.unit = -1;
            }
            textureUnits[i] = texture;
            unit = i;
            break;
          }
          if (unit >= numTexUnits) {
            check$1.raise('insufficient number of texture units');
          }
          if (config.profile && stats.maxTextureUnits < unit + 1) {
            stats.maxTextureUnits = unit + 1; // +1, since the units are zero-based
          }
          texture.unit = unit;
          gl.activeTexture(GL_TEXTURE0 + unit);
          gl.bindTexture(texture.target, texture.texture);
        }
        return unit;
      },

      unbind: function () {
        this.bindCount -= 1;
      },

      decRef: function () {
        if (--this.refCount <= 0) {
          destroy(this);
        }
      }
    });

    function createTexture2D(a, b) {
      var texture = new REGLTexture(GL_TEXTURE_2D);
      textureSet[texture.id] = texture;
      stats.textureCount++;

      function reglTexture2D(a, b) {
        var texInfo = texture.texInfo;
        TexInfo.call(texInfo);
        var mipData = allocMipMap();

        if (typeof a === 'number') {
          if (typeof b === 'number') {
            parseMipMapFromShape(mipData, a | 0, b | 0);
          } else {
            parseMipMapFromShape(mipData, a | 0, a | 0);
          }
        } else if (a) {
          check$1.type(a, 'object', 'invalid arguments to regl.texture');
          parseTexInfo(texInfo, a);
          parseMipMapFromObject(mipData, a);
        } else {
          // empty textures get assigned a default shape of 1x1
          parseMipMapFromShape(mipData, 1, 1);
        }

        if (texInfo.genMipmaps) {
          mipData.mipmask = (mipData.width << 1) - 1;
        }
        texture.mipmask = mipData.mipmask;

        copyFlags(texture, mipData);

        check$1.texture2D(texInfo, mipData, limits);
        texture.internalformat = mipData.internalformat;

        reglTexture2D.width = mipData.width;
        reglTexture2D.height = mipData.height;

        tempBind(texture);
        setMipMap(mipData, GL_TEXTURE_2D);
        setTexInfo(texInfo, GL_TEXTURE_2D);
        tempRestore();

        freeMipMap(mipData);

        if (config.profile) {
          texture.stats.size = getTextureSize(texture.internalformat, texture.type, mipData.width, mipData.height, texInfo.genMipmaps, false);
        }
        reglTexture2D.format = textureFormatsInvert[texture.internalformat];
        reglTexture2D.type = textureTypesInvert[texture.type];

        reglTexture2D.mag = magFiltersInvert[texInfo.magFilter];
        reglTexture2D.min = minFiltersInvert[texInfo.minFilter];

        reglTexture2D.wrapS = wrapModesInvert[texInfo.wrapS];
        reglTexture2D.wrapT = wrapModesInvert[texInfo.wrapT];

        return reglTexture2D;
      }

      function subimage(image, x_, y_, level_) {
        check$1(!!image, 'must specify image data');

        var x = x_ | 0;
        var y = y_ | 0;
        var level = level_ | 0;

        var imageData = allocImage();
        copyFlags(imageData, texture);
        imageData.width = 0;
        imageData.height = 0;
        parseImage(imageData, image);
        imageData.width = imageData.width || (texture.width >> level) - x;
        imageData.height = imageData.height || (texture.height >> level) - y;

        check$1(texture.type === imageData.type && texture.format === imageData.format && texture.internalformat === imageData.internalformat, 'incompatible format for texture.subimage');
        check$1(x >= 0 && y >= 0 && x + imageData.width <= texture.width && y + imageData.height <= texture.height, 'texture.subimage write out of bounds');
        check$1(texture.mipmask & 1 << level, 'missing mipmap data');
        check$1(imageData.data || imageData.element || imageData.needsCopy, 'missing image data');

        tempBind(texture);
        setSubImage(imageData, GL_TEXTURE_2D, x, y, level);
        tempRestore();

        freeImage(imageData);

        return reglTexture2D;
      }

      function resize(w_, h_) {
        var w = w_ | 0;
        var h = h_ | 0 || w;
        if (w === texture.width && h === texture.height) {
          return reglTexture2D;
        }

        reglTexture2D.width = texture.width = w;
        reglTexture2D.height = texture.height = h;

        tempBind(texture);
        for (var i = 0; texture.mipmask >> i; ++i) {
          gl.texImage2D(GL_TEXTURE_2D, i, texture.format, w >> i, h >> i, 0, texture.format, texture.type, null);
        }
        tempRestore();

        // also, recompute the texture size.
        if (config.profile) {
          texture.stats.size = getTextureSize(texture.internalformat, texture.type, w, h, false, false);
        }

        return reglTexture2D;
      }

      reglTexture2D(a, b);

      reglTexture2D.subimage = subimage;
      reglTexture2D.resize = resize;
      reglTexture2D._reglType = 'texture2d';
      reglTexture2D._texture = texture;
      if (config.profile) {
        reglTexture2D.stats = texture.stats;
      }
      reglTexture2D.destroy = function () {
        texture.decRef();
      };

      return reglTexture2D;
    }

    function createTextureCube(a0, a1, a2, a3, a4, a5) {
      var texture = new REGLTexture(GL_TEXTURE_CUBE_MAP);
      textureSet[texture.id] = texture;
      stats.cubeCount++;

      var faces = new Array(6);

      function reglTextureCube(a0, a1, a2, a3, a4, a5) {
        var i;
        var texInfo = texture.texInfo;
        TexInfo.call(texInfo);
        for (i = 0; i < 6; ++i) {
          faces[i] = allocMipMap();
        }

        if (typeof a0 === 'number' || !a0) {
          var s = a0 | 0 || 1;
          for (i = 0; i < 6; ++i) {
            parseMipMapFromShape(faces[i], s, s);
          }
        } else if (typeof a0 === 'object') {
          if (a1) {
            parseMipMapFromObject(faces[0], a0);
            parseMipMapFromObject(faces[1], a1);
            parseMipMapFromObject(faces[2], a2);
            parseMipMapFromObject(faces[3], a3);
            parseMipMapFromObject(faces[4], a4);
            parseMipMapFromObject(faces[5], a5);
          } else {
            parseTexInfo(texInfo, a0);
            parseFlags(texture, a0);
            if ('faces' in a0) {
              var face_input = a0.faces;
              check$1(Array.isArray(face_input) && face_input.length === 6, 'cube faces must be a length 6 array');
              for (i = 0; i < 6; ++i) {
                check$1(typeof face_input[i] === 'object' && !!face_input[i], 'invalid input for cube map face');
                copyFlags(faces[i], texture);
                parseMipMapFromObject(faces[i], face_input[i]);
              }
            } else {
              for (i = 0; i < 6; ++i) {
                parseMipMapFromObject(faces[i], a0);
              }
            }
          }
        } else {
          check$1.raise('invalid arguments to cube map');
        }

        copyFlags(texture, faces[0]);
        if (texInfo.genMipmaps) {
          texture.mipmask = (faces[0].width << 1) - 1;
        } else {
          texture.mipmask = faces[0].mipmask;
        }

        check$1.textureCube(texture, texInfo, faces, limits);
        texture.internalformat = faces[0].internalformat;

        reglTextureCube.width = faces[0].width;
        reglTextureCube.height = faces[0].height;

        tempBind(texture);
        for (i = 0; i < 6; ++i) {
          setMipMap(faces[i], GL_TEXTURE_CUBE_MAP_POSITIVE_X + i);
        }
        setTexInfo(texInfo, GL_TEXTURE_CUBE_MAP);
        tempRestore();

        if (config.profile) {
          texture.stats.size = getTextureSize(texture.internalformat, texture.type, reglTextureCube.width, reglTextureCube.height, texInfo.genMipmaps, true);
        }

        reglTextureCube.format = textureFormatsInvert[texture.internalformat];
        reglTextureCube.type = textureTypesInvert[texture.type];

        reglTextureCube.mag = magFiltersInvert[texInfo.magFilter];
        reglTextureCube.min = minFiltersInvert[texInfo.minFilter];

        reglTextureCube.wrapS = wrapModesInvert[texInfo.wrapS];
        reglTextureCube.wrapT = wrapModesInvert[texInfo.wrapT];

        for (i = 0; i < 6; ++i) {
          freeMipMap(faces[i]);
        }

        return reglTextureCube;
      }

      function subimage(face, image, x_, y_, level_) {
        check$1(!!image, 'must specify image data');
        check$1(typeof face === 'number' && face === (face | 0) && face >= 0 && face < 6, 'invalid face');

        var x = x_ | 0;
        var y = y_ | 0;
        var level = level_ | 0;

        var imageData = allocImage();
        copyFlags(imageData, texture);
        imageData.width = 0;
        imageData.height = 0;
        parseImage(imageData, image);
        imageData.width = imageData.width || (texture.width >> level) - x;
        imageData.height = imageData.height || (texture.height >> level) - y;

        check$1(texture.type === imageData.type && texture.format === imageData.format && texture.internalformat === imageData.internalformat, 'incompatible format for texture.subimage');
        check$1(x >= 0 && y >= 0 && x + imageData.width <= texture.width && y + imageData.height <= texture.height, 'texture.subimage write out of bounds');
        check$1(texture.mipmask & 1 << level, 'missing mipmap data');
        check$1(imageData.data || imageData.element || imageData.needsCopy, 'missing image data');

        tempBind(texture);
        setSubImage(imageData, GL_TEXTURE_CUBE_MAP_POSITIVE_X + face, x, y, level);
        tempRestore();

        freeImage(imageData);

        return reglTextureCube;
      }

      function resize(radius_) {
        var radius = radius_ | 0;
        if (radius === texture.width) {
          return;
        }

        reglTextureCube.width = texture.width = radius;
        reglTextureCube.height = texture.height = radius;

        tempBind(texture);
        for (var i = 0; i < 6; ++i) {
          for (var j = 0; texture.mipmask >> j; ++j) {
            gl.texImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, j, texture.format, radius >> j, radius >> j, 0, texture.format, texture.type, null);
          }
        }
        tempRestore();

        if (config.profile) {
          texture.stats.size = getTextureSize(texture.internalformat, texture.type, reglTextureCube.width, reglTextureCube.height, false, true);
        }

        return reglTextureCube;
      }

      reglTextureCube(a0, a1, a2, a3, a4, a5);

      reglTextureCube.subimage = subimage;
      reglTextureCube.resize = resize;
      reglTextureCube._reglType = 'textureCube';
      reglTextureCube._texture = texture;
      if (config.profile) {
        reglTextureCube.stats = texture.stats;
      }
      reglTextureCube.destroy = function () {
        texture.decRef();
      };

      return reglTextureCube;
    }

    // Called when regl is destroyed
    function destroyTextures() {
      for (var i = 0; i < numTexUnits; ++i) {
        gl.activeTexture(GL_TEXTURE0 + i);
        gl.bindTexture(GL_TEXTURE_2D, null);
        textureUnits[i] = null;
      }
      values(textureSet).forEach(destroy);

      stats.cubeCount = 0;
      stats.textureCount = 0;
    }

    if (config.profile) {
      stats.getTotalTextureSize = function () {
        var total = 0;
        Object.keys(textureSet).forEach(function (key) {
          total += textureSet[key].stats.size;
        });
        return total;
      };
    }

    function restoreTextures() {
      values(textureSet).forEach(function (texture) {
        texture.texture = gl.createTexture();
        gl.bindTexture(texture.target, texture.texture);
        for (var i = 0; i < 32; ++i) {
          if ((texture.mipmask & 1 << i) === 0) {
            continue;
          }
          if (texture.target === GL_TEXTURE_2D) {
            gl.texImage2D(GL_TEXTURE_2D, i, texture.internalformat, texture.width >> i, texture.height >> i, 0, texture.internalformat, texture.type, null);
          } else {
            for (var j = 0; j < 6; ++j) {
              gl.texImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + j, i, texture.internalformat, texture.width >> i, texture.height >> i, 0, texture.internalformat, texture.type, null);
            }
          }
        }
        setTexInfo(texture.texInfo, texture.target);
      });
    }

    return {
      create2D: createTexture2D,
      createCube: createTextureCube,
      clear: destroyTextures,
      getTexture: function (wrapper) {
        return null;
      },
      restore: restoreTextures
    };
  }

  var GL_RENDERBUFFER = 0x8D41;

  var GL_RGBA4$1 = 0x8056;
  var GL_RGB5_A1$1 = 0x8057;
  var GL_RGB565$1 = 0x8D62;
  var GL_DEPTH_COMPONENT16 = 0x81A5;
  var GL_STENCIL_INDEX8 = 0x8D48;
  var GL_DEPTH_STENCIL$1 = 0x84F9;

  var GL_SRGB8_ALPHA8_EXT = 0x8C43;

  var GL_RGBA32F_EXT = 0x8814;

  var GL_RGBA16F_EXT = 0x881A;
  var GL_RGB16F_EXT = 0x881B;

  var FORMAT_SIZES = [];

  FORMAT_SIZES[GL_RGBA4$1] = 2;
  FORMAT_SIZES[GL_RGB5_A1$1] = 2;
  FORMAT_SIZES[GL_RGB565$1] = 2;

  FORMAT_SIZES[GL_DEPTH_COMPONENT16] = 2;
  FORMAT_SIZES[GL_STENCIL_INDEX8] = 1;
  FORMAT_SIZES[GL_DEPTH_STENCIL$1] = 4;

  FORMAT_SIZES[GL_SRGB8_ALPHA8_EXT] = 4;
  FORMAT_SIZES[GL_RGBA32F_EXT] = 16;
  FORMAT_SIZES[GL_RGBA16F_EXT] = 8;
  FORMAT_SIZES[GL_RGB16F_EXT] = 6;

  function getRenderbufferSize(format, width, height) {
    return FORMAT_SIZES[format] * width * height;
  }

  var wrapRenderbuffers = function (gl, extensions, limits, stats, config) {
    var formatTypes = {
      'rgba4': GL_RGBA4$1,
      'rgb565': GL_RGB565$1,
      'rgb5 a1': GL_RGB5_A1$1,
      'depth': GL_DEPTH_COMPONENT16,
      'stencil': GL_STENCIL_INDEX8,
      'depth stencil': GL_DEPTH_STENCIL$1
    };

    if (extensions.ext_srgb) {
      formatTypes['srgba'] = GL_SRGB8_ALPHA8_EXT;
    }

    if (extensions.ext_color_buffer_half_float) {
      formatTypes['rgba16f'] = GL_RGBA16F_EXT;
      formatTypes['rgb16f'] = GL_RGB16F_EXT;
    }

    if (extensions.webgl_color_buffer_float) {
      formatTypes['rgba32f'] = GL_RGBA32F_EXT;
    }

    var formatTypesInvert = [];
    Object.keys(formatTypes).forEach(function (key) {
      var val = formatTypes[key];
      formatTypesInvert[val] = key;
    });

    var renderbufferCount = 0;
    var renderbufferSet = {};

    function REGLRenderbuffer(renderbuffer) {
      this.id = renderbufferCount++;
      this.refCount = 1;

      this.renderbuffer = renderbuffer;

      this.format = GL_RGBA4$1;
      this.width = 0;
      this.height = 0;

      if (config.profile) {
        this.stats = { size: 0 };
      }
    }

    REGLRenderbuffer.prototype.decRef = function () {
      if (--this.refCount <= 0) {
        destroy(this);
      }
    };

    function destroy(rb) {
      var handle = rb.renderbuffer;
      check$1(handle, 'must not double destroy renderbuffer');
      gl.bindRenderbuffer(GL_RENDERBUFFER, null);
      gl.deleteRenderbuffer(handle);
      rb.renderbuffer = null;
      rb.refCount = 0;
      delete renderbufferSet[rb.id];
      stats.renderbufferCount--;
    }

    function createRenderbuffer(a, b) {
      var renderbuffer = new REGLRenderbuffer(gl.createRenderbuffer());
      renderbufferSet[renderbuffer.id] = renderbuffer;
      stats.renderbufferCount++;

      function reglRenderbuffer(a, b) {
        var w = 0;
        var h = 0;
        var format = GL_RGBA4$1;

        if (typeof a === 'object' && a) {
          var options = a;
          if ('shape' in options) {
            var shape = options.shape;
            check$1(Array.isArray(shape) && shape.length >= 2, 'invalid renderbuffer shape');
            w = shape[0] | 0;
            h = shape[1] | 0;
          } else {
            if ('radius' in options) {
              w = h = options.radius | 0;
            }
            if ('width' in options) {
              w = options.width | 0;
            }
            if ('height' in options) {
              h = options.height | 0;
            }
          }
          if ('format' in options) {
            check$1.parameter(options.format, formatTypes, 'invalid renderbuffer format');
            format = formatTypes[options.format];
          }
        } else if (typeof a === 'number') {
          w = a | 0;
          if (typeof b === 'number') {
            h = b | 0;
          } else {
            h = w;
          }
        } else if (!a) {
          w = h = 1;
        } else {
          check$1.raise('invalid arguments to renderbuffer constructor');
        }

        // check shape
        check$1(w > 0 && h > 0 && w <= limits.maxRenderbufferSize && h <= limits.maxRenderbufferSize, 'invalid renderbuffer size');

        if (w === renderbuffer.width && h === renderbuffer.height && format === renderbuffer.format) {
          return;
        }

        reglRenderbuffer.width = renderbuffer.width = w;
        reglRenderbuffer.height = renderbuffer.height = h;
        renderbuffer.format = format;

        gl.bindRenderbuffer(GL_RENDERBUFFER, renderbuffer.renderbuffer);
        gl.renderbufferStorage(GL_RENDERBUFFER, format, w, h);

        if (config.profile) {
          renderbuffer.stats.size = getRenderbufferSize(renderbuffer.format, renderbuffer.width, renderbuffer.height);
        }
        reglRenderbuffer.format = formatTypesInvert[renderbuffer.format];

        return reglRenderbuffer;
      }

      function resize(w_, h_) {
        var w = w_ | 0;
        var h = h_ | 0 || w;

        if (w === renderbuffer.width && h === renderbuffer.height) {
          return reglRenderbuffer;
        }

        // check shape
        check$1(w > 0 && h > 0 && w <= limits.maxRenderbufferSize && h <= limits.maxRenderbufferSize, 'invalid renderbuffer size');

        reglRenderbuffer.width = renderbuffer.width = w;
        reglRenderbuffer.height = renderbuffer.height = h;

        gl.bindRenderbuffer(GL_RENDERBUFFER, renderbuffer.renderbuffer);
        gl.renderbufferStorage(GL_RENDERBUFFER, renderbuffer.format, w, h);

        // also, recompute size.
        if (config.profile) {
          renderbuffer.stats.size = getRenderbufferSize(renderbuffer.format, renderbuffer.width, renderbuffer.height);
        }

        return reglRenderbuffer;
      }

      reglRenderbuffer(a, b);

      reglRenderbuffer.resize = resize;
      reglRenderbuffer._reglType = 'renderbuffer';
      reglRenderbuffer._renderbuffer = renderbuffer;
      if (config.profile) {
        reglRenderbuffer.stats = renderbuffer.stats;
      }
      reglRenderbuffer.destroy = function () {
        renderbuffer.decRef();
      };

      return reglRenderbuffer;
    }

    if (config.profile) {
      stats.getTotalRenderbufferSize = function () {
        var total = 0;
        Object.keys(renderbufferSet).forEach(function (key) {
          total += renderbufferSet[key].stats.size;
        });
        return total;
      };
    }

    function restoreRenderbuffers() {
      values(renderbufferSet).forEach(function (rb) {
        rb.renderbuffer = gl.createRenderbuffer();
        gl.bindRenderbuffer(GL_RENDERBUFFER, rb.renderbuffer);
        gl.renderbufferStorage(GL_RENDERBUFFER, rb.format, rb.width, rb.height);
      });
      gl.bindRenderbuffer(GL_RENDERBUFFER, null);
    }

    return {
      create: createRenderbuffer,
      clear: function () {
        values(renderbufferSet).forEach(destroy);
      },
      restore: restoreRenderbuffers
    };
  };

  // We store these constants so that the minifier can inline them
  var GL_FRAMEBUFFER = 0x8D40;
  var GL_RENDERBUFFER$1 = 0x8D41;

  var GL_TEXTURE_2D$1 = 0x0DE1;
  var GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 = 0x8515;

  var GL_COLOR_ATTACHMENT0 = 0x8CE0;
  var GL_DEPTH_ATTACHMENT = 0x8D00;
  var GL_STENCIL_ATTACHMENT = 0x8D20;
  var GL_DEPTH_STENCIL_ATTACHMENT = 0x821A;

  var GL_FRAMEBUFFER_COMPLETE = 0x8CD5;
  var GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 0x8CD6;
  var GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 0x8CD7;
  var GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 0x8CD9;
  var GL_FRAMEBUFFER_UNSUPPORTED = 0x8CDD;

  var GL_HALF_FLOAT_OES$2 = 0x8D61;
  var GL_UNSIGNED_BYTE$5 = 0x1401;
  var GL_FLOAT$4 = 0x1406;

  var GL_RGBA$1 = 0x1908;

  var GL_DEPTH_COMPONENT$1 = 0x1902;

  var colorTextureFormatEnums = [GL_RGBA$1];

  // for every texture format, store
  // the number of channels
  var textureFormatChannels = [];
  textureFormatChannels[GL_RGBA$1] = 4;

  // for every texture type, store
  // the size in bytes.
  var textureTypeSizes = [];
  textureTypeSizes[GL_UNSIGNED_BYTE$5] = 1;
  textureTypeSizes[GL_FLOAT$4] = 4;
  textureTypeSizes[GL_HALF_FLOAT_OES$2] = 2;

  var GL_RGBA4$2 = 0x8056;
  var GL_RGB5_A1$2 = 0x8057;
  var GL_RGB565$2 = 0x8D62;
  var GL_DEPTH_COMPONENT16$1 = 0x81A5;
  var GL_STENCIL_INDEX8$1 = 0x8D48;
  var GL_DEPTH_STENCIL$2 = 0x84F9;

  var GL_SRGB8_ALPHA8_EXT$1 = 0x8C43;

  var GL_RGBA32F_EXT$1 = 0x8814;

  var GL_RGBA16F_EXT$1 = 0x881A;
  var GL_RGB16F_EXT$1 = 0x881B;

  var colorRenderbufferFormatEnums = [GL_RGBA4$2, GL_RGB5_A1$2, GL_RGB565$2, GL_SRGB8_ALPHA8_EXT$1, GL_RGBA16F_EXT$1, GL_RGB16F_EXT$1, GL_RGBA32F_EXT$1];

  var statusCode = {};
  statusCode[GL_FRAMEBUFFER_COMPLETE] = 'complete';
  statusCode[GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT] = 'incomplete attachment';
  statusCode[GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS] = 'incomplete dimensions';
  statusCode[GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT] = 'incomplete, missing attachment';
  statusCode[GL_FRAMEBUFFER_UNSUPPORTED] = 'unsupported';

  function wrapFBOState(gl, extensions, limits, textureState, renderbufferState, stats) {
    var framebufferState = {
      cur: null,
      next: null,
      dirty: false,
      setFBO: null
    };

    var colorTextureFormats = ['rgba'];
    var colorRenderbufferFormats = ['rgba4', 'rgb565', 'rgb5 a1'];

    if (extensions.ext_srgb) {
      colorRenderbufferFormats.push('srgba');
    }

    if (extensions.ext_color_buffer_half_float) {
      colorRenderbufferFormats.push('rgba16f', 'rgb16f');
    }

    if (extensions.webgl_color_buffer_float) {
      colorRenderbufferFormats.push('rgba32f');
    }

    var colorTypes = ['uint8'];
    if (extensions.oes_texture_half_float) {
      colorTypes.push('half float', 'float16');
    }
    if (extensions.oes_texture_float) {
      colorTypes.push('float', 'float32');
    }

    function FramebufferAttachment(target, texture, renderbuffer) {
      this.target = target;
      this.texture = texture;
      this.renderbuffer = renderbuffer;

      var w = 0;
      var h = 0;
      if (texture) {
        w = texture.width;
        h = texture.height;
      } else if (renderbuffer) {
        w = renderbuffer.width;
        h = renderbuffer.height;
      }
      this.width = w;
      this.height = h;
    }

    function decRef(attachment) {
      if (attachment) {
        if (attachment.texture) {
          attachment.texture._texture.decRef();
        }
        if (attachment.renderbuffer) {
          attachment.renderbuffer._renderbuffer.decRef();
        }
      }
    }

    function incRefAndCheckShape(attachment, width, height) {
      if (!attachment) {
        return;
      }
      if (attachment.texture) {
        var texture = attachment.texture._texture;
        var tw = Math.max(1, texture.width);
        var th = Math.max(1, texture.height);
        check$1(tw === width && th === height, 'inconsistent width/height for supplied texture');
        texture.refCount += 1;
      } else {
        var renderbuffer = attachment.renderbuffer._renderbuffer;
        check$1(renderbuffer.width === width && renderbuffer.height === height, 'inconsistent width/height for renderbuffer');
        renderbuffer.refCount += 1;
      }
    }

    function attach(location, attachment) {
      if (attachment) {
        if (attachment.texture) {
          gl.framebufferTexture2D(GL_FRAMEBUFFER, location, attachment.target, attachment.texture._texture.texture, 0);
        } else {
          gl.framebufferRenderbuffer(GL_FRAMEBUFFER, location, GL_RENDERBUFFER$1, attachment.renderbuffer._renderbuffer.renderbuffer);
        }
      }
    }

    function parseAttachment(attachment) {
      var target = GL_TEXTURE_2D$1;
      var texture = null;
      var renderbuffer = null;

      var data = attachment;
      if (typeof attachment === 'object') {
        data = attachment.data;
        if ('target' in attachment) {
          target = attachment.target | 0;
        }
      }

      check$1.type(data, 'function', 'invalid attachment data');

      var type = data._reglType;
      if (type === 'texture2d') {
        texture = data;
        check$1(target === GL_TEXTURE_2D$1);
      } else if (type === 'textureCube') {
        texture = data;
        check$1(target >= GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 && target < GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + 6, 'invalid cube map target');
      } else if (type === 'renderbuffer') {
        renderbuffer = data;
        target = GL_RENDERBUFFER$1;
      } else {
        check$1.raise('invalid regl object for attachment');
      }

      return new FramebufferAttachment(target, texture, renderbuffer);
    }

    function allocAttachment(width, height, isTexture, format, type) {
      if (isTexture) {
        var texture = textureState.create2D({
          width: width,
          height: height,
          format: format,
          type: type
        });
        texture._texture.refCount = 0;
        return new FramebufferAttachment(GL_TEXTURE_2D$1, texture, null);
      } else {
        var rb = renderbufferState.create({
          width: width,
          height: height,
          format: format
        });
        rb._renderbuffer.refCount = 0;
        return new FramebufferAttachment(GL_RENDERBUFFER$1, null, rb);
      }
    }

    function unwrapAttachment(attachment) {
      return attachment && (attachment.texture || attachment.renderbuffer);
    }

    function resizeAttachment(attachment, w, h) {
      if (attachment) {
        if (attachment.texture) {
          attachment.texture.resize(w, h);
        } else if (attachment.renderbuffer) {
          attachment.renderbuffer.resize(w, h);
        }
      }
    }

    var framebufferCount = 0;
    var framebufferSet = {};

    function REGLFramebuffer() {
      this.id = framebufferCount++;
      framebufferSet[this.id] = this;

      this.framebuffer = gl.createFramebuffer();
      this.width = 0;
      this.height = 0;

      this.colorAttachments = [];
      this.depthAttachment = null;
      this.stencilAttachment = null;
      this.depthStencilAttachment = null;
    }

    function decFBORefs(framebuffer) {
      framebuffer.colorAttachments.forEach(decRef);
      decRef(framebuffer.depthAttachment);
      decRef(framebuffer.stencilAttachment);
      decRef(framebuffer.depthStencilAttachment);
    }

    function destroy(framebuffer) {
      var handle = framebuffer.framebuffer;
      check$1(handle, 'must not double destroy framebuffer');
      gl.deleteFramebuffer(handle);
      framebuffer.framebuffer = null;
      stats.framebufferCount--;
      delete framebufferSet[framebuffer.id];
    }

    function updateFramebuffer(framebuffer) {
      var i;

      gl.bindFramebuffer(GL_FRAMEBUFFER, framebuffer.framebuffer);
      var colorAttachments = framebuffer.colorAttachments;
      for (i = 0; i < colorAttachments.length; ++i) {
        attach(GL_COLOR_ATTACHMENT0 + i, colorAttachments[i]);
      }
      for (i = colorAttachments.length; i < limits.maxColorAttachments; ++i) {
        gl.framebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0 + i, GL_TEXTURE_2D$1, null, 0);
      }

      gl.framebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_TEXTURE_2D$1, null, 0);
      gl.framebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D$1, null, 0);
      gl.framebufferTexture2D(GL_FRAMEBUFFER, GL_STENCIL_ATTACHMENT, GL_TEXTURE_2D$1, null, 0);

      attach(GL_DEPTH_ATTACHMENT, framebuffer.depthAttachment);
      attach(GL_STENCIL_ATTACHMENT, framebuffer.stencilAttachment);
      attach(GL_DEPTH_STENCIL_ATTACHMENT, framebuffer.depthStencilAttachment);

      // Check status code
      var status = gl.checkFramebufferStatus(GL_FRAMEBUFFER);
      if (status !== GL_FRAMEBUFFER_COMPLETE) {
        check$1.raise('framebuffer configuration not supported, status = ' + statusCode[status]);
      }

      gl.bindFramebuffer(GL_FRAMEBUFFER, framebufferState.next);
      framebufferState.cur = framebufferState.next;

      // FIXME: Clear error code here.  This is a work around for a bug in
      // headless-gl
      gl.getError();
    }

    function createFBO(a0, a1) {
      var framebuffer = new REGLFramebuffer();
      stats.framebufferCount++;

      function reglFramebuffer(a, b) {
        var i;

        check$1(framebufferState.next !== framebuffer, 'can not update framebuffer which is currently in use');

        var extDrawBuffers = extensions.webgl_draw_buffers;

        var width = 0;
        var height = 0;

        var needsDepth = true;
        var needsStencil = true;

        var colorBuffer = null;
        var colorTexture = true;
        var colorFormat = 'rgba';
        var colorType = 'uint8';
        var colorCount = 1;

        var depthBuffer = null;
        var stencilBuffer = null;
        var depthStencilBuffer = null;
        var depthStencilTexture = false;

        if (typeof a === 'number') {
          width = a | 0;
          height = b | 0 || width;
        } else if (!a) {
          width = height = 1;
        } else {
          check$1.type(a, 'object', 'invalid arguments for framebuffer');
          var options = a;

          if ('shape' in options) {
            var shape = options.shape;
            check$1(Array.isArray(shape) && shape.length >= 2, 'invalid shape for framebuffer');
            width = shape[0];
            height = shape[1];
          } else {
            if ('radius' in options) {
              width = height = options.radius;
            }
            if ('width' in options) {
              width = options.width;
            }
            if ('height' in options) {
              height = options.height;
            }
          }

          if ('color' in options || 'colors' in options) {
            colorBuffer = options.color || options.colors;
            if (Array.isArray(colorBuffer)) {
              check$1(colorBuffer.length === 1 || extDrawBuffers, 'multiple render targets not supported');
            }
          }

          if (!colorBuffer) {
            if ('colorCount' in options) {
              colorCount = options.colorCount | 0;
              check$1(colorCount > 0, 'invalid color buffer count');
            }

            if ('colorTexture' in options) {
              colorTexture = !!options.colorTexture;
              colorFormat = 'rgba4';
            }

            if ('colorType' in options) {
              colorType = options.colorType;
              if (!colorTexture) {
                if (colorType === 'half float' || colorType === 'float16') {
                  check$1(extensions.ext_color_buffer_half_float, 'you must enable EXT_color_buffer_half_float to use 16-bit render buffers');
                  colorFormat = 'rgba16f';
                } else if (colorType === 'float' || colorType === 'float32') {
                  check$1(extensions.webgl_color_buffer_float, 'you must enable WEBGL_color_buffer_float in order to use 32-bit floating point renderbuffers');
                  colorFormat = 'rgba32f';
                }
              } else {
                check$1(extensions.oes_texture_float || !(colorType === 'float' || colorType === 'float32'), 'you must enable OES_texture_float in order to use floating point framebuffer objects');
                check$1(extensions.oes_texture_half_float || !(colorType === 'half float' || colorType === 'float16'), 'you must enable OES_texture_half_float in order to use 16-bit floating point framebuffer objects');
              }
              check$1.oneOf(colorType, colorTypes, 'invalid color type');
            }

            if ('colorFormat' in options) {
              colorFormat = options.colorFormat;
              if (colorTextureFormats.indexOf(colorFormat) >= 0) {
                colorTexture = true;
              } else if (colorRenderbufferFormats.indexOf(colorFormat) >= 0) {
                colorTexture = false;
              } else {
                if (colorTexture) {
                  check$1.oneOf(options.colorFormat, colorTextureFormats, 'invalid color format for texture');
                } else {
                  check$1.oneOf(options.colorFormat, colorRenderbufferFormats, 'invalid color format for renderbuffer');
                }
              }
            }
          }

          if ('depthTexture' in options || 'depthStencilTexture' in options) {
            depthStencilTexture = !!(options.depthTexture || options.depthStencilTexture);
            check$1(!depthStencilTexture || extensions.webgl_depth_texture, 'webgl_depth_texture extension not supported');
          }

          if ('depth' in options) {
            if (typeof options.depth === 'boolean') {
              needsDepth = options.depth;
            } else {
              depthBuffer = options.depth;
              needsStencil = false;
            }
          }

          if ('stencil' in options) {
            if (typeof options.stencil === 'boolean') {
              needsStencil = options.stencil;
            } else {
              stencilBuffer = options.stencil;
              needsDepth = false;
            }
          }

          if ('depthStencil' in options) {
            if (typeof options.depthStencil === 'boolean') {
              needsDepth = needsStencil = options.depthStencil;
            } else {
              depthStencilBuffer = options.depthStencil;
              needsDepth = false;
              needsStencil = false;
            }
          }
        }

        // parse attachments
        var colorAttachments = null;
        var depthAttachment = null;
        var stencilAttachment = null;
        var depthStencilAttachment = null;

        // Set up color attachments
        if (Array.isArray(colorBuffer)) {
          colorAttachments = colorBuffer.map(parseAttachment);
        } else if (colorBuffer) {
          colorAttachments = [parseAttachment(colorBuffer)];
        } else {
          colorAttachments = new Array(colorCount);
          for (i = 0; i < colorCount; ++i) {
            colorAttachments[i] = allocAttachment(width, height, colorTexture, colorFormat, colorType);
          }
        }

        check$1(extensions.webgl_draw_buffers || colorAttachments.length <= 1, 'you must enable the WEBGL_draw_buffers extension in order to use multiple color buffers.');
        check$1(colorAttachments.length <= limits.maxColorAttachments, 'too many color attachments, not supported');

        width = width || colorAttachments[0].width;
        height = height || colorAttachments[0].height;

        if (depthBuffer) {
          depthAttachment = parseAttachment(depthBuffer);
        } else if (needsDepth && !needsStencil) {
          depthAttachment = allocAttachment(width, height, depthStencilTexture, 'depth', 'uint32');
        }

        if (stencilBuffer) {
          stencilAttachment = parseAttachment(stencilBuffer);
        } else if (needsStencil && !needsDepth) {
          stencilAttachment = allocAttachment(width, height, false, 'stencil', 'uint8');
        }

        if (depthStencilBuffer) {
          depthStencilAttachment = parseAttachment(depthStencilBuffer);
        } else if (!depthBuffer && !stencilBuffer && needsStencil && needsDepth) {
          depthStencilAttachment = allocAttachment(width, height, depthStencilTexture, 'depth stencil', 'depth stencil');
        }

        check$1(!!depthBuffer + !!stencilBuffer + !!depthStencilBuffer <= 1, 'invalid framebuffer configuration, can specify exactly one depth/stencil attachment');

        var commonColorAttachmentSize = null;

        for (i = 0; i < colorAttachments.length; ++i) {
          incRefAndCheckShape(colorAttachments[i], width, height);
          check$1(!colorAttachments[i] || colorAttachments[i].texture && colorTextureFormatEnums.indexOf(colorAttachments[i].texture._texture.format) >= 0 || colorAttachments[i].renderbuffer && colorRenderbufferFormatEnums.indexOf(colorAttachments[i].renderbuffer._renderbuffer.format) >= 0, 'framebuffer color attachment ' + i + ' is invalid');

          if (colorAttachments[i] && colorAttachments[i].texture) {
            var colorAttachmentSize = textureFormatChannels[colorAttachments[i].texture._texture.format] * textureTypeSizes[colorAttachments[i].texture._texture.type];

            if (commonColorAttachmentSize === null) {
              commonColorAttachmentSize = colorAttachmentSize;
            } else {
              // We need to make sure that all color attachments have the same number of bitplanes
              // (that is, the same numer of bits per pixel)
              // This is required by the GLES2.0 standard. See the beginning of Chapter 4 in that document.
              check$1(commonColorAttachmentSize === colorAttachmentSize, 'all color attachments much have the same number of bits per pixel.');
            }
          }
        }
        incRefAndCheckShape(depthAttachment, width, height);
        check$1(!depthAttachment || depthAttachment.texture && depthAttachment.texture._texture.format === GL_DEPTH_COMPONENT$1 || depthAttachment.renderbuffer && depthAttachment.renderbuffer._renderbuffer.format === GL_DEPTH_COMPONENT16$1, 'invalid depth attachment for framebuffer object');
        incRefAndCheckShape(stencilAttachment, width, height);
        check$1(!stencilAttachment || stencilAttachment.renderbuffer && stencilAttachment.renderbuffer._renderbuffer.format === GL_STENCIL_INDEX8$1, 'invalid stencil attachment for framebuffer object');
        incRefAndCheckShape(depthStencilAttachment, width, height);
        check$1(!depthStencilAttachment || depthStencilAttachment.texture && depthStencilAttachment.texture._texture.format === GL_DEPTH_STENCIL$2 || depthStencilAttachment.renderbuffer && depthStencilAttachment.renderbuffer._renderbuffer.format === GL_DEPTH_STENCIL$2, 'invalid depth-stencil attachment for framebuffer object');

        // decrement references
        decFBORefs(framebuffer);

        framebuffer.width = width;
        framebuffer.height = height;

        framebuffer.colorAttachments = colorAttachments;
        framebuffer.depthAttachment = depthAttachment;
        framebuffer.stencilAttachment = stencilAttachment;
        framebuffer.depthStencilAttachment = depthStencilAttachment;

        reglFramebuffer.color = colorAttachments.map(unwrapAttachment);
        reglFramebuffer.depth = unwrapAttachment(depthAttachment);
        reglFramebuffer.stencil = unwrapAttachment(stencilAttachment);
        reglFramebuffer.depthStencil = unwrapAttachment(depthStencilAttachment);

        reglFramebuffer.width = framebuffer.width;
        reglFramebuffer.height = framebuffer.height;

        updateFramebuffer(framebuffer);

        return reglFramebuffer;
      }

      function resize(w_, h_) {
        check$1(framebufferState.next !== framebuffer, 'can not resize a framebuffer which is currently in use');

        var w = w_ | 0;
        var h = h_ | 0 || w;
        if (w === framebuffer.width && h === framebuffer.height) {
          return reglFramebuffer;
        }

        // resize all buffers
        var colorAttachments = framebuffer.colorAttachments;
        for (var i = 0; i < colorAttachments.length; ++i) {
          resizeAttachment(colorAttachments[i], w, h);
        }
        resizeAttachment(framebuffer.depthAttachment, w, h);
        resizeAttachment(framebuffer.stencilAttachment, w, h);
        resizeAttachment(framebuffer.depthStencilAttachment, w, h);

        framebuffer.width = reglFramebuffer.width = w;
        framebuffer.height = reglFramebuffer.height = h;

        updateFramebuffer(framebuffer);

        return reglFramebuffer;
      }

      reglFramebuffer(a0, a1);

      return extend(reglFramebuffer, {
        resize: resize,
        _reglType: 'framebuffer',
        _framebuffer: framebuffer,
        destroy: function () {
          destroy(framebuffer);
          decFBORefs(framebuffer);
        },
        use: function (block) {
          framebufferState.setFBO({
            framebuffer: reglFramebuffer
          }, block);
        }
      });
    }

    function createCubeFBO(options) {
      var faces = Array(6);

      function reglFramebufferCube(a) {
        var i;

        check$1(faces.indexOf(framebufferState.next) < 0, 'can not update framebuffer which is currently in use');

        var extDrawBuffers = extensions.webgl_draw_buffers;

        var params = {
          color: null
        };

        var radius = 0;

        var colorBuffer = null;
        var colorFormat = 'rgba';
        var colorType = 'uint8';
        var colorCount = 1;

        if (typeof a === 'number') {
          radius = a | 0;
        } else if (!a) {
          radius = 1;
        } else {
          check$1.type(a, 'object', 'invalid arguments for framebuffer');
          var options = a;

          if ('shape' in options) {
            var shape = options.shape;
            check$1(Array.isArray(shape) && shape.length >= 2, 'invalid shape for framebuffer');
            check$1(shape[0] === shape[1], 'cube framebuffer must be square');
            radius = shape[0];
          } else {
            if ('radius' in options) {
              radius = options.radius | 0;
            }
            if ('width' in options) {
              radius = options.width | 0;
              if ('height' in options) {
                check$1(options.height === radius, 'must be square');
              }
            } else if ('height' in options) {
              radius = options.height | 0;
            }
          }

          if ('color' in options || 'colors' in options) {
            colorBuffer = options.color || options.colors;
            if (Array.isArray(colorBuffer)) {
              check$1(colorBuffer.length === 1 || extDrawBuffers, 'multiple render targets not supported');
            }
          }

          if (!colorBuffer) {
            if ('colorCount' in options) {
              colorCount = options.colorCount | 0;
              check$1(colorCount > 0, 'invalid color buffer count');
            }

            if ('colorType' in options) {
              check$1.oneOf(options.colorType, colorTypes, 'invalid color type');
              colorType = options.colorType;
            }

            if ('colorFormat' in options) {
              colorFormat = options.colorFormat;
              check$1.oneOf(options.colorFormat, colorTextureFormats, 'invalid color format for texture');
            }
          }

          if ('depth' in options) {
            params.depth = options.depth;
          }

          if ('stencil' in options) {
            params.stencil = options.stencil;
          }

          if ('depthStencil' in options) {
            params.depthStencil = options.depthStencil;
          }
        }

        var colorCubes;
        if (colorBuffer) {
          if (Array.isArray(colorBuffer)) {
            colorCubes = [];
            for (i = 0; i < colorBuffer.length; ++i) {
              colorCubes[i] = colorBuffer[i];
            }
          } else {
            colorCubes = [colorBuffer];
          }
        } else {
          colorCubes = Array(colorCount);
          var cubeMapParams = {
            radius: radius,
            format: colorFormat,
            type: colorType
          };
          for (i = 0; i < colorCount; ++i) {
            colorCubes[i] = textureState.createCube(cubeMapParams);
          }
        }

        // Check color cubes
        params.color = Array(colorCubes.length);
        for (i = 0; i < colorCubes.length; ++i) {
          var cube = colorCubes[i];
          check$1(typeof cube === 'function' && cube._reglType === 'textureCube', 'invalid cube map');
          radius = radius || cube.width;
          check$1(cube.width === radius && cube.height === radius, 'invalid cube map shape');
          params.color[i] = {
            target: GL_TEXTURE_CUBE_MAP_POSITIVE_X$1,
            data: colorCubes[i]
          };
        }

        for (i = 0; i < 6; ++i) {
          for (var j = 0; j < colorCubes.length; ++j) {
            params.color[j].target = GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + i;
          }
          // reuse depth-stencil attachments across all cube maps
          if (i > 0) {
            params.depth = faces[0].depth;
            params.stencil = faces[0].stencil;
            params.depthStencil = faces[0].depthStencil;
          }
          if (faces[i]) {
            faces[i](params);
          } else {
            faces[i] = createFBO(params);
          }
        }

        return extend(reglFramebufferCube, {
          width: radius,
          height: radius,
          color: colorCubes
        });
      }

      function resize(radius_) {
        var i;
        var radius = radius_ | 0;
        check$1(radius > 0 && radius <= limits.maxCubeMapSize, 'invalid radius for cube fbo');

        if (radius === reglFramebufferCube.width) {
          return reglFramebufferCube;
        }

        var colors = reglFramebufferCube.color;
        for (i = 0; i < colors.length; ++i) {
          colors[i].resize(radius);
        }

        for (i = 0; i < 6; ++i) {
          faces[i].resize(radius);
        }

        reglFramebufferCube.width = reglFramebufferCube.height = radius;

        return reglFramebufferCube;
      }

      reglFramebufferCube(options);

      return extend(reglFramebufferCube, {
        faces: faces,
        resize: resize,
        _reglType: 'framebufferCube',
        destroy: function () {
          faces.forEach(function (f) {
            f.destroy();
          });
        }
      });
    }

    function restoreFramebuffers() {
      values(framebufferSet).forEach(function (fb) {
        fb.framebuffer = gl.createFramebuffer();
        updateFramebuffer(fb);
      });
    }

    return extend(framebufferState, {
      getFramebuffer: function (object) {
        if (typeof object === 'function' && object._reglType === 'framebuffer') {
          var fbo = object._framebuffer;
          if (fbo instanceof REGLFramebuffer) {
            return fbo;
          }
        }
        return null;
      },
      create: createFBO,
      createCube: createCubeFBO,
      clear: function () {
        values(framebufferSet).forEach(destroy);
      },
      restore: restoreFramebuffers
    });
  }

  var GL_FLOAT$5 = 5126;

  function AttributeRecord() {
    this.state = 0;

    this.x = 0.0;
    this.y = 0.0;
    this.z = 0.0;
    this.w = 0.0;

    this.buffer = null;
    this.size = 0;
    this.normalized = false;
    this.type = GL_FLOAT$5;
    this.offset = 0;
    this.stride = 0;
    this.divisor = 0;
  }

  function wrapAttributeState(gl, extensions, limits, bufferState, stringStore) {
    var NUM_ATTRIBUTES = limits.maxAttributes;
    var attributeBindings = new Array(NUM_ATTRIBUTES);
    for (var i = 0; i < NUM_ATTRIBUTES; ++i) {
      attributeBindings[i] = new AttributeRecord();
    }

    return {
      Record: AttributeRecord,
      scope: {},
      state: attributeBindings
    };
  }

  var GL_FRAGMENT_SHADER = 35632;
  var GL_VERTEX_SHADER = 35633;

  var GL_ACTIVE_UNIFORMS = 0x8B86;
  var GL_ACTIVE_ATTRIBUTES = 0x8B89;

  function wrapShaderState(gl, stringStore, stats, config) {
    // ===================================================
    // glsl compilation and linking
    // ===================================================
    var fragShaders = {};
    var vertShaders = {};

    function ActiveInfo(name, id, location, info) {
      this.name = name;
      this.id = id;
      this.location = location;
      this.info = info;
    }

    function insertActiveInfo(list, info) {
      for (var i = 0; i < list.length; ++i) {
        if (list[i].id === info.id) {
          list[i].location = info.location;
          return;
        }
      }
      list.push(info);
    }

    function getShader(type, id, command) {
      var cache = type === GL_FRAGMENT_SHADER ? fragShaders : vertShaders;
      var shader = cache[id];

      if (!shader) {
        var source = stringStore.str(id);
        shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        check$1.shaderError(gl, shader, source, type, command);
        cache[id] = shader;
      }

      return shader;
    }

    // ===================================================
    // program linking
    // ===================================================
    var programCache = {};
    var programList = [];

    var PROGRAM_COUNTER = 0;

    function REGLProgram(fragId, vertId) {
      this.id = PROGRAM_COUNTER++;
      this.fragId = fragId;
      this.vertId = vertId;
      this.program = null;
      this.uniforms = [];
      this.attributes = [];

      if (config.profile) {
        this.stats = {
          uniformsCount: 0,
          attributesCount: 0
        };
      }
    }

    function linkProgram(desc, command) {
      var i, info;

      // -------------------------------
      // compile & link
      // -------------------------------
      var fragShader = getShader(GL_FRAGMENT_SHADER, desc.fragId);
      var vertShader = getShader(GL_VERTEX_SHADER, desc.vertId);

      var program = desc.program = gl.createProgram();
      gl.attachShader(program, fragShader);
      gl.attachShader(program, vertShader);
      gl.linkProgram(program);
      check$1.linkError(gl, program, stringStore.str(desc.fragId), stringStore.str(desc.vertId), command);

      // -------------------------------
      // grab uniforms
      // -------------------------------
      var numUniforms = gl.getProgramParameter(program, GL_ACTIVE_UNIFORMS);
      if (config.profile) {
        desc.stats.uniformsCount = numUniforms;
      }
      var uniforms = desc.uniforms;
      for (i = 0; i < numUniforms; ++i) {
        info = gl.getActiveUniform(program, i);
        if (info) {
          if (info.size > 1) {
            for (var j = 0; j < info.size; ++j) {
              var name = info.name.replace('[0]', '[' + j + ']');
              insertActiveInfo(uniforms, new ActiveInfo(name, stringStore.id(name), gl.getUniformLocation(program, name), info));
            }
          } else {
            insertActiveInfo(uniforms, new ActiveInfo(info.name, stringStore.id(info.name), gl.getUniformLocation(program, info.name), info));
          }
        }
      }

      // -------------------------------
      // grab attributes
      // -------------------------------
      var numAttributes = gl.getProgramParameter(program, GL_ACTIVE_ATTRIBUTES);
      if (config.profile) {
        desc.stats.attributesCount = numAttributes;
      }

      var attributes = desc.attributes;
      for (i = 0; i < numAttributes; ++i) {
        info = gl.getActiveAttrib(program, i);
        if (info) {
          insertActiveInfo(attributes, new ActiveInfo(info.name, stringStore.id(info.name), gl.getAttribLocation(program, info.name), info));
        }
      }
    }

    if (config.profile) {
      stats.getMaxUniformsCount = function () {
        var m = 0;
        programList.forEach(function (desc) {
          if (desc.stats.uniformsCount > m) {
            m = desc.stats.uniformsCount;
          }
        });
        return m;
      };

      stats.getMaxAttributesCount = function () {
        var m = 0;
        programList.forEach(function (desc) {
          if (desc.stats.attributesCount > m) {
            m = desc.stats.attributesCount;
          }
        });
        return m;
      };
    }

    function restoreShaders() {
      fragShaders = {};
      vertShaders = {};
      for (var i = 0; i < programList.length; ++i) {
        linkProgram(programList[i]);
      }
    }

    return {
      clear: function () {
        var deleteShader = gl.deleteShader.bind(gl);
        values(fragShaders).forEach(deleteShader);
        fragShaders = {};
        values(vertShaders).forEach(deleteShader);
        vertShaders = {};

        programList.forEach(function (desc) {
          gl.deleteProgram(desc.program);
        });
        programList.length = 0;
        programCache = {};

        stats.shaderCount = 0;
      },

      program: function (vertId, fragId, command) {
        check$1.command(vertId >= 0, 'missing vertex shader', command);
        check$1.command(fragId >= 0, 'missing fragment shader', command);

        var cache = programCache[fragId];
        if (!cache) {
          cache = programCache[fragId] = {};
        }
        var program = cache[vertId];
        if (!program) {
          program = new REGLProgram(fragId, vertId);
          stats.shaderCount++;

          linkProgram(program, command);
          cache[vertId] = program;
          programList.push(program);
        }
        return program;
      },

      restore: restoreShaders,

      shader: getShader,

      frag: -1,
      vert: -1
    };
  }

  var GL_RGBA$2 = 6408;
  var GL_UNSIGNED_BYTE$6 = 5121;
  var GL_PACK_ALIGNMENT = 0x0D05;
  var GL_FLOAT$6 = 0x1406; // 5126

  function wrapReadPixels(gl, framebufferState, reglPoll, context, glAttributes, extensions) {
    function readPixelsImpl(input) {
      var type;
      if (framebufferState.next === null) {
        check$1(glAttributes.preserveDrawingBuffer, 'you must create a webgl context with "preserveDrawingBuffer":true in order to read pixels from the drawing buffer');
        type = GL_UNSIGNED_BYTE$6;
      } else {
        check$1(framebufferState.next.colorAttachments[0].texture !== null, 'You cannot read from a renderbuffer');
        type = framebufferState.next.colorAttachments[0].texture._texture.type;

        if (extensions.oes_texture_float) {
          check$1(type === GL_UNSIGNED_BYTE$6 || type === GL_FLOAT$6, 'Reading from a framebuffer is only allowed for the types \'uint8\' and \'float\'');
        } else {
          check$1(type === GL_UNSIGNED_BYTE$6, 'Reading from a framebuffer is only allowed for the type \'uint8\'');
        }
      }

      var x = 0;
      var y = 0;
      var width = context.framebufferWidth;
      var height = context.framebufferHeight;
      var data = null;

      if (isTypedArray(input)) {
        data = input;
      } else if (input) {
        check$1.type(input, 'object', 'invalid arguments to regl.read()');
        x = input.x | 0;
        y = input.y | 0;
        check$1(x >= 0 && x < context.framebufferWidth, 'invalid x offset for regl.read');
        check$1(y >= 0 && y < context.framebufferHeight, 'invalid y offset for regl.read');
        width = (input.width || context.framebufferWidth - x) | 0;
        height = (input.height || context.framebufferHeight - y) | 0;
        data = input.data || null;
      }

      // sanity check input.data
      if (data) {
        if (type === GL_UNSIGNED_BYTE$6) {
          check$1(data instanceof Uint8Array, 'buffer must be \'Uint8Array\' when reading from a framebuffer of type \'uint8\'');
        } else if (type === GL_FLOAT$6) {
          check$1(data instanceof Float32Array, 'buffer must be \'Float32Array\' when reading from a framebuffer of type \'float\'');
        }
      }

      check$1(width > 0 && width + x <= context.framebufferWidth, 'invalid width for read pixels');
      check$1(height > 0 && height + y <= context.framebufferHeight, 'invalid height for read pixels');

      // Update WebGL state
      reglPoll();

      // Compute size
      var size = width * height * 4;

      // Allocate data
      if (!data) {
        if (type === GL_UNSIGNED_BYTE$6) {
          data = new Uint8Array(size);
        } else if (type === GL_FLOAT$6) {
          data = data || new Float32Array(size);
        }
      }

      // Type check
      check$1.isTypedArray(data, 'data buffer for regl.read() must be a typedarray');
      check$1(data.byteLength >= size, 'data buffer for regl.read() too small');

      // Run read pixels
      gl.pixelStorei(GL_PACK_ALIGNMENT, 4);
      gl.readPixels(x, y, width, height, GL_RGBA$2, type, data);

      return data;
    }

    function readPixelsFBO(options) {
      var result;
      framebufferState.setFBO({
        framebuffer: options.framebuffer
      }, function () {
        result = readPixelsImpl(options);
      });
      return result;
    }

    function readPixels(options) {
      if (!options || !('framebuffer' in options)) {
        return readPixelsImpl(options);
      } else {
        return readPixelsFBO(options);
      }
    }

    return readPixels;
  }

  function slice(x) {
    return Array.prototype.slice.call(x);
  }

  function join(x) {
    return slice(x).join('');
  }

  function createEnvironment() {
    // Unique variable id counter
    var varCounter = 0;

    // Linked values are passed from this scope into the generated code block
    // Calling link() passes a value into the generated scope and returns
    // the variable name which it is bound to
    var linkedNames = [];
    var linkedValues = [];
    function link(value) {
      for (var i = 0; i < linkedValues.length; ++i) {
        if (linkedValues[i] === value) {
          return linkedNames[i];
        }
      }

      var name = 'g' + varCounter++;
      linkedNames.push(name);
      linkedValues.push(value);
      return name;
    }

    // create a code block
    function block() {
      var code = [];
      function push() {
        code.push.apply(code, slice(arguments));
      }

      var vars = [];
      function def() {
        var name = 'v' + varCounter++;
        vars.push(name);

        if (arguments.length > 0) {
          code.push(name, '=');
          code.push.apply(code, slice(arguments));
          code.push(';');
        }

        return name;
      }

      return extend(push, {
        def: def,
        toString: function () {
          return join([vars.length > 0 ? 'var ' + vars + ';' : '', join(code)]);
        }
      });
    }

    function scope() {
      var entry = block();
      var exit = block();

      var entryToString = entry.toString;
      var exitToString = exit.toString;

      function save(object, prop) {
        exit(object, prop, '=', entry.def(object, prop), ';');
      }

      return extend(function () {
        entry.apply(entry, slice(arguments));
      }, {
        def: entry.def,
        entry: entry,
        exit: exit,
        save: save,
        set: function (object, prop, value) {
          save(object, prop);
          entry(object, prop, '=', value, ';');
        },
        toString: function () {
          return entryToString() + exitToString();
        }
      });
    }

    function conditional() {
      var pred = join(arguments);
      var thenBlock = scope();
      var elseBlock = scope();

      var thenToString = thenBlock.toString;
      var elseToString = elseBlock.toString;

      return extend(thenBlock, {
        then: function () {
          thenBlock.apply(thenBlock, slice(arguments));
          return this;
        },
        else: function () {
          elseBlock.apply(elseBlock, slice(arguments));
          return this;
        },
        toString: function () {
          var elseClause = elseToString();
          if (elseClause) {
            elseClause = 'else{' + elseClause + '}';
          }
          return join(['if(', pred, '){', thenToString(), '}', elseClause]);
        }
      });
    }

    // procedure list
    var globalBlock = block();
    var procedures = {};
    function proc(name, count) {
      var args = [];
      function arg() {
        var name = 'a' + args.length;
        args.push(name);
        return name;
      }

      count = count || 0;
      for (var i = 0; i < count; ++i) {
        arg();
      }

      var body = scope();
      var bodyToString = body.toString;

      var result = procedures[name] = extend(body, {
        arg: arg,
        toString: function () {
          return join(['function(', args.join(), '){', bodyToString(), '}']);
        }
      });

      return result;
    }

    function compile() {
      var code = ['"use strict";', globalBlock, 'return {'];
      Object.keys(procedures).forEach(function (name) {
        code.push('"', name, '":', procedures[name].toString(), ',');
      });
      code.push('}');
      var src = join(code).replace(/;/g, ';\n').replace(/}/g, '}\n').replace(/{/g, '{\n');
      var proc = Function.apply(null, linkedNames.concat(src));
      return proc.apply(null, linkedValues);
    }

    return {
      global: globalBlock,
      link: link,
      block: block,
      proc: proc,
      scope: scope,
      cond: conditional,
      compile: compile
    };
  }

  // "cute" names for vector components
  var CUTE_COMPONENTS = 'xyzw'.split('');

  var GL_UNSIGNED_BYTE$7 = 5121;

  var ATTRIB_STATE_POINTER = 1;
  var ATTRIB_STATE_CONSTANT = 2;

  var DYN_FUNC$1 = 0;
  var DYN_PROP$1 = 1;
  var DYN_CONTEXT$1 = 2;
  var DYN_STATE$1 = 3;
  var DYN_THUNK = 4;

  var S_DITHER = 'dither';
  var S_BLEND_ENABLE = 'blend.enable';
  var S_BLEND_COLOR = 'blend.color';
  var S_BLEND_EQUATION = 'blend.equation';
  var S_BLEND_FUNC = 'blend.func';
  var S_DEPTH_ENABLE = 'depth.enable';
  var S_DEPTH_FUNC = 'depth.func';
  var S_DEPTH_RANGE = 'depth.range';
  var S_DEPTH_MASK = 'depth.mask';
  var S_COLOR_MASK = 'colorMask';
  var S_CULL_ENABLE = 'cull.enable';
  var S_CULL_FACE = 'cull.face';
  var S_FRONT_FACE = 'frontFace';
  var S_LINE_WIDTH = 'lineWidth';
  var S_POLYGON_OFFSET_ENABLE = 'polygonOffset.enable';
  var S_POLYGON_OFFSET_OFFSET = 'polygonOffset.offset';
  var S_SAMPLE_ALPHA = 'sample.alpha';
  var S_SAMPLE_ENABLE = 'sample.enable';
  var S_SAMPLE_COVERAGE = 'sample.coverage';
  var S_STENCIL_ENABLE = 'stencil.enable';
  var S_STENCIL_MASK = 'stencil.mask';
  var S_STENCIL_FUNC = 'stencil.func';
  var S_STENCIL_OPFRONT = 'stencil.opFront';
  var S_STENCIL_OPBACK = 'stencil.opBack';
  var S_SCISSOR_ENABLE = 'scissor.enable';
  var S_SCISSOR_BOX = 'scissor.box';
  var S_VIEWPORT = 'viewport';

  var S_PROFILE = 'profile';

  var S_FRAMEBUFFER = 'framebuffer';
  var S_VERT = 'vert';
  var S_FRAG = 'frag';
  var S_ELEMENTS = 'elements';
  var S_PRIMITIVE = 'primitive';
  var S_COUNT = 'count';
  var S_OFFSET = 'offset';
  var S_INSTANCES = 'instances';

  var SUFFIX_WIDTH = 'Width';
  var SUFFIX_HEIGHT = 'Height';

  var S_FRAMEBUFFER_WIDTH = S_FRAMEBUFFER + SUFFIX_WIDTH;
  var S_FRAMEBUFFER_HEIGHT = S_FRAMEBUFFER + SUFFIX_HEIGHT;
  var S_VIEWPORT_WIDTH = S_VIEWPORT + SUFFIX_WIDTH;
  var S_VIEWPORT_HEIGHT = S_VIEWPORT + SUFFIX_HEIGHT;
  var S_DRAWINGBUFFER = 'drawingBuffer';
  var S_DRAWINGBUFFER_WIDTH = S_DRAWINGBUFFER + SUFFIX_WIDTH;
  var S_DRAWINGBUFFER_HEIGHT = S_DRAWINGBUFFER + SUFFIX_HEIGHT;

  var NESTED_OPTIONS = [S_BLEND_FUNC, S_BLEND_EQUATION, S_STENCIL_FUNC, S_STENCIL_OPFRONT, S_STENCIL_OPBACK, S_SAMPLE_COVERAGE, S_VIEWPORT, S_SCISSOR_BOX, S_POLYGON_OFFSET_OFFSET];

  var GL_ARRAY_BUFFER$1 = 34962;
  var GL_ELEMENT_ARRAY_BUFFER$1 = 34963;

  var GL_FRAGMENT_SHADER$1 = 35632;
  var GL_VERTEX_SHADER$1 = 35633;

  var GL_TEXTURE_2D$2 = 0x0DE1;
  var GL_TEXTURE_CUBE_MAP$1 = 0x8513;

  var GL_CULL_FACE = 0x0B44;
  var GL_BLEND = 0x0BE2;
  var GL_DITHER = 0x0BD0;
  var GL_STENCIL_TEST = 0x0B90;
  var GL_DEPTH_TEST = 0x0B71;
  var GL_SCISSOR_TEST = 0x0C11;
  var GL_POLYGON_OFFSET_FILL = 0x8037;
  var GL_SAMPLE_ALPHA_TO_COVERAGE = 0x809E;
  var GL_SAMPLE_COVERAGE = 0x80A0;

  var GL_FLOAT$7 = 5126;
  var GL_FLOAT_VEC2 = 35664;
  var GL_FLOAT_VEC3 = 35665;
  var GL_FLOAT_VEC4 = 35666;
  var GL_INT$3 = 5124;
  var GL_INT_VEC2 = 35667;
  var GL_INT_VEC3 = 35668;
  var GL_INT_VEC4 = 35669;
  var GL_BOOL = 35670;
  var GL_BOOL_VEC2 = 35671;
  var GL_BOOL_VEC3 = 35672;
  var GL_BOOL_VEC4 = 35673;
  var GL_FLOAT_MAT2 = 35674;
  var GL_FLOAT_MAT3 = 35675;
  var GL_FLOAT_MAT4 = 35676;
  var GL_SAMPLER_2D = 35678;
  var GL_SAMPLER_CUBE = 35680;

  var GL_TRIANGLES$1 = 4;

  var GL_FRONT = 1028;
  var GL_BACK = 1029;
  var GL_CW = 0x0900;
  var GL_CCW = 0x0901;
  var GL_MIN_EXT = 0x8007;
  var GL_MAX_EXT = 0x8008;
  var GL_ALWAYS = 519;
  var GL_KEEP = 7680;
  var GL_ZERO = 0;
  var GL_ONE = 1;
  var GL_FUNC_ADD = 0x8006;
  var GL_LESS = 513;

  var GL_FRAMEBUFFER$1 = 0x8D40;
  var GL_COLOR_ATTACHMENT0$1 = 0x8CE0;

  var blendFuncs = {
    '0': 0,
    '1': 1,
    'zero': 0,
    'one': 1,
    'src color': 768,
    'one minus src color': 769,
    'src alpha': 770,
    'one minus src alpha': 771,
    'dst color': 774,
    'one minus dst color': 775,
    'dst alpha': 772,
    'one minus dst alpha': 773,
    'constant color': 32769,
    'one minus constant color': 32770,
    'constant alpha': 32771,
    'one minus constant alpha': 32772,
    'src alpha saturate': 776
  };

  // There are invalid values for srcRGB and dstRGB. See:
  // https://www.khronos.org/registry/webgl/specs/1.0/#6.13
  // https://github.com/KhronosGroup/WebGL/blob/0d3201f5f7ec3c0060bc1f04077461541f1987b9/conformance-suites/1.0.3/conformance/misc/webgl-specific.html#L56
  var invalidBlendCombinations = ['constant color, constant alpha', 'one minus constant color, constant alpha', 'constant color, one minus constant alpha', 'one minus constant color, one minus constant alpha', 'constant alpha, constant color', 'constant alpha, one minus constant color', 'one minus constant alpha, constant color', 'one minus constant alpha, one minus constant color'];

  var compareFuncs = {
    'never': 512,
    'less': 513,
    '<': 513,
    'equal': 514,
    '=': 514,
    '==': 514,
    '===': 514,
    'lequal': 515,
    '<=': 515,
    'greater': 516,
    '>': 516,
    'notequal': 517,
    '!=': 517,
    '!==': 517,
    'gequal': 518,
    '>=': 518,
    'always': 519
  };

  var stencilOps = {
    '0': 0,
    'zero': 0,
    'keep': 7680,
    'replace': 7681,
    'increment': 7682,
    'decrement': 7683,
    'increment wrap': 34055,
    'decrement wrap': 34056,
    'invert': 5386
  };

  var shaderType = {
    'frag': GL_FRAGMENT_SHADER$1,
    'vert': GL_VERTEX_SHADER$1
  };

  var orientationType = {
    'cw': GL_CW,
    'ccw': GL_CCW
  };

  function isBufferArgs(x) {
    return Array.isArray(x) || isTypedArray(x) || isNDArrayLike(x);
  }

  // Make sure viewport is processed first
  function sortState(state) {
    return state.sort(function (a, b) {
      if (a === S_VIEWPORT) {
        return -1;
      } else if (b === S_VIEWPORT) {
        return 1;
      }
      return a < b ? -1 : 1;
    });
  }

  function Declaration(thisDep, contextDep, propDep, append) {
    this.thisDep = thisDep;
    this.contextDep = contextDep;
    this.propDep = propDep;
    this.append = append;
  }

  function isStatic(decl) {
    return decl && !(decl.thisDep || decl.contextDep || decl.propDep);
  }

  function createStaticDecl(append) {
    return new Declaration(false, false, false, append);
  }

  function createDynamicDecl(dyn, append) {
    var type = dyn.type;
    if (type === DYN_FUNC$1) {
      var numArgs = dyn.data.length;
      return new Declaration(true, numArgs >= 1, numArgs >= 2, append);
    } else if (type === DYN_THUNK) {
      var data = dyn.data;
      return new Declaration(data.thisDep, data.contextDep, data.propDep, append);
    } else {
      return new Declaration(type === DYN_STATE$1, type === DYN_CONTEXT$1, type === DYN_PROP$1, append);
    }
  }

  var SCOPE_DECL = new Declaration(false, false, false, function () {});

  function reglCore(gl, stringStore, extensions, limits, bufferState, elementState, textureState, framebufferState, uniformState, attributeState, shaderState, drawState, contextState, timer, config) {
    var AttributeRecord = attributeState.Record;

    var blendEquations = {
      'add': 32774,
      'subtract': 32778,
      'reverse subtract': 32779
    };
    if (extensions.ext_blend_minmax) {
      blendEquations.min = GL_MIN_EXT;
      blendEquations.max = GL_MAX_EXT;
    }

    var extInstancing = extensions.angle_instanced_arrays;
    var extDrawBuffers = extensions.webgl_draw_buffers;

    // ===================================================
    // ===================================================
    // WEBGL STATE
    // ===================================================
    // ===================================================
    var currentState = {
      dirty: true,
      profile: config.profile
    };
    var nextState = {};
    var GL_STATE_NAMES = [];
    var GL_FLAGS = {};
    var GL_VARIABLES = {};

    function propName(name) {
      return name.replace('.', '_');
    }

    function stateFlag(sname, cap, init) {
      var name = propName(sname);
      GL_STATE_NAMES.push(sname);
      nextState[name] = currentState[name] = !!init;
      GL_FLAGS[name] = cap;
    }

    function stateVariable(sname, func, init) {
      var name = propName(sname);
      GL_STATE_NAMES.push(sname);
      if (Array.isArray(init)) {
        currentState[name] = init.slice();
        nextState[name] = init.slice();
      } else {
        currentState[name] = nextState[name] = init;
      }
      GL_VARIABLES[name] = func;
    }

    // Dithering
    stateFlag(S_DITHER, GL_DITHER);

    // Blending
    stateFlag(S_BLEND_ENABLE, GL_BLEND);
    stateVariable(S_BLEND_COLOR, 'blendColor', [0, 0, 0, 0]);
    stateVariable(S_BLEND_EQUATION, 'blendEquationSeparate', [GL_FUNC_ADD, GL_FUNC_ADD]);
    stateVariable(S_BLEND_FUNC, 'blendFuncSeparate', [GL_ONE, GL_ZERO, GL_ONE, GL_ZERO]);

    // Depth
    stateFlag(S_DEPTH_ENABLE, GL_DEPTH_TEST, true);
    stateVariable(S_DEPTH_FUNC, 'depthFunc', GL_LESS);
    stateVariable(S_DEPTH_RANGE, 'depthRange', [0, 1]);
    stateVariable(S_DEPTH_MASK, 'depthMask', true);

    // Color mask
    stateVariable(S_COLOR_MASK, S_COLOR_MASK, [true, true, true, true]);

    // Face culling
    stateFlag(S_CULL_ENABLE, GL_CULL_FACE);
    stateVariable(S_CULL_FACE, 'cullFace', GL_BACK);

    // Front face orientation
    stateVariable(S_FRONT_FACE, S_FRONT_FACE, GL_CCW);

    // Line width
    stateVariable(S_LINE_WIDTH, S_LINE_WIDTH, 1);

    // Polygon offset
    stateFlag(S_POLYGON_OFFSET_ENABLE, GL_POLYGON_OFFSET_FILL);
    stateVariable(S_POLYGON_OFFSET_OFFSET, 'polygonOffset', [0, 0]);

    // Sample coverage
    stateFlag(S_SAMPLE_ALPHA, GL_SAMPLE_ALPHA_TO_COVERAGE);
    stateFlag(S_SAMPLE_ENABLE, GL_SAMPLE_COVERAGE);
    stateVariable(S_SAMPLE_COVERAGE, 'sampleCoverage', [1, false]);

    // Stencil
    stateFlag(S_STENCIL_ENABLE, GL_STENCIL_TEST);
    stateVariable(S_STENCIL_MASK, 'stencilMask', -1);
    stateVariable(S_STENCIL_FUNC, 'stencilFunc', [GL_ALWAYS, 0, -1]);
    stateVariable(S_STENCIL_OPFRONT, 'stencilOpSeparate', [GL_FRONT, GL_KEEP, GL_KEEP, GL_KEEP]);
    stateVariable(S_STENCIL_OPBACK, 'stencilOpSeparate', [GL_BACK, GL_KEEP, GL_KEEP, GL_KEEP]);

    // Scissor
    stateFlag(S_SCISSOR_ENABLE, GL_SCISSOR_TEST);
    stateVariable(S_SCISSOR_BOX, 'scissor', [0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight]);

    // Viewport
    stateVariable(S_VIEWPORT, S_VIEWPORT, [0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight]);

    // ===================================================
    // ===================================================
    // ENVIRONMENT
    // ===================================================
    // ===================================================
    var sharedState = {
      gl: gl,
      context: contextState,
      strings: stringStore,
      next: nextState,
      current: currentState,
      draw: drawState,
      elements: elementState,
      buffer: bufferState,
      shader: shaderState,
      attributes: attributeState.state,
      uniforms: uniformState,
      framebuffer: framebufferState,
      extensions: extensions,

      timer: timer,
      isBufferArgs: isBufferArgs
    };

    var sharedConstants = {
      primTypes: primTypes,
      compareFuncs: compareFuncs,
      blendFuncs: blendFuncs,
      blendEquations: blendEquations,
      stencilOps: stencilOps,
      glTypes: glTypes,
      orientationType: orientationType
    };

    check$1.optional(function () {
      sharedState.isArrayLike = isArrayLike;
    });

    if (extDrawBuffers) {
      sharedConstants.backBuffer = [GL_BACK];
      sharedConstants.drawBuffer = loop(limits.maxDrawbuffers, function (i) {
        if (i === 0) {
          return [0];
        }
        return loop(i, function (j) {
          return GL_COLOR_ATTACHMENT0$1 + j;
        });
      });
    }

    var drawCallCounter = 0;
    function createREGLEnvironment() {
      var env = createEnvironment();
      var link = env.link;
      var global = env.global;
      env.id = drawCallCounter++;

      env.batchId = '0';

      // link shared state
      var SHARED = link(sharedState);
      var shared = env.shared = {
        props: 'a0'
      };
      Object.keys(sharedState).forEach(function (prop) {
        shared[prop] = global.def(SHARED, '.', prop);
      });

      // Inject runtime assertion stuff for debug builds
      check$1.optional(function () {
        env.CHECK = link(check$1);
        env.commandStr = check$1.guessCommand();
        env.command = link(env.commandStr);
        env.assert = function (block, pred, message) {
          block('if(!(', pred, '))', this.CHECK, '.commandRaise(', link(message), ',', this.command, ');');
        };

        sharedConstants.invalidBlendCombinations = invalidBlendCombinations;
      });

      // Copy GL state variables over
      var nextVars = env.next = {};
      var currentVars = env.current = {};
      Object.keys(GL_VARIABLES).forEach(function (variable) {
        if (Array.isArray(currentState[variable])) {
          nextVars[variable] = global.def(shared.next, '.', variable);
          currentVars[variable] = global.def(shared.current, '.', variable);
        }
      });

      // Initialize shared constants
      var constants = env.constants = {};
      Object.keys(sharedConstants).forEach(function (name) {
        constants[name] = global.def(JSON.stringify(sharedConstants[name]));
      });

      // Helper function for calling a block
      env.invoke = function (block, x) {
        switch (x.type) {
          case DYN_FUNC$1:
            var argList = ['this', shared.context, shared.props, env.batchId];
            return block.def(link(x.data), '.call(', argList.slice(0, Math.max(x.data.length + 1, 4)), ')');
          case DYN_PROP$1:
            return block.def(shared.props, x.data);
          case DYN_CONTEXT$1:
            return block.def(shared.context, x.data);
          case DYN_STATE$1:
            return block.def('this', x.data);
          case DYN_THUNK:
            x.data.append(env, block);
            return x.data.ref;
        }
      };

      env.attribCache = {};

      var scopeAttribs = {};
      env.scopeAttrib = function (name) {
        var id = stringStore.id(name);
        if (id in scopeAttribs) {
          return scopeAttribs[id];
        }
        var binding = attributeState.scope[id];
        if (!binding) {
          binding = attributeState.scope[id] = new AttributeRecord();
        }
        var result = scopeAttribs[id] = link(binding);
        return result;
      };

      return env;
    }

    // ===================================================
    // ===================================================
    // PARSING
    // ===================================================
    // ===================================================
    function parseProfile(options) {
      var staticOptions = options.static;
      var dynamicOptions = options.dynamic;

      var profileEnable;
      if (S_PROFILE in staticOptions) {
        var value = !!staticOptions[S_PROFILE];
        profileEnable = createStaticDecl(function (env, scope) {
          return value;
        });
        profileEnable.enable = value;
      } else if (S_PROFILE in dynamicOptions) {
        var dyn = dynamicOptions[S_PROFILE];
        profileEnable = createDynamicDecl(dyn, function (env, scope) {
          return env.invoke(scope, dyn);
        });
      }

      return profileEnable;
    }

    function parseFramebuffer(options, env) {
      var staticOptions = options.static;
      var dynamicOptions = options.dynamic;

      if (S_FRAMEBUFFER in staticOptions) {
        var framebuffer = staticOptions[S_FRAMEBUFFER];
        if (framebuffer) {
          framebuffer = framebufferState.getFramebuffer(framebuffer);
          check$1.command(framebuffer, 'invalid framebuffer object');
          return createStaticDecl(function (env, block) {
            var FRAMEBUFFER = env.link(framebuffer);
            var shared = env.shared;
            block.set(shared.framebuffer, '.next', FRAMEBUFFER);
            var CONTEXT = shared.context;
            block.set(CONTEXT, '.' + S_FRAMEBUFFER_WIDTH, FRAMEBUFFER + '.width');
            block.set(CONTEXT, '.' + S_FRAMEBUFFER_HEIGHT, FRAMEBUFFER + '.height');
            return FRAMEBUFFER;
          });
        } else {
          return createStaticDecl(function (env, scope) {
            var shared = env.shared;
            scope.set(shared.framebuffer, '.next', 'null');
            var CONTEXT = shared.context;
            scope.set(CONTEXT, '.' + S_FRAMEBUFFER_WIDTH, CONTEXT + '.' + S_DRAWINGBUFFER_WIDTH);
            scope.set(CONTEXT, '.' + S_FRAMEBUFFER_HEIGHT, CONTEXT + '.' + S_DRAWINGBUFFER_HEIGHT);
            return 'null';
          });
        }
      } else if (S_FRAMEBUFFER in dynamicOptions) {
        var dyn = dynamicOptions[S_FRAMEBUFFER];
        return createDynamicDecl(dyn, function (env, scope) {
          var FRAMEBUFFER_FUNC = env.invoke(scope, dyn);
          var shared = env.shared;
          var FRAMEBUFFER_STATE = shared.framebuffer;
          var FRAMEBUFFER = scope.def(FRAMEBUFFER_STATE, '.getFramebuffer(', FRAMEBUFFER_FUNC, ')');

          check$1.optional(function () {
            env.assert(scope, '!' + FRAMEBUFFER_FUNC + '||' + FRAMEBUFFER, 'invalid framebuffer object');
          });

          scope.set(FRAMEBUFFER_STATE, '.next', FRAMEBUFFER);
          var CONTEXT = shared.context;
          scope.set(CONTEXT, '.' + S_FRAMEBUFFER_WIDTH, FRAMEBUFFER + '?' + FRAMEBUFFER + '.width:' + CONTEXT + '.' + S_DRAWINGBUFFER_WIDTH);
          scope.set(CONTEXT, '.' + S_FRAMEBUFFER_HEIGHT, FRAMEBUFFER + '?' + FRAMEBUFFER + '.height:' + CONTEXT + '.' + S_DRAWINGBUFFER_HEIGHT);
          return FRAMEBUFFER;
        });
      } else {
        return null;
      }
    }

    function parseViewportScissor(options, framebuffer, env) {
      var staticOptions = options.static;
      var dynamicOptions = options.dynamic;

      function parseBox(param) {
        if (param in staticOptions) {
          var box = staticOptions[param];
          check$1.commandType(box, 'object', 'invalid ' + param, env.commandStr);

          var isStatic = true;
          var x = box.x | 0;
          var y = box.y | 0;
          var w, h;
          if ('width' in box) {
            w = box.width | 0;
            check$1.command(w >= 0, 'invalid ' + param, env.commandStr);
          } else {
            isStatic = false;
          }
          if ('height' in box) {
            h = box.height | 0;
            check$1.command(h >= 0, 'invalid ' + param, env.commandStr);
          } else {
            isStatic = false;
          }

          return new Declaration(!isStatic && framebuffer && framebuffer.thisDep, !isStatic && framebuffer && framebuffer.contextDep, !isStatic && framebuffer && framebuffer.propDep, function (env, scope) {
            var CONTEXT = env.shared.context;
            var BOX_W = w;
            if (!('width' in box)) {
              BOX_W = scope.def(CONTEXT, '.', S_FRAMEBUFFER_WIDTH, '-', x);
            }
            var BOX_H = h;
            if (!('height' in box)) {
              BOX_H = scope.def(CONTEXT, '.', S_FRAMEBUFFER_HEIGHT, '-', y);
            }
            return [x, y, BOX_W, BOX_H];
          });
        } else if (param in dynamicOptions) {
          var dynBox = dynamicOptions[param];
          var result = createDynamicDecl(dynBox, function (env, scope) {
            var BOX = env.invoke(scope, dynBox);

            check$1.optional(function () {
              env.assert(scope, BOX + '&&typeof ' + BOX + '==="object"', 'invalid ' + param);
            });

            var CONTEXT = env.shared.context;
            var BOX_X = scope.def(BOX, '.x|0');
            var BOX_Y = scope.def(BOX, '.y|0');
            var BOX_W = scope.def('"width" in ', BOX, '?', BOX, '.width|0:', '(', CONTEXT, '.', S_FRAMEBUFFER_WIDTH, '-', BOX_X, ')');
            var BOX_H = scope.def('"height" in ', BOX, '?', BOX, '.height|0:', '(', CONTEXT, '.', S_FRAMEBUFFER_HEIGHT, '-', BOX_Y, ')');

            check$1.optional(function () {
              env.assert(scope, BOX_W + '>=0&&' + BOX_H + '>=0', 'invalid ' + param);
            });

            return [BOX_X, BOX_Y, BOX_W, BOX_H];
          });
          if (framebuffer) {
            result.thisDep = result.thisDep || framebuffer.thisDep;
            result.contextDep = result.contextDep || framebuffer.contextDep;
            result.propDep = result.propDep || framebuffer.propDep;
          }
          return result;
        } else if (framebuffer) {
          return new Declaration(framebuffer.thisDep, framebuffer.contextDep, framebuffer.propDep, function (env, scope) {
            var CONTEXT = env.shared.context;
            return [0, 0, scope.def(CONTEXT, '.', S_FRAMEBUFFER_WIDTH), scope.def(CONTEXT, '.', S_FRAMEBUFFER_HEIGHT)];
          });
        } else {
          return null;
        }
      }

      var viewport = parseBox(S_VIEWPORT);

      if (viewport) {
        var prevViewport = viewport;
        viewport = new Declaration(viewport.thisDep, viewport.contextDep, viewport.propDep, function (env, scope) {
          var VIEWPORT = prevViewport.append(env, scope);
          var CONTEXT = env.shared.context;
          scope.set(CONTEXT, '.' + S_VIEWPORT_WIDTH, VIEWPORT[2]);
          scope.set(CONTEXT, '.' + S_VIEWPORT_HEIGHT, VIEWPORT[3]);
          return VIEWPORT;
        });
      }

      return {
        viewport: viewport,
        scissor_box: parseBox(S_SCISSOR_BOX)
      };
    }

    function parseProgram(options) {
      var staticOptions = options.static;
      var dynamicOptions = options.dynamic;

      function parseShader(name) {
        if (name in staticOptions) {
          var id = stringStore.id(staticOptions[name]);
          check$1.optional(function () {
            shaderState.shader(shaderType[name], id, check$1.guessCommand());
          });
          var result = createStaticDecl(function () {
            return id;
          });
          result.id = id;
          return result;
        } else if (name in dynamicOptions) {
          var dyn = dynamicOptions[name];
          return createDynamicDecl(dyn, function (env, scope) {
            var str = env.invoke(scope, dyn);
            var id = scope.def(env.shared.strings, '.id(', str, ')');
            check$1.optional(function () {
              scope(env.shared.shader, '.shader(', shaderType[name], ',', id, ',', env.command, ');');
            });
            return id;
          });
        }
        return null;
      }

      var frag = parseShader(S_FRAG);
      var vert = parseShader(S_VERT);

      var program = null;
      var progVar;
      if (isStatic(frag) && isStatic(vert)) {
        program = shaderState.program(vert.id, frag.id);
        progVar = createStaticDecl(function (env, scope) {
          return env.link(program);
        });
      } else {
        progVar = new Declaration(frag && frag.thisDep || vert && vert.thisDep, frag && frag.contextDep || vert && vert.contextDep, frag && frag.propDep || vert && vert.propDep, function (env, scope) {
          var SHADER_STATE = env.shared.shader;
          var fragId;
          if (frag) {
            fragId = frag.append(env, scope);
          } else {
            fragId = scope.def(SHADER_STATE, '.', S_FRAG);
          }
          var vertId;
          if (vert) {
            vertId = vert.append(env, scope);
          } else {
            vertId = scope.def(SHADER_STATE, '.', S_VERT);
          }
          var progDef = SHADER_STATE + '.program(' + vertId + ',' + fragId;
          check$1.optional(function () {
            progDef += ',' + env.command;
          });
          return scope.def(progDef + ')');
        });
      }

      return {
        frag: frag,
        vert: vert,
        progVar: progVar,
        program: program
      };
    }

    function parseDraw(options, env) {
      var staticOptions = options.static;
      var dynamicOptions = options.dynamic;

      function parseElements() {
        if (S_ELEMENTS in staticOptions) {
          var elements = staticOptions[S_ELEMENTS];
          if (isBufferArgs(elements)) {
            elements = elementState.getElements(elementState.create(elements, true));
          } else if (elements) {
            elements = elementState.getElements(elements);
            check$1.command(elements, 'invalid elements', env.commandStr);
          }
          var result = createStaticDecl(function (env, scope) {
            if (elements) {
              var result = env.link(elements);
              env.ELEMENTS = result;
              return result;
            }
            env.ELEMENTS = null;
            return null;
          });
          result.value = elements;
          return result;
        } else if (S_ELEMENTS in dynamicOptions) {
          var dyn = dynamicOptions[S_ELEMENTS];
          return createDynamicDecl(dyn, function (env, scope) {
            var shared = env.shared;

            var IS_BUFFER_ARGS = shared.isBufferArgs;
            var ELEMENT_STATE = shared.elements;

            var elementDefn = env.invoke(scope, dyn);
            var elements = scope.def('null');
            var elementStream = scope.def(IS_BUFFER_ARGS, '(', elementDefn, ')');

            var ifte = env.cond(elementStream).then(elements, '=', ELEMENT_STATE, '.createStream(', elementDefn, ');').else(elements, '=', ELEMENT_STATE, '.getElements(', elementDefn, ');');

            check$1.optional(function () {
              env.assert(ifte.else, '!' + elementDefn + '||' + elements, 'invalid elements');
            });

            scope.entry(ifte);
            scope.exit(env.cond(elementStream).then(ELEMENT_STATE, '.destroyStream(', elements, ');'));

            env.ELEMENTS = elements;

            return elements;
          });
        }

        return null;
      }

      var elements = parseElements();

      function parsePrimitive() {
        if (S_PRIMITIVE in staticOptions) {
          var primitive = staticOptions[S_PRIMITIVE];
          check$1.commandParameter(primitive, primTypes, 'invalid primitve', env.commandStr);
          return createStaticDecl(function (env, scope) {
            return primTypes[primitive];
          });
        } else if (S_PRIMITIVE in dynamicOptions) {
          var dynPrimitive = dynamicOptions[S_PRIMITIVE];
          return createDynamicDecl(dynPrimitive, function (env, scope) {
            var PRIM_TYPES = env.constants.primTypes;
            var prim = env.invoke(scope, dynPrimitive);
            check$1.optional(function () {
              env.assert(scope, prim + ' in ' + PRIM_TYPES, 'invalid primitive, must be one of ' + Object.keys(primTypes));
            });
            return scope.def(PRIM_TYPES, '[', prim, ']');
          });
        } else if (elements) {
          if (isStatic(elements)) {
            if (elements.value) {
              return createStaticDecl(function (env, scope) {
                return scope.def(env.ELEMENTS, '.primType');
              });
            } else {
              return createStaticDecl(function () {
                return GL_TRIANGLES$1;
              });
            }
          } else {
            return new Declaration(elements.thisDep, elements.contextDep, elements.propDep, function (env, scope) {
              var elements = env.ELEMENTS;
              return scope.def(elements, '?', elements, '.primType:', GL_TRIANGLES$1);
            });
          }
        }
        return null;
      }

      function parseParam(param, isOffset) {
        if (param in staticOptions) {
          var value = staticOptions[param] | 0;
          check$1.command(!isOffset || value >= 0, 'invalid ' + param, env.commandStr);
          return createStaticDecl(function (env, scope) {
            if (isOffset) {
              env.OFFSET = value;
            }
            return value;
          });
        } else if (param in dynamicOptions) {
          var dynValue = dynamicOptions[param];
          return createDynamicDecl(dynValue, function (env, scope) {
            var result = env.invoke(scope, dynValue);
            if (isOffset) {
              env.OFFSET = result;
              check$1.optional(function () {
                env.assert(scope, result + '>=0', 'invalid ' + param);
              });
            }
            return result;
          });
        } else if (isOffset && elements) {
          return createStaticDecl(function (env, scope) {
            env.OFFSET = '0';
            return 0;
          });
        }
        return null;
      }

      var OFFSET = parseParam(S_OFFSET, true);

      function parseVertCount() {
        if (S_COUNT in staticOptions) {
          var count = staticOptions[S_COUNT] | 0;
          check$1.command(typeof count === 'number' && count >= 0, 'invalid vertex count', env.commandStr);
          return createStaticDecl(function () {
            return count;
          });
        } else if (S_COUNT in dynamicOptions) {
          var dynCount = dynamicOptions[S_COUNT];
          return createDynamicDecl(dynCount, function (env, scope) {
            var result = env.invoke(scope, dynCount);
            check$1.optional(function () {
              env.assert(scope, 'typeof ' + result + '==="number"&&' + result + '>=0&&' + result + '===(' + result + '|0)', 'invalid vertex count');
            });
            return result;
          });
        } else if (elements) {
          if (isStatic(elements)) {
            if (elements) {
              if (OFFSET) {
                return new Declaration(OFFSET.thisDep, OFFSET.contextDep, OFFSET.propDep, function (env, scope) {
                  var result = scope.def(env.ELEMENTS, '.vertCount-', env.OFFSET);

                  check$1.optional(function () {
                    env.assert(scope, result + '>=0', 'invalid vertex offset/element buffer too small');
                  });

                  return result;
                });
              } else {
                return createStaticDecl(function (env, scope) {
                  return scope.def(env.ELEMENTS, '.vertCount');
                });
              }
            } else {
              var result = createStaticDecl(function () {
                return -1;
              });
              check$1.optional(function () {
                result.MISSING = true;
              });
              return result;
            }
          } else {
            var variable = new Declaration(elements.thisDep || OFFSET.thisDep, elements.contextDep || OFFSET.contextDep, elements.propDep || OFFSET.propDep, function (env, scope) {
              var elements = env.ELEMENTS;
              if (env.OFFSET) {
                return scope.def(elements, '?', elements, '.vertCount-', env.OFFSET, ':-1');
              }
              return scope.def(elements, '?', elements, '.vertCount:-1');
            });
            check$1.optional(function () {
              variable.DYNAMIC = true;
            });
            return variable;
          }
        }
        return null;
      }

      return {
        elements: elements,
        primitive: parsePrimitive(),
        count: parseVertCount(),
        instances: parseParam(S_INSTANCES, false),
        offset: OFFSET
      };
    }

    function parseGLState(options, env) {
      var staticOptions = options.static;
      var dynamicOptions = options.dynamic;

      var STATE = {};

      GL_STATE_NAMES.forEach(function (prop) {
        var param = propName(prop);

        function parseParam(parseStatic, parseDynamic) {
          if (prop in staticOptions) {
            var value = parseStatic(staticOptions[prop]);
            STATE[param] = createStaticDecl(function () {
              return value;
            });
          } else if (prop in dynamicOptions) {
            var dyn = dynamicOptions[prop];
            STATE[param] = createDynamicDecl(dyn, function (env, scope) {
              return parseDynamic(env, scope, env.invoke(scope, dyn));
            });
          }
        }

        switch (prop) {
          case S_CULL_ENABLE:
          case S_BLEND_ENABLE:
          case S_DITHER:
          case S_STENCIL_ENABLE:
          case S_DEPTH_ENABLE:
          case S_SCISSOR_ENABLE:
          case S_POLYGON_OFFSET_ENABLE:
          case S_SAMPLE_ALPHA:
          case S_SAMPLE_ENABLE:
          case S_DEPTH_MASK:
            return parseParam(function (value) {
              check$1.commandType(value, 'boolean', prop, env.commandStr);
              return value;
            }, function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope, 'typeof ' + value + '==="boolean"', 'invalid flag ' + prop, env.commandStr);
              });
              return value;
            });

          case S_DEPTH_FUNC:
            return parseParam(function (value) {
              check$1.commandParameter(value, compareFuncs, 'invalid ' + prop, env.commandStr);
              return compareFuncs[value];
            }, function (env, scope, value) {
              var COMPARE_FUNCS = env.constants.compareFuncs;
              check$1.optional(function () {
                env.assert(scope, value + ' in ' + COMPARE_FUNCS, 'invalid ' + prop + ', must be one of ' + Object.keys(compareFuncs));
              });
              return scope.def(COMPARE_FUNCS, '[', value, ']');
            });

          case S_DEPTH_RANGE:
            return parseParam(function (value) {
              check$1.command(isArrayLike(value) && value.length === 2 && typeof value[0] === 'number' && typeof value[1] === 'number' && value[0] <= value[1], 'depth range is 2d array', env.commandStr);
              return value;
            }, function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope, env.shared.isArrayLike + '(' + value + ')&&' + value + '.length===2&&' + 'typeof ' + value + '[0]==="number"&&' + 'typeof ' + value + '[1]==="number"&&' + value + '[0]<=' + value + '[1]', 'depth range must be a 2d array');
              });

              var Z_NEAR = scope.def('+', value, '[0]');
              var Z_FAR = scope.def('+', value, '[1]');
              return [Z_NEAR, Z_FAR];
            });

          case S_BLEND_FUNC:
            return parseParam(function (value) {
              check$1.commandType(value, 'object', 'blend.func', env.commandStr);
              var srcRGB = 'srcRGB' in value ? value.srcRGB : value.src;
              var srcAlpha = 'srcAlpha' in value ? value.srcAlpha : value.src;
              var dstRGB = 'dstRGB' in value ? value.dstRGB : value.dst;
              var dstAlpha = 'dstAlpha' in value ? value.dstAlpha : value.dst;
              check$1.commandParameter(srcRGB, blendFuncs, param + '.srcRGB', env.commandStr);
              check$1.commandParameter(srcAlpha, blendFuncs, param + '.srcAlpha', env.commandStr);
              check$1.commandParameter(dstRGB, blendFuncs, param + '.dstRGB', env.commandStr);
              check$1.commandParameter(dstAlpha, blendFuncs, param + '.dstAlpha', env.commandStr);

              check$1.command(invalidBlendCombinations.indexOf(srcRGB + ', ' + dstRGB) === -1, 'unallowed blending combination (srcRGB, dstRGB) = (' + srcRGB + ', ' + dstRGB + ')', env.commandStr);

              return [blendFuncs[srcRGB], blendFuncs[dstRGB], blendFuncs[srcAlpha], blendFuncs[dstAlpha]];
            }, function (env, scope, value) {
              var BLEND_FUNCS = env.constants.blendFuncs;

              check$1.optional(function () {
                env.assert(scope, value + '&&typeof ' + value + '==="object"', 'invalid blend func, must be an object');
              });

              function read(prefix, suffix) {
                var func = scope.def('"', prefix, suffix, '" in ', value, '?', value, '.', prefix, suffix, ':', value, '.', prefix);

                check$1.optional(function () {
                  env.assert(scope, func + ' in ' + BLEND_FUNCS, 'invalid ' + prop + '.' + prefix + suffix + ', must be one of ' + Object.keys(blendFuncs));
                });

                return func;
              }

              var srcRGB = read('src', 'RGB');
              var dstRGB = read('dst', 'RGB');

              check$1.optional(function () {
                var INVALID_BLEND_COMBINATIONS = env.constants.invalidBlendCombinations;

                env.assert(scope, INVALID_BLEND_COMBINATIONS + '.indexOf(' + srcRGB + '+", "+' + dstRGB + ') === -1 ', 'unallowed blending combination for (srcRGB, dstRGB)');
              });

              var SRC_RGB = scope.def(BLEND_FUNCS, '[', srcRGB, ']');
              var SRC_ALPHA = scope.def(BLEND_FUNCS, '[', read('src', 'Alpha'), ']');
              var DST_RGB = scope.def(BLEND_FUNCS, '[', dstRGB, ']');
              var DST_ALPHA = scope.def(BLEND_FUNCS, '[', read('dst', 'Alpha'), ']');

              return [SRC_RGB, DST_RGB, SRC_ALPHA, DST_ALPHA];
            });

          case S_BLEND_EQUATION:
            return parseParam(function (value) {
              if (typeof value === 'string') {
                check$1.commandParameter(value, blendEquations, 'invalid ' + prop, env.commandStr);
                return [blendEquations[value], blendEquations[value]];
              } else if (typeof value === 'object') {
                check$1.commandParameter(value.rgb, blendEquations, prop + '.rgb', env.commandStr);
                check$1.commandParameter(value.alpha, blendEquations, prop + '.alpha', env.commandStr);
                return [blendEquations[value.rgb], blendEquations[value.alpha]];
              } else {
                check$1.commandRaise('invalid blend.equation', env.commandStr);
              }
            }, function (env, scope, value) {
              var BLEND_EQUATIONS = env.constants.blendEquations;

              var RGB = scope.def();
              var ALPHA = scope.def();

              var ifte = env.cond('typeof ', value, '==="string"');

              check$1.optional(function () {
                function checkProp(block, name, value) {
                  env.assert(block, value + ' in ' + BLEND_EQUATIONS, 'invalid ' + name + ', must be one of ' + Object.keys(blendEquations));
                }
                checkProp(ifte.then, prop, value);

                env.assert(ifte.else, value + '&&typeof ' + value + '==="object"', 'invalid ' + prop);
                checkProp(ifte.else, prop + '.rgb', value + '.rgb');
                checkProp(ifte.else, prop + '.alpha', value + '.alpha');
              });

              ifte.then(RGB, '=', ALPHA, '=', BLEND_EQUATIONS, '[', value, '];');
              ifte.else(RGB, '=', BLEND_EQUATIONS, '[', value, '.rgb];', ALPHA, '=', BLEND_EQUATIONS, '[', value, '.alpha];');

              scope(ifte);

              return [RGB, ALPHA];
            });

          case S_BLEND_COLOR:
            return parseParam(function (value) {
              check$1.command(isArrayLike(value) && value.length === 4, 'blend.color must be a 4d array', env.commandStr);
              return loop(4, function (i) {
                return +value[i];
              });
            }, function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope, env.shared.isArrayLike + '(' + value + ')&&' + value + '.length===4', 'blend.color must be a 4d array');
              });
              return loop(4, function (i) {
                return scope.def('+', value, '[', i, ']');
              });
            });

          case S_STENCIL_MASK:
            return parseParam(function (value) {
              check$1.commandType(value, 'number', param, env.commandStr);
              return value | 0;
            }, function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope, 'typeof ' + value + '==="number"', 'invalid stencil.mask');
              });
              return scope.def(value, '|0');
            });

          case S_STENCIL_FUNC:
            return parseParam(function (value) {
              check$1.commandType(value, 'object', param, env.commandStr);
              var cmp = value.cmp || 'keep';
              var ref = value.ref || 0;
              var mask = 'mask' in value ? value.mask : -1;
              check$1.commandParameter(cmp, compareFuncs, prop + '.cmp', env.commandStr);
              check$1.commandType(ref, 'number', prop + '.ref', env.commandStr);
              check$1.commandType(mask, 'number', prop + '.mask', env.commandStr);
              return [compareFuncs[cmp], ref, mask];
            }, function (env, scope, value) {
              var COMPARE_FUNCS = env.constants.compareFuncs;
              check$1.optional(function () {
                function assert() {
                  env.assert(scope, Array.prototype.join.call(arguments, ''), 'invalid stencil.func');
                }
                assert(value + '&&typeof ', value, '==="object"');
                assert('!("cmp" in ', value, ')||(', value, '.cmp in ', COMPARE_FUNCS, ')');
              });
              var cmp = scope.def('"cmp" in ', value, '?', COMPARE_FUNCS, '[', value, '.cmp]', ':', GL_KEEP);
              var ref = scope.def(value, '.ref|0');
              var mask = scope.def('"mask" in ', value, '?', value, '.mask|0:-1');
              return [cmp, ref, mask];
            });

          case S_STENCIL_OPFRONT:
          case S_STENCIL_OPBACK:
            return parseParam(function (value) {
              check$1.commandType(value, 'object', param, env.commandStr);
              var fail = value.fail || 'keep';
              var zfail = value.zfail || 'keep';
              var zpass = value.zpass || 'keep';
              check$1.commandParameter(fail, stencilOps, prop + '.fail', env.commandStr);
              check$1.commandParameter(zfail, stencilOps, prop + '.zfail', env.commandStr);
              check$1.commandParameter(zpass, stencilOps, prop + '.zpass', env.commandStr);
              return [prop === S_STENCIL_OPBACK ? GL_BACK : GL_FRONT, stencilOps[fail], stencilOps[zfail], stencilOps[zpass]];
            }, function (env, scope, value) {
              var STENCIL_OPS = env.constants.stencilOps;

              check$1.optional(function () {
                env.assert(scope, value + '&&typeof ' + value + '==="object"', 'invalid ' + prop);
              });

              function read(name) {
                check$1.optional(function () {
                  env.assert(scope, '!("' + name + '" in ' + value + ')||' + '(' + value + '.' + name + ' in ' + STENCIL_OPS + ')', 'invalid ' + prop + '.' + name + ', must be one of ' + Object.keys(stencilOps));
                });

                return scope.def('"', name, '" in ', value, '?', STENCIL_OPS, '[', value, '.', name, ']:', GL_KEEP);
              }

              return [prop === S_STENCIL_OPBACK ? GL_BACK : GL_FRONT, read('fail'), read('zfail'), read('zpass')];
            });

          case S_POLYGON_OFFSET_OFFSET:
            return parseParam(function (value) {
              check$1.commandType(value, 'object', param, env.commandStr);
              var factor = value.factor | 0;
              var units = value.units | 0;
              check$1.commandType(factor, 'number', param + '.factor', env.commandStr);
              check$1.commandType(units, 'number', param + '.units', env.commandStr);
              return [factor, units];
            }, function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope, value + '&&typeof ' + value + '==="object"', 'invalid ' + prop);
              });

              var FACTOR = scope.def(value, '.factor|0');
              var UNITS = scope.def(value, '.units|0');

              return [FACTOR, UNITS];
            });

          case S_CULL_FACE:
            return parseParam(function (value) {
              var face = 0;
              if (value === 'front') {
                face = GL_FRONT;
              } else if (value === 'back') {
                face = GL_BACK;
              }
              check$1.command(!!face, param, env.commandStr);
              return face;
            }, function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope, value + '==="front"||' + value + '==="back"', 'invalid cull.face');
              });
              return scope.def(value, '==="front"?', GL_FRONT, ':', GL_BACK);
            });

          case S_LINE_WIDTH:
            return parseParam(function (value) {
              check$1.command(typeof value === 'number' && value >= limits.lineWidthDims[0] && value <= limits.lineWidthDims[1], 'invalid line width, must positive number between ' + limits.lineWidthDims[0] + ' and ' + limits.lineWidthDims[1], env.commandStr);
              return value;
            }, function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope, 'typeof ' + value + '==="number"&&' + value + '>=' + limits.lineWidthDims[0] + '&&' + value + '<=' + limits.lineWidthDims[1], 'invalid line width');
              });

              return value;
            });

          case S_FRONT_FACE:
            return parseParam(function (value) {
              check$1.commandParameter(value, orientationType, param, env.commandStr);
              return orientationType[value];
            }, function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope, value + '==="cw"||' + value + '==="ccw"', 'invalid frontFace, must be one of cw,ccw');
              });
              return scope.def(value + '==="cw"?' + GL_CW + ':' + GL_CCW);
            });

          case S_COLOR_MASK:
            return parseParam(function (value) {
              check$1.command(isArrayLike(value) && value.length === 4, 'color.mask must be length 4 array', env.commandStr);
              return value.map(function (v) {
                return !!v;
              });
            }, function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope, env.shared.isArrayLike + '(' + value + ')&&' + value + '.length===4', 'invalid color.mask');
              });
              return loop(4, function (i) {
                return '!!' + value + '[' + i + ']';
              });
            });

          case S_SAMPLE_COVERAGE:
            return parseParam(function (value) {
              check$1.command(typeof value === 'object' && value, param, env.commandStr);
              var sampleValue = 'value' in value ? value.value : 1;
              var sampleInvert = !!value.invert;
              check$1.command(typeof sampleValue === 'number' && sampleValue >= 0 && sampleValue <= 1, 'sample.coverage.value must be a number between 0 and 1', env.commandStr);
              return [sampleValue, sampleInvert];
            }, function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope, value + '&&typeof ' + value + '==="object"', 'invalid sample.coverage');
              });
              var VALUE = scope.def('"value" in ', value, '?+', value, '.value:1');
              var INVERT = scope.def('!!', value, '.invert');
              return [VALUE, INVERT];
            });
        }
      });

      return STATE;
    }

    function parseUniforms(uniforms, env) {
      var staticUniforms = uniforms.static;
      var dynamicUniforms = uniforms.dynamic;

      var UNIFORMS = {};

      Object.keys(staticUniforms).forEach(function (name) {
        var value = staticUniforms[name];
        var result;
        if (typeof value === 'number' || typeof value === 'boolean') {
          result = createStaticDecl(function () {
            return value;
          });
        } else if (typeof value === 'function') {
          var reglType = value._reglType;
          if (reglType === 'texture2d' || reglType === 'textureCube') {
            result = createStaticDecl(function (env) {
              return env.link(value);
            });
          } else if (reglType === 'framebuffer' || reglType === 'framebufferCube') {
            check$1.command(value.color.length > 0, 'missing color attachment for framebuffer sent to uniform "' + name + '"', env.commandStr);
            result = createStaticDecl(function (env) {
              return env.link(value.color[0]);
            });
          } else {
            check$1.commandRaise('invalid data for uniform "' + name + '"', env.commandStr);
          }
        } else if (isArrayLike(value)) {
          result = createStaticDecl(function (env) {
            var ITEM = env.global.def('[', loop(value.length, function (i) {
              check$1.command(typeof value[i] === 'number' || typeof value[i] === 'boolean', 'invalid uniform ' + name, env.commandStr);
              return value[i];
            }), ']');
            return ITEM;
          });
        } else {
          check$1.commandRaise('invalid or missing data for uniform "' + name + '"', env.commandStr);
        }
        result.value = value;
        UNIFORMS[name] = result;
      });

      Object.keys(dynamicUniforms).forEach(function (key) {
        var dyn = dynamicUniforms[key];
        UNIFORMS[key] = createDynamicDecl(dyn, function (env, scope) {
          return env.invoke(scope, dyn);
        });
      });

      return UNIFORMS;
    }

    function parseAttributes(attributes, env) {
      var staticAttributes = attributes.static;
      var dynamicAttributes = attributes.dynamic;

      var attributeDefs = {};

      Object.keys(staticAttributes).forEach(function (attribute) {
        var value = staticAttributes[attribute];
        var id = stringStore.id(attribute);

        var record = new AttributeRecord();
        if (isBufferArgs(value)) {
          record.state = ATTRIB_STATE_POINTER;
          record.buffer = bufferState.getBuffer(bufferState.create(value, GL_ARRAY_BUFFER$1, false, true));
          record.type = 0;
        } else {
          var buffer = bufferState.getBuffer(value);
          if (buffer) {
            record.state = ATTRIB_STATE_POINTER;
            record.buffer = buffer;
            record.type = 0;
          } else {
            check$1.command(typeof value === 'object' && value, 'invalid data for attribute ' + attribute, env.commandStr);
            if (value.constant) {
              var constant = value.constant;
              record.buffer = 'null';
              record.state = ATTRIB_STATE_CONSTANT;
              if (typeof constant === 'number') {
                record.x = constant;
              } else {
                check$1.command(isArrayLike(constant) && constant.length > 0 && constant.length <= 4, 'invalid constant for attribute ' + attribute, env.commandStr);
                CUTE_COMPONENTS.forEach(function (c, i) {
                  if (i < constant.length) {
                    record[c] = constant[i];
                  }
                });
              }
            } else {
              if (isBufferArgs(value.buffer)) {
                buffer = bufferState.getBuffer(bufferState.create(value.buffer, GL_ARRAY_BUFFER$1, false, true));
              } else {
                buffer = bufferState.getBuffer(value.buffer);
              }
              check$1.command(!!buffer, 'missing buffer for attribute "' + attribute + '"', env.commandStr);

              var offset = value.offset | 0;
              check$1.command(offset >= 0, 'invalid offset for attribute "' + attribute + '"', env.commandStr);

              var stride = value.stride | 0;
              check$1.command(stride >= 0 && stride < 256, 'invalid stride for attribute "' + attribute + '", must be integer betweeen [0, 255]', env.commandStr);

              var size = value.size | 0;
              check$1.command(!('size' in value) || size > 0 && size <= 4, 'invalid size for attribute "' + attribute + '", must be 1,2,3,4', env.commandStr);

              var normalized = !!value.normalized;

              var type = 0;
              if ('type' in value) {
                check$1.commandParameter(value.type, glTypes, 'invalid type for attribute ' + attribute, env.commandStr);
                type = glTypes[value.type];
              }

              var divisor = value.divisor | 0;
              if ('divisor' in value) {
                check$1.command(divisor === 0 || extInstancing, 'cannot specify divisor for attribute "' + attribute + '", instancing not supported', env.commandStr);
                check$1.command(divisor >= 0, 'invalid divisor for attribute "' + attribute + '"', env.commandStr);
              }

              check$1.optional(function () {
                var command = env.commandStr;

                var VALID_KEYS = ['buffer', 'offset', 'divisor', 'normalized', 'type', 'size', 'stride'];

                Object.keys(value).forEach(function (prop) {
                  check$1.command(VALID_KEYS.indexOf(prop) >= 0, 'unknown parameter "' + prop + '" for attribute pointer "' + attribute + '" (valid parameters are ' + VALID_KEYS + ')', command);
                });
              });

              record.buffer = buffer;
              record.state = ATTRIB_STATE_POINTER;
              record.size = size;
              record.normalized = normalized;
              record.type = type || buffer.dtype;
              record.offset = offset;
              record.stride = stride;
              record.divisor = divisor;
            }
          }
        }

        attributeDefs[attribute] = createStaticDecl(function (env, scope) {
          var cache = env.attribCache;
          if (id in cache) {
            return cache[id];
          }
          var result = {
            isStream: false
          };
          Object.keys(record).forEach(function (key) {
            result[key] = record[key];
          });
          if (record.buffer) {
            result.buffer = env.link(record.buffer);
            result.type = result.type || result.buffer + '.dtype';
          }
          cache[id] = result;
          return result;
        });
      });

      Object.keys(dynamicAttributes).forEach(function (attribute) {
        var dyn = dynamicAttributes[attribute];

        function appendAttributeCode(env, block) {
          var VALUE = env.invoke(block, dyn);

          var shared = env.shared;

          var IS_BUFFER_ARGS = shared.isBufferArgs;
          var BUFFER_STATE = shared.buffer;

          // Perform validation on attribute
          check$1.optional(function () {
            env.assert(block, VALUE + '&&(typeof ' + VALUE + '==="object"||typeof ' + VALUE + '==="function")&&(' + IS_BUFFER_ARGS + '(' + VALUE + ')||' + BUFFER_STATE + '.getBuffer(' + VALUE + ')||' + BUFFER_STATE + '.getBuffer(' + VALUE + '.buffer)||' + IS_BUFFER_ARGS + '(' + VALUE + '.buffer)||' + '("constant" in ' + VALUE + '&&(typeof ' + VALUE + '.constant==="number"||' + shared.isArrayLike + '(' + VALUE + '.constant))))', 'invalid dynamic attribute "' + attribute + '"');
          });

          // allocate names for result
          var result = {
            isStream: block.def(false)
          };
          var defaultRecord = new AttributeRecord();
          defaultRecord.state = ATTRIB_STATE_POINTER;
          Object.keys(defaultRecord).forEach(function (key) {
            result[key] = block.def('' + defaultRecord[key]);
          });

          var BUFFER = result.buffer;
          var TYPE = result.type;
          block('if(', IS_BUFFER_ARGS, '(', VALUE, ')){', result.isStream, '=true;', BUFFER, '=', BUFFER_STATE, '.createStream(', GL_ARRAY_BUFFER$1, ',', VALUE, ');', TYPE, '=', BUFFER, '.dtype;', '}else{', BUFFER, '=', BUFFER_STATE, '.getBuffer(', VALUE, ');', 'if(', BUFFER, '){', TYPE, '=', BUFFER, '.dtype;', '}else if("constant" in ', VALUE, '){', result.state, '=', ATTRIB_STATE_CONSTANT, ';', 'if(typeof ' + VALUE + '.constant === "number"){', result[CUTE_COMPONENTS[0]], '=', VALUE, '.constant;', CUTE_COMPONENTS.slice(1).map(function (n) {
            return result[n];
          }).join('='), '=0;', '}else{', CUTE_COMPONENTS.map(function (name, i) {
            return result[name] + '=' + VALUE + '.constant.length>=' + i + '?' + VALUE + '.constant[' + i + ']:0;';
          }).join(''), '}}else{', 'if(', IS_BUFFER_ARGS, '(', VALUE, '.buffer)){', BUFFER, '=', BUFFER_STATE, '.createStream(', GL_ARRAY_BUFFER$1, ',', VALUE, '.buffer);', '}else{', BUFFER, '=', BUFFER_STATE, '.getBuffer(', VALUE, '.buffer);', '}', TYPE, '="type" in ', VALUE, '?', shared.glTypes, '[', VALUE, '.type]:', BUFFER, '.dtype;', result.normalized, '=!!', VALUE, '.normalized;');
          function emitReadRecord(name) {
            block(result[name], '=', VALUE, '.', name, '|0;');
          }
          emitReadRecord('size');
          emitReadRecord('offset');
          emitReadRecord('stride');
          emitReadRecord('divisor');

          block('}}');

          block.exit('if(', result.isStream, '){', BUFFER_STATE, '.destroyStream(', BUFFER, ');', '}');

          return result;
        }

        attributeDefs[attribute] = createDynamicDecl(dyn, appendAttributeCode);
      });

      return attributeDefs;
    }

    function parseContext(context) {
      var staticContext = context.static;
      var dynamicContext = context.dynamic;
      var result = {};

      Object.keys(staticContext).forEach(function (name) {
        var value = staticContext[name];
        result[name] = createStaticDecl(function (env, scope) {
          if (typeof value === 'number' || typeof value === 'boolean') {
            return '' + value;
          } else {
            return env.link(value);
          }
        });
      });

      Object.keys(dynamicContext).forEach(function (name) {
        var dyn = dynamicContext[name];
        result[name] = createDynamicDecl(dyn, function (env, scope) {
          return env.invoke(scope, dyn);
        });
      });

      return result;
    }

    function parseArguments(options, attributes, uniforms, context, env) {
      var staticOptions = options.static;
      var dynamicOptions = options.dynamic;

      check$1.optional(function () {
        var KEY_NAMES = [S_FRAMEBUFFER, S_VERT, S_FRAG, S_ELEMENTS, S_PRIMITIVE, S_OFFSET, S_COUNT, S_INSTANCES, S_PROFILE].concat(GL_STATE_NAMES);

        function checkKeys(dict) {
          Object.keys(dict).forEach(function (key) {
            check$1.command(KEY_NAMES.indexOf(key) >= 0, 'unknown parameter "' + key + '"', env.commandStr);
          });
        }

        checkKeys(staticOptions);
        checkKeys(dynamicOptions);
      });

      var framebuffer = parseFramebuffer(options, env);
      var viewportAndScissor = parseViewportScissor(options, framebuffer, env);
      var draw = parseDraw(options, env);
      var state = parseGLState(options, env);
      var shader = parseProgram(options, env);

      function copyBox(name) {
        var defn = viewportAndScissor[name];
        if (defn) {
          state[name] = defn;
        }
      }
      copyBox(S_VIEWPORT);
      copyBox(propName(S_SCISSOR_BOX));

      var dirty = Object.keys(state).length > 0;

      var result = {
        framebuffer: framebuffer,
        draw: draw,
        shader: shader,
        state: state,
        dirty: dirty
      };

      result.profile = parseProfile(options, env);
      result.uniforms = parseUniforms(uniforms, env);
      result.attributes = parseAttributes(attributes, env);
      result.context = parseContext(context, env);
      return result;
    }

    // ===================================================
    // ===================================================
    // COMMON UPDATE FUNCTIONS
    // ===================================================
    // ===================================================
    function emitContext(env, scope, context) {
      var shared = env.shared;
      var CONTEXT = shared.context;

      var contextEnter = env.scope();

      Object.keys(context).forEach(function (name) {
        scope.save(CONTEXT, '.' + name);
        var defn = context[name];
        contextEnter(CONTEXT, '.', name, '=', defn.append(env, scope), ';');
      });

      scope(contextEnter);
    }

    // ===================================================
    // ===================================================
    // COMMON DRAWING FUNCTIONS
    // ===================================================
    // ===================================================
    function emitPollFramebuffer(env, scope, framebuffer, skipCheck) {
      var shared = env.shared;

      var GL = shared.gl;
      var FRAMEBUFFER_STATE = shared.framebuffer;
      var EXT_DRAW_BUFFERS;
      if (extDrawBuffers) {
        EXT_DRAW_BUFFERS = scope.def(shared.extensions, '.webgl_draw_buffers');
      }

      var constants = env.constants;

      var DRAW_BUFFERS = constants.drawBuffer;
      var BACK_BUFFER = constants.backBuffer;

      var NEXT;
      if (framebuffer) {
        NEXT = framebuffer.append(env, scope);
      } else {
        NEXT = scope.def(FRAMEBUFFER_STATE, '.next');
      }

      if (!skipCheck) {
        scope('if(', NEXT, '!==', FRAMEBUFFER_STATE, '.cur){');
      }
      scope('if(', NEXT, '){', GL, '.bindFramebuffer(', GL_FRAMEBUFFER$1, ',', NEXT, '.framebuffer);');
      if (extDrawBuffers) {
        scope(EXT_DRAW_BUFFERS, '.drawBuffersWEBGL(', DRAW_BUFFERS, '[', NEXT, '.colorAttachments.length]);');
      }
      scope('}else{', GL, '.bindFramebuffer(', GL_FRAMEBUFFER$1, ',null);');
      if (extDrawBuffers) {
        scope(EXT_DRAW_BUFFERS, '.drawBuffersWEBGL(', BACK_BUFFER, ');');
      }
      scope('}', FRAMEBUFFER_STATE, '.cur=', NEXT, ';');
      if (!skipCheck) {
        scope('}');
      }
    }

    function emitPollState(env, scope, args) {
      var shared = env.shared;

      var GL = shared.gl;

      var CURRENT_VARS = env.current;
      var NEXT_VARS = env.next;
      var CURRENT_STATE = shared.current;
      var NEXT_STATE = shared.next;

      var block = env.cond(CURRENT_STATE, '.dirty');

      GL_STATE_NAMES.forEach(function (prop) {
        var param = propName(prop);
        if (param in args.state) {
          return;
        }

        var NEXT, CURRENT;
        if (param in NEXT_VARS) {
          NEXT = NEXT_VARS[param];
          CURRENT = CURRENT_VARS[param];
          var parts = loop(currentState[param].length, function (i) {
            return block.def(NEXT, '[', i, ']');
          });
          block(env.cond(parts.map(function (p, i) {
            return p + '!==' + CURRENT + '[' + i + ']';
          }).join('||')).then(GL, '.', GL_VARIABLES[param], '(', parts, ');', parts.map(function (p, i) {
            return CURRENT + '[' + i + ']=' + p;
          }).join(';'), ';'));
        } else {
          NEXT = block.def(NEXT_STATE, '.', param);
          var ifte = env.cond(NEXT, '!==', CURRENT_STATE, '.', param);
          block(ifte);
          if (param in GL_FLAGS) {
            ifte(env.cond(NEXT).then(GL, '.enable(', GL_FLAGS[param], ');').else(GL, '.disable(', GL_FLAGS[param], ');'), CURRENT_STATE, '.', param, '=', NEXT, ';');
          } else {
            ifte(GL, '.', GL_VARIABLES[param], '(', NEXT, ');', CURRENT_STATE, '.', param, '=', NEXT, ';');
          }
        }
      });
      if (Object.keys(args.state).length === 0) {
        block(CURRENT_STATE, '.dirty=false;');
      }
      scope(block);
    }

    function emitSetOptions(env, scope, options, filter) {
      var shared = env.shared;
      var CURRENT_VARS = env.current;
      var CURRENT_STATE = shared.current;
      var GL = shared.gl;
      sortState(Object.keys(options)).forEach(function (param) {
        var defn = options[param];
        if (filter && !filter(defn)) {
          return;
        }
        var variable = defn.append(env, scope);
        if (GL_FLAGS[param]) {
          var flag = GL_FLAGS[param];
          if (isStatic(defn)) {
            if (variable) {
              scope(GL, '.enable(', flag, ');');
            } else {
              scope(GL, '.disable(', flag, ');');
            }
          } else {
            scope(env.cond(variable).then(GL, '.enable(', flag, ');').else(GL, '.disable(', flag, ');'));
          }
          scope(CURRENT_STATE, '.', param, '=', variable, ';');
        } else if (isArrayLike(variable)) {
          var CURRENT = CURRENT_VARS[param];
          scope(GL, '.', GL_VARIABLES[param], '(', variable, ');', variable.map(function (v, i) {
            return CURRENT + '[' + i + ']=' + v;
          }).join(';'), ';');
        } else {
          scope(GL, '.', GL_VARIABLES[param], '(', variable, ');', CURRENT_STATE, '.', param, '=', variable, ';');
        }
      });
    }

    function injectExtensions(env, scope) {
      if (extInstancing) {
        env.instancing = scope.def(env.shared.extensions, '.angle_instanced_arrays');
      }
    }

    function emitProfile(env, scope, args, useScope, incrementCounter) {
      var shared = env.shared;
      var STATS = env.stats;
      var CURRENT_STATE = shared.current;
      var TIMER = shared.timer;
      var profileArg = args.profile;

      function perfCounter() {
        if (typeof performance === 'undefined') {
          return 'Date.now()';
        } else {
          return 'performance.now()';
        }
      }

      var CPU_START, QUERY_COUNTER;
      function emitProfileStart(block) {
        CPU_START = scope.def();
        block(CPU_START, '=', perfCounter(), ';');
        if (typeof incrementCounter === 'string') {
          block(STATS, '.count+=', incrementCounter, ';');
        } else {
          block(STATS, '.count++;');
        }
        if (timer) {
          if (useScope) {
            QUERY_COUNTER = scope.def();
            block(QUERY_COUNTER, '=', TIMER, '.getNumPendingQueries();');
          } else {
            block(TIMER, '.beginQuery(', STATS, ');');
          }
        }
      }

      function emitProfileEnd(block) {
        block(STATS, '.cpuTime+=', perfCounter(), '-', CPU_START, ';');
        if (timer) {
          if (useScope) {
            block(TIMER, '.pushScopeStats(', QUERY_COUNTER, ',', TIMER, '.getNumPendingQueries(),', STATS, ');');
          } else {
            block(TIMER, '.endQuery();');
          }
        }
      }

      function scopeProfile(value) {
        var prev = scope.def(CURRENT_STATE, '.profile');
        scope(CURRENT_STATE, '.profile=', value, ';');
        scope.exit(CURRENT_STATE, '.profile=', prev, ';');
      }

      var USE_PROFILE;
      if (profileArg) {
        if (isStatic(profileArg)) {
          if (profileArg.enable) {
            emitProfileStart(scope);
            emitProfileEnd(scope.exit);
            scopeProfile('true');
          } else {
            scopeProfile('false');
          }
          return;
        }
        USE_PROFILE = profileArg.append(env, scope);
        scopeProfile(USE_PROFILE);
      } else {
        USE_PROFILE = scope.def(CURRENT_STATE, '.profile');
      }

      var start = env.block();
      emitProfileStart(start);
      scope('if(', USE_PROFILE, '){', start, '}');
      var end = env.block();
      emitProfileEnd(end);
      scope.exit('if(', USE_PROFILE, '){', end, '}');
    }

    function emitAttributes(env, scope, args, attributes, filter) {
      var shared = env.shared;

      function typeLength(x) {
        switch (x) {
          case GL_FLOAT_VEC2:
          case GL_INT_VEC2:
          case GL_BOOL_VEC2:
            return 2;
          case GL_FLOAT_VEC3:
          case GL_INT_VEC3:
          case GL_BOOL_VEC3:
            return 3;
          case GL_FLOAT_VEC4:
          case GL_INT_VEC4:
          case GL_BOOL_VEC4:
            return 4;
          default:
            return 1;
        }
      }

      function emitBindAttribute(ATTRIBUTE, size, record) {
        var GL = shared.gl;

        var LOCATION = scope.def(ATTRIBUTE, '.location');
        var BINDING = scope.def(shared.attributes, '[', LOCATION, ']');

        var STATE = record.state;
        var BUFFER = record.buffer;
        var CONST_COMPONENTS = [record.x, record.y, record.z, record.w];

        var COMMON_KEYS = ['buffer', 'normalized', 'offset', 'stride'];

        function emitBuffer() {
          scope('if(!', BINDING, '.buffer){', GL, '.enableVertexAttribArray(', LOCATION, ');}');

          var TYPE = record.type;
          var SIZE;
          if (!record.size) {
            SIZE = size;
          } else {
            SIZE = scope.def(record.size, '||', size);
          }

          scope('if(', BINDING, '.type!==', TYPE, '||', BINDING, '.size!==', SIZE, '||', COMMON_KEYS.map(function (key) {
            return BINDING + '.' + key + '!==' + record[key];
          }).join('||'), '){', GL, '.bindBuffer(', GL_ARRAY_BUFFER$1, ',', BUFFER, '.buffer);', GL, '.vertexAttribPointer(', [LOCATION, SIZE, TYPE, record.normalized, record.stride, record.offset], ');', BINDING, '.type=', TYPE, ';', BINDING, '.size=', SIZE, ';', COMMON_KEYS.map(function (key) {
            return BINDING + '.' + key + '=' + record[key] + ';';
          }).join(''), '}');

          if (extInstancing) {
            var DIVISOR = record.divisor;
            scope('if(', BINDING, '.divisor!==', DIVISOR, '){', env.instancing, '.vertexAttribDivisorANGLE(', [LOCATION, DIVISOR], ');', BINDING, '.divisor=', DIVISOR, ';}');
          }
        }

        function emitConstant() {
          scope('if(', BINDING, '.buffer){', GL, '.disableVertexAttribArray(', LOCATION, ');', '}if(', CUTE_COMPONENTS.map(function (c, i) {
            return BINDING + '.' + c + '!==' + CONST_COMPONENTS[i];
          }).join('||'), '){', GL, '.vertexAttrib4f(', LOCATION, ',', CONST_COMPONENTS, ');', CUTE_COMPONENTS.map(function (c, i) {
            return BINDING + '.' + c + '=' + CONST_COMPONENTS[i] + ';';
          }).join(''), '}');
        }

        if (STATE === ATTRIB_STATE_POINTER) {
          emitBuffer();
        } else if (STATE === ATTRIB_STATE_CONSTANT) {
          emitConstant();
        } else {
          scope('if(', STATE, '===', ATTRIB_STATE_POINTER, '){');
          emitBuffer();
          scope('}else{');
          emitConstant();
          scope('}');
        }
      }

      attributes.forEach(function (attribute) {
        var name = attribute.name;
        var arg = args.attributes[name];
        var record;
        if (arg) {
          if (!filter(arg)) {
            return;
          }
          record = arg.append(env, scope);
        } else {
          if (!filter(SCOPE_DECL)) {
            return;
          }
          var scopeAttrib = env.scopeAttrib(name);
          check$1.optional(function () {
            env.assert(scope, scopeAttrib + '.state', 'missing attribute ' + name);
          });
          record = {};
          Object.keys(new AttributeRecord()).forEach(function (key) {
            record[key] = scope.def(scopeAttrib, '.', key);
          });
        }
        emitBindAttribute(env.link(attribute), typeLength(attribute.info.type), record);
      });
    }

    function emitUniforms(env, scope, args, uniforms, filter) {
      var shared = env.shared;
      var GL = shared.gl;

      var infix;
      for (var i = 0; i < uniforms.length; ++i) {
        var uniform = uniforms[i];
        var name = uniform.name;
        var type = uniform.info.type;
        var arg = args.uniforms[name];
        var UNIFORM = env.link(uniform);
        var LOCATION = UNIFORM + '.location';

        var VALUE;
        if (arg) {
          if (!filter(arg)) {
            continue;
          }
          if (isStatic(arg)) {
            var value = arg.value;
            check$1.command(value !== null && typeof value !== 'undefined', 'missing uniform "' + name + '"', env.commandStr);
            if (type === GL_SAMPLER_2D || type === GL_SAMPLER_CUBE) {
              check$1.command(typeof value === 'function' && (type === GL_SAMPLER_2D && (value._reglType === 'texture2d' || value._reglType === 'framebuffer') || type === GL_SAMPLER_CUBE && (value._reglType === 'textureCube' || value._reglType === 'framebufferCube')), 'invalid texture for uniform ' + name, env.commandStr);
              var TEX_VALUE = env.link(value._texture || value.color[0]._texture);
              scope(GL, '.uniform1i(', LOCATION, ',', TEX_VALUE + '.bind());');
              scope.exit(TEX_VALUE, '.unbind();');
            } else if (type === GL_FLOAT_MAT2 || type === GL_FLOAT_MAT3 || type === GL_FLOAT_MAT4) {
              check$1.optional(function () {
                check$1.command(isArrayLike(value), 'invalid matrix for uniform ' + name, env.commandStr);
                check$1.command(type === GL_FLOAT_MAT2 && value.length === 4 || type === GL_FLOAT_MAT3 && value.length === 9 || type === GL_FLOAT_MAT4 && value.length === 16, 'invalid length for matrix uniform ' + name, env.commandStr);
              });
              var MAT_VALUE = env.global.def('new Float32Array([' + Array.prototype.slice.call(value) + '])');
              var dim = 2;
              if (type === GL_FLOAT_MAT3) {
                dim = 3;
              } else if (type === GL_FLOAT_MAT4) {
                dim = 4;
              }
              scope(GL, '.uniformMatrix', dim, 'fv(', LOCATION, ',false,', MAT_VALUE, ');');
            } else {
              switch (type) {
                case GL_FLOAT$7:
                  check$1.commandType(value, 'number', 'uniform ' + name, env.commandStr);
                  infix = '1f';
                  break;
                case GL_FLOAT_VEC2:
                  check$1.command(isArrayLike(value) && value.length === 2, 'uniform ' + name, env.commandStr);
                  infix = '2f';
                  break;
                case GL_FLOAT_VEC3:
                  check$1.command(isArrayLike(value) && value.length === 3, 'uniform ' + name, env.commandStr);
                  infix = '3f';
                  break;
                case GL_FLOAT_VEC4:
                  check$1.command(isArrayLike(value) && value.length === 4, 'uniform ' + name, env.commandStr);
                  infix = '4f';
                  break;
                case GL_BOOL:
                  check$1.commandType(value, 'boolean', 'uniform ' + name, env.commandStr);
                  infix = '1i';
                  break;
                case GL_INT$3:
                  check$1.commandType(value, 'number', 'uniform ' + name, env.commandStr);
                  infix = '1i';
                  break;
                case GL_BOOL_VEC2:
                  check$1.command(isArrayLike(value) && value.length === 2, 'uniform ' + name, env.commandStr);
                  infix = '2i';
                  break;
                case GL_INT_VEC2:
                  check$1.command(isArrayLike(value) && value.length === 2, 'uniform ' + name, env.commandStr);
                  infix = '2i';
                  break;
                case GL_BOOL_VEC3:
                  check$1.command(isArrayLike(value) && value.length === 3, 'uniform ' + name, env.commandStr);
                  infix = '3i';
                  break;
                case GL_INT_VEC3:
                  check$1.command(isArrayLike(value) && value.length === 3, 'uniform ' + name, env.commandStr);
                  infix = '3i';
                  break;
                case GL_BOOL_VEC4:
                  check$1.command(isArrayLike(value) && value.length === 4, 'uniform ' + name, env.commandStr);
                  infix = '4i';
                  break;
                case GL_INT_VEC4:
                  check$1.command(isArrayLike(value) && value.length === 4, 'uniform ' + name, env.commandStr);
                  infix = '4i';
                  break;
              }
              scope(GL, '.uniform', infix, '(', LOCATION, ',', isArrayLike(value) ? Array.prototype.slice.call(value) : value, ');');
            }
            continue;
          } else {
            VALUE = arg.append(env, scope);
          }
        } else {
          if (!filter(SCOPE_DECL)) {
            continue;
          }
          VALUE = scope.def(shared.uniforms, '[', stringStore.id(name), ']');
        }

        if (type === GL_SAMPLER_2D) {
          scope('if(', VALUE, '&&', VALUE, '._reglType==="framebuffer"){', VALUE, '=', VALUE, '.color[0];', '}');
        } else if (type === GL_SAMPLER_CUBE) {
          scope('if(', VALUE, '&&', VALUE, '._reglType==="framebufferCube"){', VALUE, '=', VALUE, '.color[0];', '}');
        }

        // perform type validation
        check$1.optional(function () {
          function check(pred, message) {
            env.assert(scope, pred, 'bad data or missing for uniform "' + name + '".  ' + message);
          }

          function checkType(type) {
            check('typeof ' + VALUE + '==="' + type + '"', 'invalid type, expected ' + type);
          }

          function checkVector(n, type) {
            check(shared.isArrayLike + '(' + VALUE + ')&&' + VALUE + '.length===' + n, 'invalid vector, should have length ' + n, env.commandStr);
          }

          function checkTexture(target) {
            check('typeof ' + VALUE + '==="function"&&' + VALUE + '._reglType==="texture' + (target === GL_TEXTURE_2D$2 ? '2d' : 'Cube') + '"', 'invalid texture type', env.commandStr);
          }

          switch (type) {
            case GL_INT$3:
              checkType('number');
              break;
            case GL_INT_VEC2:
              checkVector(2, 'number');
              break;
            case GL_INT_VEC3:
              checkVector(3, 'number');
              break;
            case GL_INT_VEC4:
              checkVector(4, 'number');
              break;
            case GL_FLOAT$7:
              checkType('number');
              break;
            case GL_FLOAT_VEC2:
              checkVector(2, 'number');
              break;
            case GL_FLOAT_VEC3:
              checkVector(3, 'number');
              break;
            case GL_FLOAT_VEC4:
              checkVector(4, 'number');
              break;
            case GL_BOOL:
              checkType('boolean');
              break;
            case GL_BOOL_VEC2:
              checkVector(2, 'boolean');
              break;
            case GL_BOOL_VEC3:
              checkVector(3, 'boolean');
              break;
            case GL_BOOL_VEC4:
              checkVector(4, 'boolean');
              break;
            case GL_FLOAT_MAT2:
              checkVector(4, 'number');
              break;
            case GL_FLOAT_MAT3:
              checkVector(9, 'number');
              break;
            case GL_FLOAT_MAT4:
              checkVector(16, 'number');
              break;
            case GL_SAMPLER_2D:
              checkTexture(GL_TEXTURE_2D$2);
              break;
            case GL_SAMPLER_CUBE:
              checkTexture(GL_TEXTURE_CUBE_MAP$1);
              break;
          }
        });

        var unroll = 1;
        switch (type) {
          case GL_SAMPLER_2D:
          case GL_SAMPLER_CUBE:
            var TEX = scope.def(VALUE, '._texture');
            scope(GL, '.uniform1i(', LOCATION, ',', TEX, '.bind());');
            scope.exit(TEX, '.unbind();');
            continue;

          case GL_INT$3:
          case GL_BOOL:
            infix = '1i';
            break;

          case GL_INT_VEC2:
          case GL_BOOL_VEC2:
            infix = '2i';
            unroll = 2;
            break;

          case GL_INT_VEC3:
          case GL_BOOL_VEC3:
            infix = '3i';
            unroll = 3;
            break;

          case GL_INT_VEC4:
          case GL_BOOL_VEC4:
            infix = '4i';
            unroll = 4;
            break;

          case GL_FLOAT$7:
            infix = '1f';
            break;

          case GL_FLOAT_VEC2:
            infix = '2f';
            unroll = 2;
            break;

          case GL_FLOAT_VEC3:
            infix = '3f';
            unroll = 3;
            break;

          case GL_FLOAT_VEC4:
            infix = '4f';
            unroll = 4;
            break;

          case GL_FLOAT_MAT2:
            infix = 'Matrix2fv';
            break;

          case GL_FLOAT_MAT3:
            infix = 'Matrix3fv';
            break;

          case GL_FLOAT_MAT4:
            infix = 'Matrix4fv';
            break;
        }

        scope(GL, '.uniform', infix, '(', LOCATION, ',');
        if (infix.charAt(0) === 'M') {
          var matSize = Math.pow(type - GL_FLOAT_MAT2 + 2, 2);
          var STORAGE = env.global.def('new Float32Array(', matSize, ')');
          scope('false,(Array.isArray(', VALUE, ')||', VALUE, ' instanceof Float32Array)?', VALUE, ':(', loop(matSize, function (i) {
            return STORAGE + '[' + i + ']=' + VALUE + '[' + i + ']';
          }), ',', STORAGE, ')');
        } else if (unroll > 1) {
          scope(loop(unroll, function (i) {
            return VALUE + '[' + i + ']';
          }));
        } else {
          scope(VALUE);
        }
        scope(');');
      }
    }

    function emitDraw(env, outer, inner, args) {
      var shared = env.shared;
      var GL = shared.gl;
      var DRAW_STATE = shared.draw;

      var drawOptions = args.draw;

      function emitElements() {
        var defn = drawOptions.elements;
        var ELEMENTS;
        var scope = outer;
        if (defn) {
          if (defn.contextDep && args.contextDynamic || defn.propDep) {
            scope = inner;
          }
          ELEMENTS = defn.append(env, scope);
        } else {
          ELEMENTS = scope.def(DRAW_STATE, '.', S_ELEMENTS);
        }
        if (ELEMENTS) {
          scope('if(' + ELEMENTS + ')' + GL + '.bindBuffer(' + GL_ELEMENT_ARRAY_BUFFER$1 + ',' + ELEMENTS + '.buffer.buffer);');
        }
        return ELEMENTS;
      }

      function emitCount() {
        var defn = drawOptions.count;
        var COUNT;
        var scope = outer;
        if (defn) {
          if (defn.contextDep && args.contextDynamic || defn.propDep) {
            scope = inner;
          }
          COUNT = defn.append(env, scope);
          check$1.optional(function () {
            if (defn.MISSING) {
              env.assert(outer, 'false', 'missing vertex count');
            }
            if (defn.DYNAMIC) {
              env.assert(scope, COUNT + '>=0', 'missing vertex count');
            }
          });
        } else {
          COUNT = scope.def(DRAW_STATE, '.', S_COUNT);
          check$1.optional(function () {
            env.assert(scope, COUNT + '>=0', 'missing vertex count');
          });
        }
        return COUNT;
      }

      var ELEMENTS = emitElements();
      function emitValue(name) {
        var defn = drawOptions[name];
        if (defn) {
          if (defn.contextDep && args.contextDynamic || defn.propDep) {
            return defn.append(env, inner);
          } else {
            return defn.append(env, outer);
          }
        } else {
          return outer.def(DRAW_STATE, '.', name);
        }
      }

      var PRIMITIVE = emitValue(S_PRIMITIVE);
      var OFFSET = emitValue(S_OFFSET);

      var COUNT = emitCount();
      if (typeof COUNT === 'number') {
        if (COUNT === 0) {
          return;
        }
      } else {
        inner('if(', COUNT, '){');
        inner.exit('}');
      }

      var INSTANCES, EXT_INSTANCING;
      if (extInstancing) {
        INSTANCES = emitValue(S_INSTANCES);
        EXT_INSTANCING = env.instancing;
      }

      var ELEMENT_TYPE = ELEMENTS + '.type';

      var elementsStatic = drawOptions.elements && isStatic(drawOptions.elements);

      function emitInstancing() {
        function drawElements() {
          inner(EXT_INSTANCING, '.drawElementsInstancedANGLE(', [PRIMITIVE, COUNT, ELEMENT_TYPE, OFFSET + '<<((' + ELEMENT_TYPE + '-' + GL_UNSIGNED_BYTE$7 + ')>>1)', INSTANCES], ');');
        }

        function drawArrays() {
          inner(EXT_INSTANCING, '.drawArraysInstancedANGLE(', [PRIMITIVE, OFFSET, COUNT, INSTANCES], ');');
        }

        if (ELEMENTS) {
          if (!elementsStatic) {
            inner('if(', ELEMENTS, '){');
            drawElements();
            inner('}else{');
            drawArrays();
            inner('}');
          } else {
            drawElements();
          }
        } else {
          drawArrays();
        }
      }

      function emitRegular() {
        function drawElements() {
          inner(GL + '.drawElements(' + [PRIMITIVE, COUNT, ELEMENT_TYPE, OFFSET + '<<((' + ELEMENT_TYPE + '-' + GL_UNSIGNED_BYTE$7 + ')>>1)'] + ');');
        }

        function drawArrays() {
          inner(GL + '.drawArrays(' + [PRIMITIVE, OFFSET, COUNT] + ');');
        }

        if (ELEMENTS) {
          if (!elementsStatic) {
            inner('if(', ELEMENTS, '){');
            drawElements();
            inner('}else{');
            drawArrays();
            inner('}');
          } else {
            drawElements();
          }
        } else {
          drawArrays();
        }
      }

      if (extInstancing && (typeof INSTANCES !== 'number' || INSTANCES >= 0)) {
        if (typeof INSTANCES === 'string') {
          inner('if(', INSTANCES, '>0){');
          emitInstancing();
          inner('}else if(', INSTANCES, '<0){');
          emitRegular();
          inner('}');
        } else {
          emitInstancing();
        }
      } else {
        emitRegular();
      }
    }

    function createBody(emitBody, parentEnv, args, program, count) {
      var env = createREGLEnvironment();
      var scope = env.proc('body', count);
      check$1.optional(function () {
        env.commandStr = parentEnv.commandStr;
        env.command = env.link(parentEnv.commandStr);
      });
      if (extInstancing) {
        env.instancing = scope.def(env.shared.extensions, '.angle_instanced_arrays');
      }
      emitBody(env, scope, args, program);
      return env.compile().body;
    }

    // ===================================================
    // ===================================================
    // DRAW PROC
    // ===================================================
    // ===================================================
    function emitDrawBody(env, draw, args, program) {
      injectExtensions(env, draw);
      emitAttributes(env, draw, args, program.attributes, function () {
        return true;
      });
      emitUniforms(env, draw, args, program.uniforms, function () {
        return true;
      });
      emitDraw(env, draw, draw, args);
    }

    function emitDrawProc(env, args) {
      var draw = env.proc('draw', 1);

      injectExtensions(env, draw);

      emitContext(env, draw, args.context);
      emitPollFramebuffer(env, draw, args.framebuffer);

      emitPollState(env, draw, args);
      emitSetOptions(env, draw, args.state);

      emitProfile(env, draw, args, false, true);

      var program = args.shader.progVar.append(env, draw);
      draw(env.shared.gl, '.useProgram(', program, '.program);');

      if (args.shader.program) {
        emitDrawBody(env, draw, args, args.shader.program);
      } else {
        var drawCache = env.global.def('{}');
        var PROG_ID = draw.def(program, '.id');
        var CACHED_PROC = draw.def(drawCache, '[', PROG_ID, ']');
        draw(env.cond(CACHED_PROC).then(CACHED_PROC, '.call(this,a0);').else(CACHED_PROC, '=', drawCache, '[', PROG_ID, ']=', env.link(function (program) {
          return createBody(emitDrawBody, env, args, program, 1);
        }), '(', program, ');', CACHED_PROC, '.call(this,a0);'));
      }

      if (Object.keys(args.state).length > 0) {
        draw(env.shared.current, '.dirty=true;');
      }
    }

    // ===================================================
    // ===================================================
    // BATCH PROC
    // ===================================================
    // ===================================================

    function emitBatchDynamicShaderBody(env, scope, args, program) {
      env.batchId = 'a1';

      injectExtensions(env, scope);

      function all() {
        return true;
      }

      emitAttributes(env, scope, args, program.attributes, all);
      emitUniforms(env, scope, args, program.uniforms, all);
      emitDraw(env, scope, scope, args);
    }

    function emitBatchBody(env, scope, args, program) {
      injectExtensions(env, scope);

      var contextDynamic = args.contextDep;

      var BATCH_ID = scope.def();
      var PROP_LIST = 'a0';
      var NUM_PROPS = 'a1';
      var PROPS = scope.def();
      env.shared.props = PROPS;
      env.batchId = BATCH_ID;

      var outer = env.scope();
      var inner = env.scope();

      scope(outer.entry, 'for(', BATCH_ID, '=0;', BATCH_ID, '<', NUM_PROPS, ';++', BATCH_ID, '){', PROPS, '=', PROP_LIST, '[', BATCH_ID, '];', inner, '}', outer.exit);

      function isInnerDefn(defn) {
        return defn.contextDep && contextDynamic || defn.propDep;
      }

      function isOuterDefn(defn) {
        return !isInnerDefn(defn);
      }

      if (args.needsContext) {
        emitContext(env, inner, args.context);
      }
      if (args.needsFramebuffer) {
        emitPollFramebuffer(env, inner, args.framebuffer);
      }
      emitSetOptions(env, inner, args.state, isInnerDefn);

      if (args.profile && isInnerDefn(args.profile)) {
        emitProfile(env, inner, args, false, true);
      }

      if (!program) {
        var progCache = env.global.def('{}');
        var PROGRAM = args.shader.progVar.append(env, inner);
        var PROG_ID = inner.def(PROGRAM, '.id');
        var CACHED_PROC = inner.def(progCache, '[', PROG_ID, ']');
        inner(env.shared.gl, '.useProgram(', PROGRAM, '.program);', 'if(!', CACHED_PROC, '){', CACHED_PROC, '=', progCache, '[', PROG_ID, ']=', env.link(function (program) {
          return createBody(emitBatchDynamicShaderBody, env, args, program, 2);
        }), '(', PROGRAM, ');}', CACHED_PROC, '.call(this,a0[', BATCH_ID, '],', BATCH_ID, ');');
      } else {
        emitAttributes(env, outer, args, program.attributes, isOuterDefn);
        emitAttributes(env, inner, args, program.attributes, isInnerDefn);
        emitUniforms(env, outer, args, program.uniforms, isOuterDefn);
        emitUniforms(env, inner, args, program.uniforms, isInnerDefn);
        emitDraw(env, outer, inner, args);
      }
    }

    function emitBatchProc(env, args) {
      var batch = env.proc('batch', 2);
      env.batchId = '0';

      injectExtensions(env, batch);

      // Check if any context variables depend on props
      var contextDynamic = false;
      var needsContext = true;
      Object.keys(args.context).forEach(function (name) {
        contextDynamic = contextDynamic || args.context[name].propDep;
      });
      if (!contextDynamic) {
        emitContext(env, batch, args.context);
        needsContext = false;
      }

      // framebuffer state affects framebufferWidth/height context vars
      var framebuffer = args.framebuffer;
      var needsFramebuffer = false;
      if (framebuffer) {
        if (framebuffer.propDep) {
          contextDynamic = needsFramebuffer = true;
        } else if (framebuffer.contextDep && contextDynamic) {
          needsFramebuffer = true;
        }
        if (!needsFramebuffer) {
          emitPollFramebuffer(env, batch, framebuffer);
        }
      } else {
        emitPollFramebuffer(env, batch, null);
      }

      // viewport is weird because it can affect context vars
      if (args.state.viewport && args.state.viewport.propDep) {
        contextDynamic = true;
      }

      function isInnerDefn(defn) {
        return defn.contextDep && contextDynamic || defn.propDep;
      }

      // set webgl options
      emitPollState(env, batch, args);
      emitSetOptions(env, batch, args.state, function (defn) {
        return !isInnerDefn(defn);
      });

      if (!args.profile || !isInnerDefn(args.profile)) {
        emitProfile(env, batch, args, false, 'a1');
      }

      // Save these values to args so that the batch body routine can use them
      args.contextDep = contextDynamic;
      args.needsContext = needsContext;
      args.needsFramebuffer = needsFramebuffer;

      // determine if shader is dynamic
      var progDefn = args.shader.progVar;
      if (progDefn.contextDep && contextDynamic || progDefn.propDep) {
        emitBatchBody(env, batch, args, null);
      } else {
        var PROGRAM = progDefn.append(env, batch);
        batch(env.shared.gl, '.useProgram(', PROGRAM, '.program);');
        if (args.shader.program) {
          emitBatchBody(env, batch, args, args.shader.program);
        } else {
          var batchCache = env.global.def('{}');
          var PROG_ID = batch.def(PROGRAM, '.id');
          var CACHED_PROC = batch.def(batchCache, '[', PROG_ID, ']');
          batch(env.cond(CACHED_PROC).then(CACHED_PROC, '.call(this,a0,a1);').else(CACHED_PROC, '=', batchCache, '[', PROG_ID, ']=', env.link(function (program) {
            return createBody(emitBatchBody, env, args, program, 2);
          }), '(', PROGRAM, ');', CACHED_PROC, '.call(this,a0,a1);'));
        }
      }

      if (Object.keys(args.state).length > 0) {
        batch(env.shared.current, '.dirty=true;');
      }
    }

    // ===================================================
    // ===================================================
    // SCOPE COMMAND
    // ===================================================
    // ===================================================
    function emitScopeProc(env, args) {
      var scope = env.proc('scope', 3);
      env.batchId = 'a2';

      var shared = env.shared;
      var CURRENT_STATE = shared.current;

      emitContext(env, scope, args.context);

      if (args.framebuffer) {
        args.framebuffer.append(env, scope);
      }

      sortState(Object.keys(args.state)).forEach(function (name) {
        var defn = args.state[name];
        var value = defn.append(env, scope);
        if (isArrayLike(value)) {
          value.forEach(function (v, i) {
            scope.set(env.next[name], '[' + i + ']', v);
          });
        } else {
          scope.set(shared.next, '.' + name, value);
        }
      });

      emitProfile(env, scope, args, true, true);[S_ELEMENTS, S_OFFSET, S_COUNT, S_INSTANCES, S_PRIMITIVE].forEach(function (opt) {
        var variable = args.draw[opt];
        if (!variable) {
          return;
        }
        scope.set(shared.draw, '.' + opt, '' + variable.append(env, scope));
      });

      Object.keys(args.uniforms).forEach(function (opt) {
        scope.set(shared.uniforms, '[' + stringStore.id(opt) + ']', args.uniforms[opt].append(env, scope));
      });

      Object.keys(args.attributes).forEach(function (name) {
        var record = args.attributes[name].append(env, scope);
        var scopeAttrib = env.scopeAttrib(name);
        Object.keys(new AttributeRecord()).forEach(function (prop) {
          scope.set(scopeAttrib, '.' + prop, record[prop]);
        });
      });

      function saveShader(name) {
        var shader = args.shader[name];
        if (shader) {
          scope.set(shared.shader, '.' + name, shader.append(env, scope));
        }
      }
      saveShader(S_VERT);
      saveShader(S_FRAG);

      if (Object.keys(args.state).length > 0) {
        scope(CURRENT_STATE, '.dirty=true;');
        scope.exit(CURRENT_STATE, '.dirty=true;');
      }

      scope('a1(', env.shared.context, ',a0,', env.batchId, ');');
    }

    function isDynamicObject(object) {
      if (typeof object !== 'object' || isArrayLike(object)) {
        return;
      }
      var props = Object.keys(object);
      for (var i = 0; i < props.length; ++i) {
        if (dynamic.isDynamic(object[props[i]])) {
          return true;
        }
      }
      return false;
    }

    function splatObject(env, options, name) {
      var object = options.static[name];
      if (!object || !isDynamicObject(object)) {
        return;
      }

      var globals = env.global;
      var keys = Object.keys(object);
      var thisDep = false;
      var contextDep = false;
      var propDep = false;
      var objectRef = env.global.def('{}');
      keys.forEach(function (key) {
        var value = object[key];
        if (dynamic.isDynamic(value)) {
          if (typeof value === 'function') {
            value = object[key] = dynamic.unbox(value);
          }
          var deps = createDynamicDecl(value, null);
          thisDep = thisDep || deps.thisDep;
          propDep = propDep || deps.propDep;
          contextDep = contextDep || deps.contextDep;
        } else {
          globals(objectRef, '.', key, '=');
          switch (typeof value) {
            case 'number':
              globals(value);
              break;
            case 'string':
              globals('"', value, '"');
              break;
            case 'object':
              if (Array.isArray(value)) {
                globals('[', value.join(), ']');
              }
              break;
            default:
              globals(env.link(value));
              break;
          }
          globals(';');
        }
      });

      function appendBlock(env, block) {
        keys.forEach(function (key) {
          var value = object[key];
          if (!dynamic.isDynamic(value)) {
            return;
          }
          var ref = env.invoke(block, value);
          block(objectRef, '.', key, '=', ref, ';');
        });
      }

      options.dynamic[name] = new dynamic.DynamicVariable(DYN_THUNK, {
        thisDep: thisDep,
        contextDep: contextDep,
        propDep: propDep,
        ref: objectRef,
        append: appendBlock
      });
      delete options.static[name];
    }

    // ===========================================================================
    // ===========================================================================
    // MAIN DRAW COMMAND
    // ===========================================================================
    // ===========================================================================
    function compileCommand(options, attributes, uniforms, context, stats) {
      var env = createREGLEnvironment();

      // link stats, so that we can easily access it in the program.
      env.stats = env.link(stats);

      // splat options and attributes to allow for dynamic nested properties
      Object.keys(attributes.static).forEach(function (key) {
        splatObject(env, attributes, key);
      });
      NESTED_OPTIONS.forEach(function (name) {
        splatObject(env, options, name);
      });

      var args = parseArguments(options, attributes, uniforms, context, env);

      emitDrawProc(env, args);
      emitScopeProc(env, args);
      emitBatchProc(env, args);

      return env.compile();
    }

    // ===========================================================================
    // ===========================================================================
    // POLL / REFRESH
    // ===========================================================================
    // ===========================================================================
    return {
      next: nextState,
      current: currentState,
      procs: function () {
        var env = createREGLEnvironment();
        var poll = env.proc('poll');
        var refresh = env.proc('refresh');
        var common = env.block();
        poll(common);
        refresh(common);

        var shared = env.shared;
        var GL = shared.gl;
        var NEXT_STATE = shared.next;
        var CURRENT_STATE = shared.current;

        common(CURRENT_STATE, '.dirty=false;');

        emitPollFramebuffer(env, poll);
        emitPollFramebuffer(env, refresh, null, true);

        // Refresh updates all attribute state changes
        var extInstancing = gl.getExtension('angle_instanced_arrays');
        var INSTANCING;
        if (extInstancing) {
          INSTANCING = env.link(extInstancing);
        }
        for (var i = 0; i < limits.maxAttributes; ++i) {
          var BINDING = refresh.def(shared.attributes, '[', i, ']');
          var ifte = env.cond(BINDING, '.buffer');
          ifte.then(GL, '.enableVertexAttribArray(', i, ');', GL, '.bindBuffer(', GL_ARRAY_BUFFER$1, ',', BINDING, '.buffer.buffer);', GL, '.vertexAttribPointer(', i, ',', BINDING, '.size,', BINDING, '.type,', BINDING, '.normalized,', BINDING, '.stride,', BINDING, '.offset);').else(GL, '.disableVertexAttribArray(', i, ');', GL, '.vertexAttrib4f(', i, ',', BINDING, '.x,', BINDING, '.y,', BINDING, '.z,', BINDING, '.w);', BINDING, '.buffer=null;');
          refresh(ifte);
          if (extInstancing) {
            refresh(INSTANCING, '.vertexAttribDivisorANGLE(', i, ',', BINDING, '.divisor);');
          }
        }

        Object.keys(GL_FLAGS).forEach(function (flag) {
          var cap = GL_FLAGS[flag];
          var NEXT = common.def(NEXT_STATE, '.', flag);
          var block = env.block();
          block('if(', NEXT, '){', GL, '.enable(', cap, ')}else{', GL, '.disable(', cap, ')}', CURRENT_STATE, '.', flag, '=', NEXT, ';');
          refresh(block);
          poll('if(', NEXT, '!==', CURRENT_STATE, '.', flag, '){', block, '}');
        });

        Object.keys(GL_VARIABLES).forEach(function (name) {
          var func = GL_VARIABLES[name];
          var init = currentState[name];
          var NEXT, CURRENT;
          var block = env.block();
          block(GL, '.', func, '(');
          if (isArrayLike(init)) {
            var n = init.length;
            NEXT = env.global.def(NEXT_STATE, '.', name);
            CURRENT = env.global.def(CURRENT_STATE, '.', name);
            block(loop(n, function (i) {
              return NEXT + '[' + i + ']';
            }), ');', loop(n, function (i) {
              return CURRENT + '[' + i + ']=' + NEXT + '[' + i + '];';
            }).join(''));
            poll('if(', loop(n, function (i) {
              return NEXT + '[' + i + ']!==' + CURRENT + '[' + i + ']';
            }).join('||'), '){', block, '}');
          } else {
            NEXT = common.def(NEXT_STATE, '.', name);
            CURRENT = common.def(CURRENT_STATE, '.', name);
            block(NEXT, ');', CURRENT_STATE, '.', name, '=', NEXT, ';');
            poll('if(', NEXT, '!==', CURRENT, '){', block, '}');
          }
          refresh(block);
        });

        return env.compile();
      }(),
      compile: compileCommand
    };
  }

  function stats() {
    return {
      bufferCount: 0,
      elementsCount: 0,
      framebufferCount: 0,
      shaderCount: 0,
      textureCount: 0,
      cubeCount: 0,
      renderbufferCount: 0,

      maxTextureUnits: 0
    };
  }

  var GL_QUERY_RESULT_EXT = 0x8866;
  var GL_QUERY_RESULT_AVAILABLE_EXT = 0x8867;
  var GL_TIME_ELAPSED_EXT = 0x88BF;

  var createTimer = function (gl, extensions) {
    var extTimer = extensions.ext_disjoint_timer_query;

    if (!extTimer) {
      return null;
    }

    // QUERY POOL BEGIN
    var queryPool = [];
    function allocQuery() {
      return queryPool.pop() || extTimer.createQueryEXT();
    }
    function freeQuery(query) {
      queryPool.push(query);
    }
    // QUERY POOL END

    var pendingQueries = [];
    function beginQuery(stats) {
      var query = allocQuery();
      extTimer.beginQueryEXT(GL_TIME_ELAPSED_EXT, query);
      pendingQueries.push(query);
      pushScopeStats(pendingQueries.length - 1, pendingQueries.length, stats);
    }

    function endQuery() {
      extTimer.endQueryEXT(GL_TIME_ELAPSED_EXT);
    }

    //
    // Pending stats pool.
    //
    function PendingStats() {
      this.startQueryIndex = -1;
      this.endQueryIndex = -1;
      this.sum = 0;
      this.stats = null;
    }
    var pendingStatsPool = [];
    function allocPendingStats() {
      return pendingStatsPool.pop() || new PendingStats();
    }
    function freePendingStats(pendingStats) {
      pendingStatsPool.push(pendingStats);
    }
    // Pending stats pool end

    var pendingStats = [];
    function pushScopeStats(start, end, stats) {
      var ps = allocPendingStats();
      ps.startQueryIndex = start;
      ps.endQueryIndex = end;
      ps.sum = 0;
      ps.stats = stats;
      pendingStats.push(ps);
    }

    // we should call this at the beginning of the frame,
    // in order to update gpuTime
    var timeSum = [];
    var queryPtr = [];
    function update() {
      var ptr, i;

      var n = pendingQueries.length;
      if (n === 0) {
        return;
      }

      // Reserve space
      queryPtr.length = Math.max(queryPtr.length, n + 1);
      timeSum.length = Math.max(timeSum.length, n + 1);
      timeSum[0] = 0;
      queryPtr[0] = 0;

      // Update all pending timer queries
      var queryTime = 0;
      ptr = 0;
      for (i = 0; i < pendingQueries.length; ++i) {
        var query = pendingQueries[i];
        if (extTimer.getQueryObjectEXT(query, GL_QUERY_RESULT_AVAILABLE_EXT)) {
          queryTime += extTimer.getQueryObjectEXT(query, GL_QUERY_RESULT_EXT);
          freeQuery(query);
        } else {
          pendingQueries[ptr++] = query;
        }
        timeSum[i + 1] = queryTime;
        queryPtr[i + 1] = ptr;
      }
      pendingQueries.length = ptr;

      // Update all pending stat queries
      ptr = 0;
      for (i = 0; i < pendingStats.length; ++i) {
        var stats = pendingStats[i];
        var start = stats.startQueryIndex;
        var end = stats.endQueryIndex;
        stats.sum += timeSum[end] - timeSum[start];
        var startPtr = queryPtr[start];
        var endPtr = queryPtr[end];
        if (endPtr === startPtr) {
          stats.stats.gpuTime += stats.sum / 1e6;
          freePendingStats(stats);
        } else {
          stats.startQueryIndex = startPtr;
          stats.endQueryIndex = endPtr;
          pendingStats[ptr++] = stats;
        }
      }
      pendingStats.length = ptr;
    }

    return {
      beginQuery: beginQuery,
      endQuery: endQuery,
      pushScopeStats: pushScopeStats,
      update: update,
      getNumPendingQueries: function () {
        return pendingQueries.length;
      },
      clear: function () {
        queryPool.push.apply(queryPool, pendingQueries);
        for (var i = 0; i < queryPool.length; i++) {
          extTimer.deleteQueryEXT(queryPool[i]);
        }
        pendingQueries.length = 0;
        queryPool.length = 0;
      },
      restore: function () {
        pendingQueries.length = 0;
        queryPool.length = 0;
      }
    };
  };

  var GL_COLOR_BUFFER_BIT = 16384;
  var GL_DEPTH_BUFFER_BIT = 256;
  var GL_STENCIL_BUFFER_BIT = 1024;

  var GL_ARRAY_BUFFER = 34962;

  var CONTEXT_LOST_EVENT = 'webglcontextlost';
  var CONTEXT_RESTORED_EVENT = 'webglcontextrestored';

  var DYN_PROP = 1;
  var DYN_CONTEXT = 2;
  var DYN_STATE = 3;

  function find(haystack, needle) {
    for (var i = 0; i < haystack.length; ++i) {
      if (haystack[i] === needle) {
        return i;
      }
    }
    return -1;
  }

  function wrapREGL(args) {
    var config = parseArgs(args);
    if (!config) {
      return null;
    }

    var gl = config.gl;
    var glAttributes = gl.getContextAttributes();
    var contextLost = gl.isContextLost();

    var extensionState = createExtensionCache(gl, config);
    if (!extensionState) {
      return null;
    }

    var stringStore = createStringStore();
    var stats$$1 = stats();
    var extensions = extensionState.extensions;
    var timer = createTimer(gl, extensions);

    var START_TIME = clock();
    var WIDTH = gl.drawingBufferWidth;
    var HEIGHT = gl.drawingBufferHeight;

    var contextState = {
      tick: 0,
      time: 0,
      viewportWidth: WIDTH,
      viewportHeight: HEIGHT,
      framebufferWidth: WIDTH,
      framebufferHeight: HEIGHT,
      drawingBufferWidth: WIDTH,
      drawingBufferHeight: HEIGHT,
      pixelRatio: config.pixelRatio
    };
    var uniformState = {};
    var drawState = {
      elements: null,
      primitive: 4, // GL_TRIANGLES
      count: -1,
      offset: 0,
      instances: -1
    };

    var limits = wrapLimits(gl, extensions);
    var bufferState = wrapBufferState(gl, stats$$1, config);
    var elementState = wrapElementsState(gl, extensions, bufferState, stats$$1);
    var attributeState = wrapAttributeState(gl, extensions, limits, bufferState, stringStore);
    var shaderState = wrapShaderState(gl, stringStore, stats$$1, config);
    var textureState = createTextureSet(gl, extensions, limits, function () {
      core.procs.poll();
    }, contextState, stats$$1, config);
    var renderbufferState = wrapRenderbuffers(gl, extensions, limits, stats$$1, config);
    var framebufferState = wrapFBOState(gl, extensions, limits, textureState, renderbufferState, stats$$1);
    var core = reglCore(gl, stringStore, extensions, limits, bufferState, elementState, textureState, framebufferState, uniformState, attributeState, shaderState, drawState, contextState, timer, config);
    var readPixels = wrapReadPixels(gl, framebufferState, core.procs.poll, contextState, glAttributes, extensions);

    var nextState = core.next;
    var canvas = gl.canvas;

    var rafCallbacks = [];
    var lossCallbacks = [];
    var restoreCallbacks = [];
    var destroyCallbacks = [config.onDestroy];

    var activeRAF = null;
    function handleRAF() {
      if (rafCallbacks.length === 0) {
        if (timer) {
          timer.update();
        }
        activeRAF = null;
        return;
      }

      // schedule next animation frame
      activeRAF = raf.next(handleRAF);

      // poll for changes
      poll();

      // fire a callback for all pending rafs
      for (var i = rafCallbacks.length - 1; i >= 0; --i) {
        var cb = rafCallbacks[i];
        if (cb) {
          cb(contextState, null, 0);
        }
      }

      // flush all pending webgl calls
      gl.flush();

      // poll GPU timers *after* gl.flush so we don't delay command dispatch
      if (timer) {
        timer.update();
      }
    }

    function startRAF() {
      if (!activeRAF && rafCallbacks.length > 0) {
        activeRAF = raf.next(handleRAF);
      }
    }

    function stopRAF() {
      if (activeRAF) {
        raf.cancel(handleRAF);
        activeRAF = null;
      }
    }

    function handleContextLoss(event) {
      event.preventDefault();

      // set context lost flag
      contextLost = true;

      // pause request animation frame
      stopRAF();

      // lose context
      lossCallbacks.forEach(function (cb) {
        cb();
      });
    }

    function handleContextRestored(event) {
      // clear error code
      gl.getError();

      // clear context lost flag
      contextLost = false;

      // refresh state
      extensionState.restore();
      shaderState.restore();
      bufferState.restore();
      textureState.restore();
      renderbufferState.restore();
      framebufferState.restore();
      if (timer) {
        timer.restore();
      }

      // refresh state
      core.procs.refresh();

      // restart RAF
      startRAF();

      // restore context
      restoreCallbacks.forEach(function (cb) {
        cb();
      });
    }

    if (canvas) {
      canvas.addEventListener(CONTEXT_LOST_EVENT, handleContextLoss, false);
      canvas.addEventListener(CONTEXT_RESTORED_EVENT, handleContextRestored, false);
    }

    function destroy() {
      rafCallbacks.length = 0;
      stopRAF();

      if (canvas) {
        canvas.removeEventListener(CONTEXT_LOST_EVENT, handleContextLoss);
        canvas.removeEventListener(CONTEXT_RESTORED_EVENT, handleContextRestored);
      }

      shaderState.clear();
      framebufferState.clear();
      renderbufferState.clear();
      textureState.clear();
      elementState.clear();
      bufferState.clear();

      if (timer) {
        timer.clear();
      }

      destroyCallbacks.forEach(function (cb) {
        cb();
      });
    }

    function compileProcedure(options) {
      check$1(!!options, 'invalid args to regl({...})');
      check$1.type(options, 'object', 'invalid args to regl({...})');

      function flattenNestedOptions(options) {
        var result = extend({}, options);
        delete result.uniforms;
        delete result.attributes;
        delete result.context;

        if ('stencil' in result && result.stencil.op) {
          result.stencil.opBack = result.stencil.opFront = result.stencil.op;
          delete result.stencil.op;
        }

        function merge(name) {
          if (name in result) {
            var child = result[name];
            delete result[name];
            Object.keys(child).forEach(function (prop) {
              result[name + '.' + prop] = child[prop];
            });
          }
        }
        merge('blend');
        merge('depth');
        merge('cull');
        merge('stencil');
        merge('polygonOffset');
        merge('scissor');
        merge('sample');

        return result;
      }

      function separateDynamic(object) {
        var staticItems = {};
        var dynamicItems = {};
        Object.keys(object).forEach(function (option) {
          var value = object[option];
          if (dynamic.isDynamic(value)) {
            dynamicItems[option] = dynamic.unbox(value, option);
          } else {
            staticItems[option] = value;
          }
        });
        return {
          dynamic: dynamicItems,
          static: staticItems
        };
      }

      // Treat context variables separate from other dynamic variables
      var context = separateDynamic(options.context || {});
      var uniforms = separateDynamic(options.uniforms || {});
      var attributes = separateDynamic(options.attributes || {});
      var opts = separateDynamic(flattenNestedOptions(options));

      var stats$$1 = {
        gpuTime: 0.0,
        cpuTime: 0.0,
        count: 0
      };

      var compiled = core.compile(opts, attributes, uniforms, context, stats$$1);

      var draw = compiled.draw;
      var batch = compiled.batch;
      var scope = compiled.scope;

      // FIXME: we should modify code generation for batch commands so this
      // isn't necessary
      var EMPTY_ARRAY = [];
      function reserve(count) {
        while (EMPTY_ARRAY.length < count) {
          EMPTY_ARRAY.push(null);
        }
        return EMPTY_ARRAY;
      }

      function REGLCommand(args, body) {
        var i;
        if (contextLost) {
          check$1.raise('context lost');
        }
        if (typeof args === 'function') {
          return scope.call(this, null, args, 0);
        } else if (typeof body === 'function') {
          if (typeof args === 'number') {
            for (i = 0; i < args; ++i) {
              scope.call(this, null, body, i);
            }
            return;
          } else if (Array.isArray(args)) {
            for (i = 0; i < args.length; ++i) {
              scope.call(this, args[i], body, i);
            }
            return;
          } else {
            return scope.call(this, args, body, 0);
          }
        } else if (typeof args === 'number') {
          if (args > 0) {
            return batch.call(this, reserve(args | 0), args | 0);
          }
        } else if (Array.isArray(args)) {
          if (args.length) {
            return batch.call(this, args, args.length);
          }
        } else {
          return draw.call(this, args);
        }
      }

      return extend(REGLCommand, {
        stats: stats$$1
      });
    }

    var setFBO = framebufferState.setFBO = compileProcedure({
      framebuffer: dynamic.define.call(null, DYN_PROP, 'framebuffer')
    });

    function clearImpl(_, options) {
      var clearFlags = 0;
      core.procs.poll();

      var c = options.color;
      if (c) {
        gl.clearColor(+c[0] || 0, +c[1] || 0, +c[2] || 0, +c[3] || 0);
        clearFlags |= GL_COLOR_BUFFER_BIT;
      }
      if ('depth' in options) {
        gl.clearDepth(+options.depth);
        clearFlags |= GL_DEPTH_BUFFER_BIT;
      }
      if ('stencil' in options) {
        gl.clearStencil(options.stencil | 0);
        clearFlags |= GL_STENCIL_BUFFER_BIT;
      }

      check$1(!!clearFlags, 'called regl.clear with no buffer specified');
      gl.clear(clearFlags);
    }

    function clear(options) {
      check$1(typeof options === 'object' && options, 'regl.clear() takes an object as input');
      if ('framebuffer' in options) {
        if (options.framebuffer && options.framebuffer_reglType === 'framebufferCube') {
          for (var i = 0; i < 6; ++i) {
            setFBO(extend({
              framebuffer: options.framebuffer.faces[i]
            }, options), clearImpl);
          }
        } else {
          setFBO(options, clearImpl);
        }
      } else {
        clearImpl(null, options);
      }
    }

    function frame(cb) {
      check$1.type(cb, 'function', 'regl.frame() callback must be a function');
      rafCallbacks.push(cb);

      function cancel() {
        // FIXME:  should we check something other than equals cb here?
        // what if a user calls frame twice with the same callback...
        //
        var i = find(rafCallbacks, cb);
        check$1(i >= 0, 'cannot cancel a frame twice');
        function pendingCancel() {
          var index = find(rafCallbacks, pendingCancel);
          rafCallbacks[index] = rafCallbacks[rafCallbacks.length - 1];
          rafCallbacks.length -= 1;
          if (rafCallbacks.length <= 0) {
            stopRAF();
          }
        }
        rafCallbacks[i] = pendingCancel;
      }

      startRAF();

      return {
        cancel: cancel
      };
    }

    // poll viewport
    function pollViewport() {
      var viewport = nextState.viewport;
      var scissorBox = nextState.scissor_box;
      viewport[0] = viewport[1] = scissorBox[0] = scissorBox[1] = 0;
      contextState.viewportWidth = contextState.framebufferWidth = contextState.drawingBufferWidth = viewport[2] = scissorBox[2] = gl.drawingBufferWidth;
      contextState.viewportHeight = contextState.framebufferHeight = contextState.drawingBufferHeight = viewport[3] = scissorBox[3] = gl.drawingBufferHeight;
    }

    function poll() {
      contextState.tick += 1;
      contextState.time = now();
      pollViewport();
      core.procs.poll();
    }

    function refresh() {
      pollViewport();
      core.procs.refresh();
      if (timer) {
        timer.update();
      }
    }

    function now() {
      return (clock() - START_TIME) / 1000.0;
    }

    refresh();

    function addListener(event, callback) {
      check$1.type(callback, 'function', 'listener callback must be a function');

      var callbacks;
      switch (event) {
        case 'frame':
          return frame(callback);
        case 'lost':
          callbacks = lossCallbacks;
          break;
        case 'restore':
          callbacks = restoreCallbacks;
          break;
        case 'destroy':
          callbacks = destroyCallbacks;
          break;
        default:
          check$1.raise('invalid event, must be one of frame,lost,restore,destroy');
      }

      callbacks.push(callback);
      return {
        cancel: function () {
          for (var i = 0; i < callbacks.length; ++i) {
            if (callbacks[i] === callback) {
              callbacks[i] = callbacks[callbacks.length - 1];
              callbacks.pop();
              return;
            }
          }
        }
      };
    }

    var regl = extend(compileProcedure, {
      // Clear current FBO
      clear: clear,

      // Short cuts for dynamic variables
      prop: dynamic.define.bind(null, DYN_PROP),
      context: dynamic.define.bind(null, DYN_CONTEXT),
      this: dynamic.define.bind(null, DYN_STATE),

      // executes an empty draw command
      draw: compileProcedure({}),

      // Resources
      buffer: function (options) {
        return bufferState.create(options, GL_ARRAY_BUFFER, false, false);
      },
      elements: function (options) {
        return elementState.create(options, false);
      },
      texture: textureState.create2D,
      cube: textureState.createCube,
      renderbuffer: renderbufferState.create,
      framebuffer: framebufferState.create,
      framebufferCube: framebufferState.createCube,

      // Expose context attributes
      attributes: glAttributes,

      // Frame rendering
      frame: frame,
      on: addListener,

      // System limits
      limits: limits,
      hasExtension: function (name) {
        return limits.extensions.indexOf(name.toLowerCase()) >= 0;
      },

      // Read pixels
      read: readPixels,

      // Destroy regl and all associated resources
      destroy: destroy,

      // Direct GL state manipulation
      _gl: gl,
      _refresh: refresh,

      poll: function () {
        poll();
        if (timer) {
          timer.update();
        }
      },

      // Current time
      now: now,

      // regl Statistics Information
      stats: stats$$1
    });

    config.onDone(null, regl);

    return regl;
  }

  return wrapREGL;
});


},{}],134:[function(require,module,exports){
/*!
 * repeat-string <https://github.com/jonschlinkert/repeat-string>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

/**
 * Results cache
 */

var res = '';
var cache;

/**
 * Expose `repeat`
 */

module.exports = repeat;

/**
 * Repeat the given `string` the specified `number`
 * of times.
 *
 * **Example:**
 *
 * ```js
 * var repeat = require('repeat-string');
 * repeat('A', 5);
 * //=> AAAAA
 * ```
 *
 * @param {String} `string` The string to repeat
 * @param {Number} `number` The number of times to repeat the string
 * @return {String} Repeated string
 * @api public
 */

function repeat(str, num) {
  if (typeof str !== 'string') {
    throw new TypeError('expected a string');
  }

  // cover common, quick use cases
  if (num === 1) return str;
  if (num === 2) return str + str;

  var max = str.length * num;
  if (cache !== str || typeof cache === 'undefined') {
    cache = str;
    res = '';
  } else if (res.length >= max) {
    return res.substr(0, max);
  }

  while (max > res.length && num > 1) {
    if (num & 1) {
      res += str;
    }

    num >>= 1;
    str += str;
  }

  res += str;
  res = res.substr(0, max);
  return res;
}

},{}],135:[function(require,module,exports){
(function (global){
module.exports = global.performance && global.performance.now ? function now() {
  return performance.now();
} : Date.now || function now() {
  return +new Date();
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],136:[function(require,module,exports){
"use strict";

var twoProduct = require("two-product");
var robustSum = require("robust-sum");
var robustDiff = require("robust-subtract");
var robustScale = require("robust-scale");

var NUM_EXPAND = 6;

function cofactor(m, c) {
  var result = new Array(m.length - 1);
  for (var i = 1; i < m.length; ++i) {
    var r = result[i - 1] = new Array(m.length - 1);
    for (var j = 0, k = 0; j < m.length; ++j) {
      if (j === c) {
        continue;
      }
      r[k++] = m[i][j];
    }
  }
  return result;
}

function matrix(n) {
  var result = new Array(n);
  for (var i = 0; i < n; ++i) {
    result[i] = new Array(n);
    for (var j = 0; j < n; ++j) {
      result[i][j] = ["m", j, "[", n - i - 2, "]"].join("");
    }
  }
  return result;
}

function generateSum(expr) {
  if (expr.length === 1) {
    return expr[0];
  } else if (expr.length === 2) {
    return ["sum(", expr[0], ",", expr[1], ")"].join("");
  } else {
    var m = expr.length >> 1;
    return ["sum(", generateSum(expr.slice(0, m)), ",", generateSum(expr.slice(m)), ")"].join("");
  }
}

function makeProduct(a, b) {
  if (a.charAt(0) === "m") {
    if (b.charAt(0) === "w") {
      var toks = a.split("[");
      return ["w", b.substr(1), "m", toks[0].substr(1)].join("");
    } else {
      return ["prod(", a, ",", b, ")"].join("");
    }
  } else {
    return makeProduct(b, a);
  }
}

function sign(s) {
  if (s & 1 !== 0) {
    return "-";
  }
  return "";
}

function determinant(m) {
  if (m.length === 2) {
    return [["diff(", makeProduct(m[0][0], m[1][1]), ",", makeProduct(m[1][0], m[0][1]), ")"].join("")];
  } else {
    var expr = [];
    for (var i = 0; i < m.length; ++i) {
      expr.push(["scale(", generateSum(determinant(cofactor(m, i))), ",", sign(i), m[0][i], ")"].join(""));
    }
    return expr;
  }
}

function makeSquare(d, n) {
  var terms = [];
  for (var i = 0; i < n - 2; ++i) {
    terms.push(["prod(m", d, "[", i, "],m", d, "[", i, "])"].join(""));
  }
  return generateSum(terms);
}

function orientation(n) {
  var pos = [];
  var neg = [];
  var m = matrix(n);
  for (var i = 0; i < n; ++i) {
    m[0][i] = "1";
    m[n - 1][i] = "w" + i;
  }
  for (var i = 0; i < n; ++i) {
    if ((i & 1) === 0) {
      pos.push.apply(pos, determinant(cofactor(m, i)));
    } else {
      neg.push.apply(neg, determinant(cofactor(m, i)));
    }
  }
  var posExpr = generateSum(pos);
  var negExpr = generateSum(neg);
  var funcName = "exactInSphere" + n;
  var funcArgs = [];
  for (var i = 0; i < n; ++i) {
    funcArgs.push("m" + i);
  }
  var code = ["function ", funcName, "(", funcArgs.join(), "){"];
  for (var i = 0; i < n; ++i) {
    code.push("var w", i, "=", makeSquare(i, n), ";");
    for (var j = 0; j < n; ++j) {
      if (j !== i) {
        code.push("var w", i, "m", j, "=scale(w", i, ",m", j, "[0]);");
      }
    }
  }
  code.push("var p=", posExpr, ",n=", negExpr, ",d=diff(p,n);return d[d.length-1];}return ", funcName);
  var proc = new Function("sum", "diff", "prod", "scale", code.join(""));
  return proc(robustSum, robustDiff, twoProduct, robustScale);
}

function inSphere0() {
  return 0;
}
function inSphere1() {
  return 0;
}
function inSphere2() {
  return 0;
}

var CACHED = [inSphere0, inSphere1, inSphere2];

function slowInSphere(args) {
  var proc = CACHED[args.length];
  if (!proc) {
    proc = CACHED[args.length] = orientation(args.length);
  }
  return proc.apply(undefined, args);
}

function generateInSphereTest() {
  while (CACHED.length <= NUM_EXPAND) {
    CACHED.push(orientation(CACHED.length));
  }
  var args = [];
  var procArgs = ["slow"];
  for (var i = 0; i <= NUM_EXPAND; ++i) {
    args.push("a" + i);
    procArgs.push("o" + i);
  }
  var code = ["function testInSphere(", args.join(), "){switch(arguments.length){case 0:case 1:return 0;"];
  for (var i = 2; i <= NUM_EXPAND; ++i) {
    code.push("case ", i, ":return o", i, "(", args.slice(0, i).join(), ");");
  }
  code.push("}var s=new Array(arguments.length);for(var i=0;i<arguments.length;++i){s[i]=arguments[i]};return slow(s);}return testInSphere");
  procArgs.push(code.join(""));

  var proc = Function.apply(undefined, procArgs);

  module.exports = proc.apply(undefined, [slowInSphere].concat(CACHED));
  for (var i = 0; i <= NUM_EXPAND; ++i) {
    module.exports[i] = CACHED[i];
  }
}

generateInSphereTest();

},{"robust-scale":139,"robust-subtract":141,"robust-sum":142,"two-product":159}],137:[function(require,module,exports){
"use strict";

var twoProduct = require("two-product");
var robustSum = require("robust-sum");
var robustScale = require("robust-scale");
var robustSubtract = require("robust-subtract");

var NUM_EXPAND = 5;

var EPSILON = 1.1102230246251565e-16;
var ERRBOUND3 = (3.0 + 16.0 * EPSILON) * EPSILON;
var ERRBOUND4 = (7.0 + 56.0 * EPSILON) * EPSILON;

function cofactor(m, c) {
  var result = new Array(m.length - 1);
  for (var i = 1; i < m.length; ++i) {
    var r = result[i - 1] = new Array(m.length - 1);
    for (var j = 0, k = 0; j < m.length; ++j) {
      if (j === c) {
        continue;
      }
      r[k++] = m[i][j];
    }
  }
  return result;
}

function matrix(n) {
  var result = new Array(n);
  for (var i = 0; i < n; ++i) {
    result[i] = new Array(n);
    for (var j = 0; j < n; ++j) {
      result[i][j] = ["m", j, "[", n - i - 1, "]"].join("");
    }
  }
  return result;
}

function sign(n) {
  if (n & 1) {
    return "-";
  }
  return "";
}

function generateSum(expr) {
  if (expr.length === 1) {
    return expr[0];
  } else if (expr.length === 2) {
    return ["sum(", expr[0], ",", expr[1], ")"].join("");
  } else {
    var m = expr.length >> 1;
    return ["sum(", generateSum(expr.slice(0, m)), ",", generateSum(expr.slice(m)), ")"].join("");
  }
}

function determinant(m) {
  if (m.length === 2) {
    return [["sum(prod(", m[0][0], ",", m[1][1], "),prod(-", m[0][1], ",", m[1][0], "))"].join("")];
  } else {
    var expr = [];
    for (var i = 0; i < m.length; ++i) {
      expr.push(["scale(", generateSum(determinant(cofactor(m, i))), ",", sign(i), m[0][i], ")"].join(""));
    }
    return expr;
  }
}

function orientation(n) {
  var pos = [];
  var neg = [];
  var m = matrix(n);
  var args = [];
  for (var i = 0; i < n; ++i) {
    if ((i & 1) === 0) {
      pos.push.apply(pos, determinant(cofactor(m, i)));
    } else {
      neg.push.apply(neg, determinant(cofactor(m, i)));
    }
    args.push("m" + i);
  }
  var posExpr = generateSum(pos);
  var negExpr = generateSum(neg);
  var funcName = "orientation" + n + "Exact";
  var code = ["function ", funcName, "(", args.join(), "){var p=", posExpr, ",n=", negExpr, ",d=sub(p,n);\
return d[d.length-1];};return ", funcName].join("");
  var proc = new Function("sum", "prod", "scale", "sub", code);
  return proc(robustSum, twoProduct, robustScale, robustSubtract);
}

var orientation3Exact = orientation(3);
var orientation4Exact = orientation(4);

var CACHED = [function orientation0() {
  return 0;
}, function orientation1() {
  return 0;
}, function orientation2(a, b) {
  return b[0] - a[0];
}, function orientation3(a, b, c) {
  var l = (a[1] - c[1]) * (b[0] - c[0]);
  var r = (a[0] - c[0]) * (b[1] - c[1]);
  var det = l - r;
  var s;
  if (l > 0) {
    if (r <= 0) {
      return det;
    } else {
      s = l + r;
    }
  } else if (l < 0) {
    if (r >= 0) {
      return det;
    } else {
      s = -(l + r);
    }
  } else {
    return det;
  }
  var tol = ERRBOUND3 * s;
  if (det >= tol || det <= -tol) {
    return det;
  }
  return orientation3Exact(a, b, c);
}, function orientation4(a, b, c, d) {
  var adx = a[0] - d[0];
  var bdx = b[0] - d[0];
  var cdx = c[0] - d[0];
  var ady = a[1] - d[1];
  var bdy = b[1] - d[1];
  var cdy = c[1] - d[1];
  var adz = a[2] - d[2];
  var bdz = b[2] - d[2];
  var cdz = c[2] - d[2];
  var bdxcdy = bdx * cdy;
  var cdxbdy = cdx * bdy;
  var cdxady = cdx * ady;
  var adxcdy = adx * cdy;
  var adxbdy = adx * bdy;
  var bdxady = bdx * ady;
  var det = adz * (bdxcdy - cdxbdy) + bdz * (cdxady - adxcdy) + cdz * (adxbdy - bdxady);
  var permanent = (Math.abs(bdxcdy) + Math.abs(cdxbdy)) * Math.abs(adz) + (Math.abs(cdxady) + Math.abs(adxcdy)) * Math.abs(bdz) + (Math.abs(adxbdy) + Math.abs(bdxady)) * Math.abs(cdz);
  var tol = ERRBOUND4 * permanent;
  if (det > tol || -det > tol) {
    return det;
  }
  return orientation4Exact(a, b, c, d);
}];

function slowOrient(args) {
  var proc = CACHED[args.length];
  if (!proc) {
    proc = CACHED[args.length] = orientation(args.length);
  }
  return proc.apply(undefined, args);
}

function generateOrientationProc() {
  while (CACHED.length <= NUM_EXPAND) {
    CACHED.push(orientation(CACHED.length));
  }
  var args = [];
  var procArgs = ["slow"];
  for (var i = 0; i <= NUM_EXPAND; ++i) {
    args.push("a" + i);
    procArgs.push("o" + i);
  }
  var code = ["function getOrientation(", args.join(), "){switch(arguments.length){case 0:case 1:return 0;"];
  for (var i = 2; i <= NUM_EXPAND; ++i) {
    code.push("case ", i, ":return o", i, "(", args.slice(0, i).join(), ");");
  }
  code.push("}var s=new Array(arguments.length);for(var i=0;i<arguments.length;++i){s[i]=arguments[i]};return slow(s);}return getOrientation");
  procArgs.push(code.join(""));

  var proc = Function.apply(undefined, procArgs);
  module.exports = proc.apply(undefined, [slowOrient].concat(CACHED));
  for (var i = 0; i <= NUM_EXPAND; ++i) {
    module.exports[i] = CACHED[i];
  }
}

generateOrientationProc();

},{"robust-scale":139,"robust-subtract":141,"robust-sum":142,"two-product":159}],138:[function(require,module,exports){
"use strict";

var robustSum = require("robust-sum");
var robustScale = require("robust-scale");

module.exports = robustProduct;

function robustProduct(a, b) {
  if (a.length === 1) {
    return robustScale(b, a[0]);
  }
  if (b.length === 1) {
    return robustScale(a, b[0]);
  }
  if (a.length === 0 || b.length === 0) {
    return [0];
  }
  var r = [0];
  if (a.length < b.length) {
    for (var i = 0; i < a.length; ++i) {
      r = robustSum(r, robustScale(b, a[i]));
    }
  } else {
    for (var i = 0; i < b.length; ++i) {
      r = robustSum(r, robustScale(a, b[i]));
    }
  }
  return r;
}

},{"robust-scale":139,"robust-sum":142}],139:[function(require,module,exports){
"use strict";

var twoProduct = require("two-product");
var twoSum = require("two-sum");

module.exports = scaleLinearExpansion;

function scaleLinearExpansion(e, scale) {
  var n = e.length;
  if (n === 1) {
    var ts = twoProduct(e[0], scale);
    if (ts[0]) {
      return ts;
    }
    return [ts[1]];
  }
  var g = new Array(2 * n);
  var q = [0.1, 0.1];
  var t = [0.1, 0.1];
  var count = 0;
  twoProduct(e[0], scale, q);
  if (q[0]) {
    g[count++] = q[0];
  }
  for (var i = 1; i < n; ++i) {
    twoProduct(e[i], scale, t);
    var pq = q[1];
    twoSum(pq, t[0], q);
    if (q[0]) {
      g[count++] = q[0];
    }
    var a = t[1];
    var b = q[1];
    var x = a + b;
    var bv = x - a;
    var y = b - bv;
    q[1] = x;
    if (y) {
      g[count++] = y;
    }
  }
  if (q[1]) {
    g[count++] = q[1];
  }
  if (count === 0) {
    g[count++] = 0.0;
  }
  g.length = count;
  return g;
}

},{"two-product":159,"two-sum":160}],140:[function(require,module,exports){
"use strict";

module.exports = segmentsIntersect;

var orient = require("robust-orientation")[3];

function checkCollinear(a0, a1, b0, b1) {

  for (var d = 0; d < 2; ++d) {
    var x0 = a0[d];
    var y0 = a1[d];
    var l0 = Math.min(x0, y0);
    var h0 = Math.max(x0, y0);

    var x1 = b0[d];
    var y1 = b1[d];
    var l1 = Math.min(x1, y1);
    var h1 = Math.max(x1, y1);

    if (h1 < l0 || h0 < l1) {
      return false;
    }
  }

  return true;
}

function segmentsIntersect(a0, a1, b0, b1) {
  var x0 = orient(a0, b0, b1);
  var y0 = orient(a1, b0, b1);
  if (x0 > 0 && y0 > 0 || x0 < 0 && y0 < 0) {
    return false;
  }

  var x1 = orient(b0, a0, a1);
  var y1 = orient(b1, a0, a1);
  if (x1 > 0 && y1 > 0 || x1 < 0 && y1 < 0) {
    return false;
  }

  //Check for degenerate collinear case
  if (x0 === 0 && y0 === 0 && x1 === 0 && y1 === 0) {
    return checkCollinear(a0, a1, b0, b1);
  }

  return true;
}

},{"robust-orientation":137}],141:[function(require,module,exports){
"use strict";

module.exports = robustSubtract;

//Easy case: Add two scalars
function scalarScalar(a, b) {
  var x = a + b;
  var bv = x - a;
  var av = x - bv;
  var br = b - bv;
  var ar = a - av;
  var y = ar + br;
  if (y) {
    return [y, x];
  }
  return [x];
}

function robustSubtract(e, f) {
  var ne = e.length | 0;
  var nf = f.length | 0;
  if (ne === 1 && nf === 1) {
    return scalarScalar(e[0], -f[0]);
  }
  var n = ne + nf;
  var g = new Array(n);
  var count = 0;
  var eptr = 0;
  var fptr = 0;
  var abs = Math.abs;
  var ei = e[eptr];
  var ea = abs(ei);
  var fi = -f[fptr];
  var fa = abs(fi);
  var a, b;
  if (ea < fa) {
    b = ei;
    eptr += 1;
    if (eptr < ne) {
      ei = e[eptr];
      ea = abs(ei);
    }
  } else {
    b = fi;
    fptr += 1;
    if (fptr < nf) {
      fi = -f[fptr];
      fa = abs(fi);
    }
  }
  if (eptr < ne && ea < fa || fptr >= nf) {
    a = ei;
    eptr += 1;
    if (eptr < ne) {
      ei = e[eptr];
      ea = abs(ei);
    }
  } else {
    a = fi;
    fptr += 1;
    if (fptr < nf) {
      fi = -f[fptr];
      fa = abs(fi);
    }
  }
  var x = a + b;
  var bv = x - a;
  var y = b - bv;
  var q0 = y;
  var q1 = x;
  var _x, _bv, _av, _br, _ar;
  while (eptr < ne && fptr < nf) {
    if (ea < fa) {
      a = ei;
      eptr += 1;
      if (eptr < ne) {
        ei = e[eptr];
        ea = abs(ei);
      }
    } else {
      a = fi;
      fptr += 1;
      if (fptr < nf) {
        fi = -f[fptr];
        fa = abs(fi);
      }
    }
    b = q0;
    x = a + b;
    bv = x - a;
    y = b - bv;
    if (y) {
      g[count++] = y;
    }
    _x = q1 + x;
    _bv = _x - q1;
    _av = _x - _bv;
    _br = x - _bv;
    _ar = q1 - _av;
    q0 = _ar + _br;
    q1 = _x;
  }
  while (eptr < ne) {
    a = ei;
    b = q0;
    x = a + b;
    bv = x - a;
    y = b - bv;
    if (y) {
      g[count++] = y;
    }
    _x = q1 + x;
    _bv = _x - q1;
    _av = _x - _bv;
    _br = x - _bv;
    _ar = q1 - _av;
    q0 = _ar + _br;
    q1 = _x;
    eptr += 1;
    if (eptr < ne) {
      ei = e[eptr];
    }
  }
  while (fptr < nf) {
    a = fi;
    b = q0;
    x = a + b;
    bv = x - a;
    y = b - bv;
    if (y) {
      g[count++] = y;
    }
    _x = q1 + x;
    _bv = _x - q1;
    _av = _x - _bv;
    _br = x - _bv;
    _ar = q1 - _av;
    q0 = _ar + _br;
    q1 = _x;
    fptr += 1;
    if (fptr < nf) {
      fi = -f[fptr];
    }
  }
  if (q0) {
    g[count++] = q0;
  }
  if (q1) {
    g[count++] = q1;
  }
  if (!count) {
    g[count++] = 0.0;
  }
  g.length = count;
  return g;
}

},{}],142:[function(require,module,exports){
"use strict";

module.exports = linearExpansionSum;

//Easy case: Add two scalars
function scalarScalar(a, b) {
  var x = a + b;
  var bv = x - a;
  var av = x - bv;
  var br = b - bv;
  var ar = a - av;
  var y = ar + br;
  if (y) {
    return [y, x];
  }
  return [x];
}

function linearExpansionSum(e, f) {
  var ne = e.length | 0;
  var nf = f.length | 0;
  if (ne === 1 && nf === 1) {
    return scalarScalar(e[0], f[0]);
  }
  var n = ne + nf;
  var g = new Array(n);
  var count = 0;
  var eptr = 0;
  var fptr = 0;
  var abs = Math.abs;
  var ei = e[eptr];
  var ea = abs(ei);
  var fi = f[fptr];
  var fa = abs(fi);
  var a, b;
  if (ea < fa) {
    b = ei;
    eptr += 1;
    if (eptr < ne) {
      ei = e[eptr];
      ea = abs(ei);
    }
  } else {
    b = fi;
    fptr += 1;
    if (fptr < nf) {
      fi = f[fptr];
      fa = abs(fi);
    }
  }
  if (eptr < ne && ea < fa || fptr >= nf) {
    a = ei;
    eptr += 1;
    if (eptr < ne) {
      ei = e[eptr];
      ea = abs(ei);
    }
  } else {
    a = fi;
    fptr += 1;
    if (fptr < nf) {
      fi = f[fptr];
      fa = abs(fi);
    }
  }
  var x = a + b;
  var bv = x - a;
  var y = b - bv;
  var q0 = y;
  var q1 = x;
  var _x, _bv, _av, _br, _ar;
  while (eptr < ne && fptr < nf) {
    if (ea < fa) {
      a = ei;
      eptr += 1;
      if (eptr < ne) {
        ei = e[eptr];
        ea = abs(ei);
      }
    } else {
      a = fi;
      fptr += 1;
      if (fptr < nf) {
        fi = f[fptr];
        fa = abs(fi);
      }
    }
    b = q0;
    x = a + b;
    bv = x - a;
    y = b - bv;
    if (y) {
      g[count++] = y;
    }
    _x = q1 + x;
    _bv = _x - q1;
    _av = _x - _bv;
    _br = x - _bv;
    _ar = q1 - _av;
    q0 = _ar + _br;
    q1 = _x;
  }
  while (eptr < ne) {
    a = ei;
    b = q0;
    x = a + b;
    bv = x - a;
    y = b - bv;
    if (y) {
      g[count++] = y;
    }
    _x = q1 + x;
    _bv = _x - q1;
    _av = _x - _bv;
    _br = x - _bv;
    _ar = q1 - _av;
    q0 = _ar + _br;
    q1 = _x;
    eptr += 1;
    if (eptr < ne) {
      ei = e[eptr];
    }
  }
  while (fptr < nf) {
    a = fi;
    b = q0;
    x = a + b;
    bv = x - a;
    y = b - bv;
    if (y) {
      g[count++] = y;
    }
    _x = q1 + x;
    _bv = _x - q1;
    _av = _x - _bv;
    _br = x - _bv;
    _ar = q1 - _av;
    q0 = _ar + _br;
    q1 = _x;
    fptr += 1;
    if (fptr < nf) {
      fi = f[fptr];
    }
  }
  if (q0) {
    g[count++] = q0;
  }
  if (q1) {
    g[count++] = q1;
  }
  if (!count) {
    g[count++] = 0.0;
  }
  g.length = count;
  return g;
}

},{}],143:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"dup":27}],144:[function(require,module,exports){
"use strict";"use restrict";

module.exports = UnionFind;

function UnionFind(count) {
  this.roots = new Array(count);
  this.ranks = new Array(count);

  for (var i = 0; i < count; ++i) {
    this.roots[i] = i;
    this.ranks[i] = 0;
  }
}

UnionFind.prototype.length = function () {
  return this.roots.length;
};

UnionFind.prototype.makeSet = function () {
  var n = this.roots.length;
  this.roots.push(n);
  this.ranks.push(0);
  return n;
};

UnionFind.prototype.find = function (x) {
  var roots = this.roots;
  while (roots[x] !== x) {
    var y = roots[x];
    roots[x] = roots[y];
    x = y;
  }
  return x;
};

UnionFind.prototype.link = function (x, y) {
  var xr = this.find(x),
      yr = this.find(y);
  if (xr === yr) {
    return;
  }
  var ranks = this.ranks,
      roots = this.roots,
      xd = ranks[xr],
      yd = ranks[yr];
  if (xd < yd) {
    roots[xr] = yr;
  } else if (yd < xd) {
    roots[yr] = xr;
  } else {
    roots[yr] = xr;
    ++ranks[xr];
  }
};

},{}],145:[function(require,module,exports){
"use strict";"use restrict";

var bits = require("bit-twiddle"),
    UnionFind = require("union-find"

//Returns the dimension of a cell complex
);function dimension(cells) {
  var d = 0,
      max = Math.max;
  for (var i = 0, il = cells.length; i < il; ++i) {
    d = max(d, cells[i].length);
  }
  return d - 1;
}
exports.dimension = dimension;

//Counts the number of vertices in faces
function countVertices(cells) {
  var vc = -1,
      max = Math.max;
  for (var i = 0, il = cells.length; i < il; ++i) {
    var c = cells[i];
    for (var j = 0, jl = c.length; j < jl; ++j) {
      vc = max(vc, c[j]);
    }
  }
  return vc + 1;
}
exports.countVertices = countVertices;

//Returns a deep copy of cells
function cloneCells(cells) {
  var ncells = new Array(cells.length);
  for (var i = 0, il = cells.length; i < il; ++i) {
    ncells[i] = cells[i].slice(0);
  }
  return ncells;
}
exports.cloneCells = cloneCells;

//Ranks a pair of cells up to permutation
function compareCells(a, b) {
  var n = a.length,
      t = a.length - b.length,
      min = Math.min;
  if (t) {
    return t;
  }
  switch (n) {
    case 0:
      return 0;
    case 1:
      return a[0] - b[0];
    case 2:
      var d = a[0] + a[1] - b[0] - b[1];
      if (d) {
        return d;
      }
      return min(a[0], a[1]) - min(b[0], b[1]);
    case 3:
      var l1 = a[0] + a[1],
          m1 = b[0] + b[1];
      d = l1 + a[2] - (m1 + b[2]);
      if (d) {
        return d;
      }
      var l0 = min(a[0], a[1]),
          m0 = min(b[0], b[1]),
          d = min(l0, a[2]) - min(m0, b[2]);
      if (d) {
        return d;
      }
      return min(l0 + a[2], l1) - min(m0 + b[2], m1

      //TODO: Maybe optimize n=4 as well?

      );default:
      var as = a.slice(0);
      as.sort();
      var bs = b.slice(0);
      bs.sort();
      for (var i = 0; i < n; ++i) {
        t = as[i] - bs[i];
        if (t) {
          return t;
        }
      }
      return 0;
  }
}
exports.compareCells = compareCells;

function compareZipped(a, b) {
  return compareCells(a[0], b[0]);
}

//Puts a cell complex into normal order for the purposes of findCell queries
function normalize(cells, attr) {
  if (attr) {
    var len = cells.length;
    var zipped = new Array(len);
    for (var i = 0; i < len; ++i) {
      zipped[i] = [cells[i], attr[i]];
    }
    zipped.sort(compareZipped);
    for (var i = 0; i < len; ++i) {
      cells[i] = zipped[i][0];
      attr[i] = zipped[i][1];
    }
    return cells;
  } else {
    cells.sort(compareCells);
    return cells;
  }
}
exports.normalize = normalize;

//Removes all duplicate cells in the complex
function unique(cells) {
  if (cells.length === 0) {
    return [];
  }
  var ptr = 1,
      len = cells.length;
  for (var i = 1; i < len; ++i) {
    var a = cells[i];
    if (compareCells(a, cells[i - 1])) {
      if (i === ptr) {
        ptr++;
        continue;
      }
      cells[ptr++] = a;
    }
  }
  cells.length = ptr;
  return cells;
}
exports.unique = unique;

//Finds a cell in a normalized cell complex
function findCell(cells, c) {
  var lo = 0,
      hi = cells.length - 1,
      r = -1;
  while (lo <= hi) {
    var mid = lo + hi >> 1,
        s = compareCells(cells[mid], c);
    if (s <= 0) {
      if (s === 0) {
        r = mid;
      }
      lo = mid + 1;
    } else if (s > 0) {
      hi = mid - 1;
    }
  }
  return r;
}
exports.findCell = findCell;

//Builds an index for an n-cell.  This is more general than dual, but less efficient
function incidence(from_cells, to_cells) {
  var index = new Array(from_cells.length);
  for (var i = 0, il = index.length; i < il; ++i) {
    index[i] = [];
  }
  var b = [];
  for (var i = 0, n = to_cells.length; i < n; ++i) {
    var c = to_cells[i];
    var cl = c.length;
    for (var k = 1, kn = 1 << cl; k < kn; ++k) {
      b.length = bits.popCount(k);
      var l = 0;
      for (var j = 0; j < cl; ++j) {
        if (k & 1 << j) {
          b[l++] = c[j];
        }
      }
      var idx = findCell(from_cells, b);
      if (idx < 0) {
        continue;
      }
      while (true) {
        index[idx++].push(i);
        if (idx >= from_cells.length || compareCells(from_cells[idx], b) !== 0) {
          break;
        }
      }
    }
  }
  return index;
}
exports.incidence = incidence;

//Computes the dual of the mesh.  This is basically an optimized version of buildIndex for the situation where from_cells is just the list of vertices
function dual(cells, vertex_count) {
  if (!vertex_count) {
    return incidence(unique(skeleton(cells, 0)), cells, 0);
  }
  var res = new Array(vertex_count);
  for (var i = 0; i < vertex_count; ++i) {
    res[i] = [];
  }
  for (var i = 0, len = cells.length; i < len; ++i) {
    var c = cells[i];
    for (var j = 0, cl = c.length; j < cl; ++j) {
      res[c[j]].push(i);
    }
  }
  return res;
}
exports.dual = dual;

//Enumerates all cells in the complex
function explode(cells) {
  var result = [];
  for (var i = 0, il = cells.length; i < il; ++i) {
    var c = cells[i],
        cl = c.length | 0;
    for (var j = 1, jl = 1 << cl; j < jl; ++j) {
      var b = [];
      for (var k = 0; k < cl; ++k) {
        if (j >>> k & 1) {
          b.push(c[k]);
        }
      }
      result.push(b);
    }
  }
  return normalize(result);
}
exports.explode = explode;

//Enumerates all of the n-cells of a cell complex
function skeleton(cells, n) {
  if (n < 0) {
    return [];
  }
  var result = [],
      k0 = (1 << n + 1) - 1;
  for (var i = 0; i < cells.length; ++i) {
    var c = cells[i];
    for (var k = k0; k < 1 << c.length; k = bits.nextCombination(k)) {
      var b = new Array(n + 1),
          l = 0;
      for (var j = 0; j < c.length; ++j) {
        if (k & 1 << j) {
          b[l++] = c[j];
        }
      }
      result.push(b);
    }
  }
  return normalize(result);
}
exports.skeleton = skeleton;

//Computes the boundary of all cells, does not remove duplicates
function boundary(cells) {
  var res = [];
  for (var i = 0, il = cells.length; i < il; ++i) {
    var c = cells[i];
    for (var j = 0, cl = c.length; j < cl; ++j) {
      var b = new Array(c.length - 1);
      for (var k = 0, l = 0; k < cl; ++k) {
        if (k !== j) {
          b[l++] = c[k];
        }
      }
      res.push(b);
    }
  }
  return normalize(res);
}
exports.boundary = boundary;

//Computes connected components for a dense cell complex
function connectedComponents_dense(cells, vertex_count) {
  var labels = new UnionFind(vertex_count);
  for (var i = 0; i < cells.length; ++i) {
    var c = cells[i];
    for (var j = 0; j < c.length; ++j) {
      for (var k = j + 1; k < c.length; ++k) {
        labels.link(c[j], c[k]);
      }
    }
  }
  var components = [],
      component_labels = labels.ranks;
  for (var i = 0; i < component_labels.length; ++i) {
    component_labels[i] = -1;
  }
  for (var i = 0; i < cells.length; ++i) {
    var l = labels.find(cells[i][0]);
    if (component_labels[l] < 0) {
      component_labels[l] = components.length;
      components.push([cells[i].slice(0)]);
    } else {
      components[component_labels[l]].push(cells[i].slice(0));
    }
  }
  return components;
}

//Computes connected components for a sparse graph
function connectedComponents_sparse(cells) {
  var vertices = unique(normalize(skeleton(cells, 0))),
      labels = new UnionFind(vertices.length);
  for (var i = 0; i < cells.length; ++i) {
    var c = cells[i];
    for (var j = 0; j < c.length; ++j) {
      var vj = findCell(vertices, [c[j]]);
      for (var k = j + 1; k < c.length; ++k) {
        labels.link(vj, findCell(vertices, [c[k]]));
      }
    }
  }
  var components = [],
      component_labels = labels.ranks;
  for (var i = 0; i < component_labels.length; ++i) {
    component_labels[i] = -1;
  }
  for (var i = 0; i < cells.length; ++i) {
    var l = labels.find(findCell(vertices, [cells[i][0]]));
    if (component_labels[l] < 0) {
      component_labels[l] = components.length;
      components.push([cells[i].slice(0)]);
    } else {
      components[component_labels[l]].push(cells[i].slice(0));
    }
  }
  return components;
}

//Computes connected components for a cell complex
function connectedComponents(cells, vertex_count) {
  if (vertex_count) {
    return connectedComponents_dense(cells, vertex_count);
  }
  return connectedComponents_sparse(cells);
}
exports.connectedComponents = connectedComponents;

},{"bit-twiddle":143,"union-find":144}],146:[function(require,module,exports){
"use strict";

module.exports = simplifyPolygon;

var orient = require("robust-orientation");
var sc = require("simplicial-complex");

function errorWeight(base, a, b) {
  var area = Math.abs(orient(base, a, b));
  var perim = Math.sqrt(Math.pow(a[0] - b[0], 2) + Math.pow(a[1] - b[1], 2));
  return area / perim;
}

function simplifyPolygon(cells, positions, minArea) {

  var n = positions.length;
  var nc = cells.length;
  var inv = new Array(n);
  var outv = new Array(n);
  var weights = new Array(n);
  var dead = new Array(n);

  //Initialize tables
  for (var i = 0; i < n; ++i) {
    inv[i] = outv[i] = -1;
    weights[i] = Infinity;
    dead[i] = false;
  }

  //Compute neighbors
  for (var i = 0; i < nc; ++i) {
    var c = cells[i];
    if (c.length !== 2) {
      throw new Error("Input must be a graph");
    }
    var s = c[1];
    var t = c[0];
    if (outv[t] !== -1) {
      outv[t] = -2;
    } else {
      outv[t] = s;
    }
    if (inv[s] !== -1) {
      inv[s] = -2;
    } else {
      inv[s] = t;
    }
  }

  //Updates the weight for vertex i
  function computeWeight(i) {
    if (dead[i]) {
      return Infinity;
    }
    //TODO: Check that the line segment doesn't cross once simplified
    var s = inv[i];
    var t = outv[i];
    if (s < 0 || t < 0) {
      return Infinity;
    } else {
      return errorWeight(positions[i], positions[s], positions[t]);
    }
  }

  //Swaps two nodes on the heap (i,j) are the index of the nodes
  function heapSwap(i, j) {
    var a = heap[i];
    var b = heap[j];
    heap[i] = b;
    heap[j] = a;
    index[a] = j;
    index[b] = i;
  }

  //Returns the weight of node i on the heap
  function heapWeight(i) {
    return weights[heap[i]];
  }

  function heapParent(i) {
    if (i & 1) {
      return i - 1 >> 1;
    }
    return (i >> 1) - 1;
  }

  //Bubble element i down the heap
  function heapDown(i) {
    var w = heapWeight(i);
    while (true) {
      var tw = w;
      var left = 2 * i + 1;
      var right = 2 * (i + 1);
      var next = i;
      if (left < heapCount) {
        var lw = heapWeight(left);
        if (lw < tw) {
          next = left;
          tw = lw;
        }
      }
      if (right < heapCount) {
        var rw = heapWeight(right);
        if (rw < tw) {
          next = right;
        }
      }
      if (next === i) {
        return i;
      }
      heapSwap(i, next);
      i = next;
    }
  }

  //Bubbles element i up the heap
  function heapUp(i) {
    var w = heapWeight(i);
    while (i > 0) {
      var parent = heapParent(i);
      if (parent >= 0) {
        var pw = heapWeight(parent);
        if (w < pw) {
          heapSwap(i, parent);
          i = parent;
          continue;
        }
      }
      return i;
    }
  }

  //Pop minimum element
  function heapPop() {
    if (heapCount > 0) {
      var head = heap[0];
      heapSwap(0, heapCount - 1);
      heapCount -= 1;
      heapDown(0);
      return head;
    }
    return -1;
  }

  //Update heap item i
  function heapUpdate(i, w) {
    var a = heap[i];
    if (weights[a] === w) {
      return i;
    }
    weights[a] = -Infinity;
    heapUp(i);
    heapPop();
    weights[a] = w;
    heapCount += 1;
    return heapUp(heapCount - 1);
  }

  //Kills a vertex (assume vertex already removed from heap)
  function kill(i) {
    if (dead[i]) {
      return;
    }
    //Kill vertex
    dead[i] = true;
    //Fixup topology
    var s = inv[i];
    var t = outv[i];
    if (inv[t] >= 0) {
      inv[t] = s;
    }
    if (outv[s] >= 0) {
      outv[s] = t;
    }

    //Update weights on s and t
    if (index[s] >= 0) {
      heapUpdate(index[s], computeWeight(s));
    }
    if (index[t] >= 0) {
      heapUpdate(index[t], computeWeight(t));
    }
  }

  //Initialize weights and heap
  var heap = [];
  var index = new Array(n);
  for (var i = 0; i < n; ++i) {
    var w = weights[i] = computeWeight(i);
    if (w < Infinity) {
      index[i] = heap.length;
      heap.push(i);
    } else {
      index[i] = -1;
    }
  }
  var heapCount = heap.length;
  for (var i = heapCount >> 1; i >= 0; --i) {
    heapDown(i);
  }

  //Kill vertices
  while (true) {
    var hmin = heapPop();
    if (hmin < 0 || weights[hmin] > minArea) {
      break;
    }
    kill(hmin);
  }

  //Build collapsed vertex table
  var npositions = [];
  for (var i = 0; i < n; ++i) {
    if (!dead[i]) {
      index[i] = npositions.length;
      npositions.push(positions[i].slice());
    }
  }
  var nv = npositions.length;

  function tortoiseHare(seq, start) {
    if (seq[start] < 0) {
      return start;
    }
    var t = start;
    var h = start;
    do {
      //Walk two steps with h
      var nh = seq[h];
      if (!dead[h] || nh < 0 || nh === h) {
        break;
      }
      h = nh;
      nh = seq[h];
      if (!dead[h] || nh < 0 || nh === h) {
        break;
      }
      h = nh;

      //Walk one step with t
      t = seq[t];
    } while (t !== h);
    //Compress cycles
    for (var v = start; v !== h; v = seq[v]) {
      seq[v] = h;
    }
    return h;
  }

  var ncells = [];
  cells.forEach(function (c) {
    var tin = tortoiseHare(inv, c[0]);
    var tout = tortoiseHare(outv, c[1]);
    if (tin >= 0 && tout >= 0 && tin !== tout) {
      var cin = index[tin];
      var cout = index[tout];
      if (cin !== cout) {
        ncells.push([cin, cout]);
      }
    }
  }

  //Normalize result
  );sc.unique(sc.normalize(ncells)

  //Return final list of cells
  );return {
    positions: npositions,
    edges: ncells
  };
}

},{"robust-orientation":137,"simplicial-complex":145}],147:[function(require,module,exports){
"use strict";

module.exports = orderSegments;

var orient = require("robust-orientation");

function horizontalOrder(a, b) {
  var bl, br;
  if (b[0][0] < b[1][0]) {
    bl = b[0];
    br = b[1];
  } else if (b[0][0] > b[1][0]) {
    bl = b[1];
    br = b[0];
  } else {
    var alo = Math.min(a[0][1], a[1][1]);
    var ahi = Math.max(a[0][1], a[1][1]);
    var blo = Math.min(b[0][1], b[1][1]);
    var bhi = Math.max(b[0][1], b[1][1]);
    if (ahi < blo) {
      return ahi - blo;
    }
    if (alo > bhi) {
      return alo - bhi;
    }
    return ahi - bhi;
  }
  var al, ar;
  if (a[0][1] < a[1][1]) {
    al = a[0];
    ar = a[1];
  } else {
    al = a[1];
    ar = a[0];
  }
  var d = orient(br, bl, al);
  if (d) {
    return d;
  }
  d = orient(br, bl, ar);
  if (d) {
    return d;
  }
  return ar - br;
}

function orderSegments(b, a) {
  var al, ar;
  if (a[0][0] < a[1][0]) {
    al = a[0];
    ar = a[1];
  } else if (a[0][0] > a[1][0]) {
    al = a[1];
    ar = a[0];
  } else {
    return horizontalOrder(a, b);
  }
  var bl, br;
  if (b[0][0] < b[1][0]) {
    bl = b[0];
    br = b[1];
  } else if (b[0][0] > b[1][0]) {
    bl = b[1];
    br = b[0];
  } else {
    return -horizontalOrder(b, a);
  }
  var d1 = orient(al, ar, br);
  var d2 = orient(al, ar, bl);
  if (d1 < 0) {
    if (d2 <= 0) {
      return d1;
    }
  } else if (d1 > 0) {
    if (d2 >= 0) {
      return d1;
    }
  } else if (d2) {
    return d2;
  }
  d1 = orient(br, bl, ar);
  d2 = orient(br, bl, al);
  if (d1 < 0) {
    if (d2 <= 0) {
      return d1;
    }
  } else if (d1 > 0) {
    if (d2 >= 0) {
      return d1;
    }
  } else if (d2) {
    return d2;
  }
  return ar[0] - br[0];
}

},{"robust-orientation":137}],148:[function(require,module,exports){
arguments[4][104][0].apply(exports,arguments)
},{"dup":104}],149:[function(require,module,exports){
"use strict";

module.exports = createSlabDecomposition;

var bounds = require("binary-search-bounds");
var createRBTree = require("functional-red-black-tree");
var orient = require("robust-orientation");
var orderSegments = require("./lib/order-segments");

function SlabDecomposition(slabs, coordinates, horizontal) {
  this.slabs = slabs;
  this.coordinates = coordinates;
  this.horizontal = horizontal;
}

var proto = SlabDecomposition.prototype;

function compareHorizontal(e, y) {
  return e.y - y;
}

function searchBucket(root, p) {
  var lastNode = null;
  while (root) {
    var seg = root.key;
    var l, r;
    if (seg[0][0] < seg[1][0]) {
      l = seg[0];
      r = seg[1];
    } else {
      l = seg[1];
      r = seg[0];
    }
    var o = orient(l, r, p);
    if (o < 0) {
      root = root.left;
    } else if (o > 0) {
      if (p[0] !== seg[1][0]) {
        lastNode = root;
        root = root.right;
      } else {
        var val = searchBucket(root.right, p);
        if (val) {
          return val;
        }
        root = root.left;
      }
    } else {
      if (p[0] !== seg[1][0]) {
        return root;
      } else {
        var val = searchBucket(root.right, p);
        if (val) {
          return val;
        }
        root = root.left;
      }
    }
  }
  return lastNode;
}

proto.castUp = function (p) {
  var bucket = bounds.le(this.coordinates, p[0]);
  if (bucket < 0) {
    return -1;
  }
  var root = this.slabs[bucket];
  var hitNode = searchBucket(this.slabs[bucket], p);
  var lastHit = -1;
  if (hitNode) {
    lastHit = hitNode.value;
  }
  //Edge case: need to handle horizontal segments (sucks)
  if (this.coordinates[bucket] === p[0]) {
    var lastSegment = null;
    if (hitNode) {
      lastSegment = hitNode.key;
    }
    if (bucket > 0) {
      var otherHitNode = searchBucket(this.slabs[bucket - 1], p);
      if (otherHitNode) {
        if (lastSegment) {
          if (orderSegments(otherHitNode.key, lastSegment) > 0) {
            lastSegment = otherHitNode.key;
            lastHit = otherHitNode.value;
          }
        } else {
          lastHit = otherHitNode.value;
          lastSegment = otherHitNode.key;
        }
      }
    }
    var horiz = this.horizontal[bucket];
    if (horiz.length > 0) {
      var hbucket = bounds.ge(horiz, p[1], compareHorizontal);
      if (hbucket < horiz.length) {
        var e = horiz[hbucket];
        if (p[1] === e.y) {
          if (e.closed) {
            return e.index;
          } else {
            while (hbucket < horiz.length - 1 && horiz[hbucket + 1].y === p[1]) {
              hbucket = hbucket + 1;
              e = horiz[hbucket];
              if (e.closed) {
                return e.index;
              }
            }
            if (e.y === p[1] && !e.start) {
              hbucket = hbucket + 1;
              if (hbucket >= horiz.length) {
                return lastHit;
              }
              e = horiz[hbucket];
            }
          }
        }
        //Check if e is above/below last segment
        if (e.start) {
          if (lastSegment) {
            var o = orient(lastSegment[0], lastSegment[1], [p[0], e.y]);
            if (lastSegment[0][0] > lastSegment[1][0]) {
              o = -o;
            }
            if (o > 0) {
              lastHit = e.index;
            }
          } else {
            lastHit = e.index;
          }
        } else if (e.y !== p[1]) {
          lastHit = e.index;
        }
      }
    }
  }
  return lastHit;
};

function IntervalSegment(y, index, start, closed) {
  this.y = y;
  this.index = index;
  this.start = start;
  this.closed = closed;
}

function Event(x, segment, create, index) {
  this.x = x;
  this.segment = segment;
  this.create = create;
  this.index = index;
}

function createSlabDecomposition(segments) {
  var numSegments = segments.length;
  var numEvents = 2 * numSegments;
  var events = new Array(numEvents);
  for (var i = 0; i < numSegments; ++i) {
    var s = segments[i];
    var f = s[0][0] < s[1][0];
    events[2 * i] = new Event(s[0][0], s, f, i);
    events[2 * i + 1] = new Event(s[1][0], s, !f, i);
  }
  events.sort(function (a, b) {
    var d = a.x - b.x;
    if (d) {
      return d;
    }
    d = a.create - b.create;
    if (d) {
      return d;
    }
    return Math.min(a.segment[0][1], a.segment[1][1]) - Math.min(b.segment[0][1], b.segment[1][1]);
  });
  var tree = createRBTree(orderSegments);
  var slabs = [];
  var lines = [];
  var horizontal = [];
  var lastX = -Infinity;
  for (var i = 0; i < numEvents;) {
    var x = events[i].x;
    var horiz = [];
    while (i < numEvents) {
      var e = events[i];
      if (e.x !== x) {
        break;
      }
      i += 1;
      if (e.segment[0][0] === e.x && e.segment[1][0] === e.x) {
        if (e.create) {
          if (e.segment[0][1] < e.segment[1][1]) {
            horiz.push(new IntervalSegment(e.segment[0][1], e.index, true, true));
            horiz.push(new IntervalSegment(e.segment[1][1], e.index, false, false));
          } else {
            horiz.push(new IntervalSegment(e.segment[1][1], e.index, true, false));
            horiz.push(new IntervalSegment(e.segment[0][1], e.index, false, true));
          }
        }
      } else {
        if (e.create) {
          tree = tree.insert(e.segment, e.index);
        } else {
          tree = tree.remove(e.segment);
        }
      }
    }
    slabs.push(tree.root);
    lines.push(x);
    horizontal.push(horiz);
  }
  return new SlabDecomposition(slabs, lines, horizontal);
}

},{"./lib/order-segments":147,"binary-search-bounds":148,"functional-red-black-tree":66,"robust-orientation":137}],150:[function(require,module,exports){
'use strict';

module.exports = sortLevels;

var INSERT_SORT_CUTOFF = 32;

function sortLevels(data_levels, data_points, data_ids, data_weights, n0) {
  if (n0 <= 4 * INSERT_SORT_CUTOFF) {
    insertionSort(0, n0 - 1, data_levels, data_points, data_ids, data_weights);
  } else {
    quickSort(0, n0 - 1, data_levels, data_points, data_ids, data_weights);
  }
}

function insertionSort(left, right, data_levels, data_points, data_ids, data_weights) {
  for (var i = left + 1; i <= right; ++i) {
    var a_level = data_levels[i];
    var a_x = data_points[2 * i];
    var a_y = data_points[2 * i + 1];
    var a_id = data_ids[i];
    var a_weight = data_weights[i];

    var j = i;
    while (j > left) {
      var b_level = data_levels[j - 1];
      var b_x = data_points[2 * (j - 1)];
      if ((b_level - a_level || a_x - b_x) >= 0) {
        break;
      }
      data_levels[j] = b_level;
      data_points[2 * j] = b_x;
      data_points[2 * j + 1] = data_points[2 * j - 1];
      data_ids[j] = data_ids[j - 1];
      data_weights[j] = data_weights[j - 1];
      j -= 1;
    }

    data_levels[j] = a_level;
    data_points[2 * j] = a_x;
    data_points[2 * j + 1] = a_y;
    data_ids[j] = a_id;
    data_weights[j] = a_weight;
  }
}

function swap(i, j, data_levels, data_points, data_ids, data_weights) {
  var a_level = data_levels[i];
  var a_x = data_points[2 * i];
  var a_y = data_points[2 * i + 1];
  var a_id = data_ids[i];
  var a_weight = data_weights[i];

  data_levels[i] = data_levels[j];
  data_points[2 * i] = data_points[2 * j];
  data_points[2 * i + 1] = data_points[2 * j + 1];
  data_ids[i] = data_ids[j];
  data_weights[i] = data_weights[j];

  data_levels[j] = a_level;
  data_points[2 * j] = a_x;
  data_points[2 * j + 1] = a_y;
  data_ids[j] = a_id;
  data_weights[j] = a_weight;
}

function move(i, j, data_levels, data_points, data_ids, data_weights) {
  data_levels[i] = data_levels[j];
  data_points[2 * i] = data_points[2 * j];
  data_points[2 * i + 1] = data_points[2 * j + 1];
  data_ids[i] = data_ids[j];
  data_weights[i] = data_weights[j];
}

function rotate(i, j, k, data_levels, data_points, data_ids, data_weights) {
  var a_level = data_levels[i];
  var a_x = data_points[2 * i];
  var a_y = data_points[2 * i + 1];
  var a_id = data_ids[i];
  var a_weight = data_weights[i];

  data_levels[i] = data_levels[j];
  data_points[2 * i] = data_points[2 * j];
  data_points[2 * i + 1] = data_points[2 * j + 1];
  data_ids[i] = data_ids[j];
  data_weights[i] = data_weights[j];

  data_levels[j] = data_levels[k];
  data_points[2 * j] = data_points[2 * k];
  data_points[2 * j + 1] = data_points[2 * k + 1];
  data_ids[j] = data_ids[k];
  data_weights[j] = data_weights[k];

  data_levels[k] = a_level;
  data_points[2 * k] = a_x;
  data_points[2 * k + 1] = a_y;
  data_ids[k] = a_id;
  data_weights[k] = a_weight;
}

function shufflePivot(i, j, a_level, a_x, a_y, a_id, a_weight, data_levels, data_points, data_ids, data_weights) {

  data_levels[i] = data_levels[j];
  data_points[2 * i] = data_points[2 * j];
  data_points[2 * i + 1] = data_points[2 * j + 1];
  data_ids[i] = data_ids[j];
  data_weights[i] = data_weights[j];

  data_levels[j] = a_level;
  data_points[2 * j] = a_x;
  data_points[2 * j + 1] = a_y;
  data_ids[j] = a_id;
  data_weights[j] = a_weight;
}

function compare(i, j, data_levels, data_points, data_ids) {
  return (data_levels[i] - data_levels[j] || data_points[2 * j] - data_points[2 * i] || data_ids[i] - data_ids[j]) < 0;
}

function comparePivot(i, level, x, y, id, data_levels, data_points, data_ids) {
  return (level - data_levels[i] || data_points[2 * i] - x || id - data_ids[i]) < 0;
}

function quickSort(left, right, data_levels, data_points, data_ids, data_weights) {
  var sixth = (right - left + 1) / 6 | 0,
      index1 = left + sixth,
      index5 = right - sixth,
      index3 = left + right >> 1,
      index2 = index3 - sixth,
      index4 = index3 + sixth,
      el1 = index1,
      el2 = index2,
      el3 = index3,
      el4 = index4,
      el5 = index5,
      less = left + 1,
      great = right - 1,
      tmp = 0;
  if (compare(el1, el2, data_levels, data_points, data_ids, data_weights)) {
    tmp = el1;
    el1 = el2;
    el2 = tmp;
  }
  if (compare(el4, el5, data_levels, data_points, data_ids, data_weights)) {
    tmp = el4;
    el4 = el5;
    el5 = tmp;
  }
  if (compare(el1, el3, data_levels, data_points, data_ids, data_weights)) {
    tmp = el1;
    el1 = el3;
    el3 = tmp;
  }
  if (compare(el2, el3, data_levels, data_points, data_ids, data_weights)) {
    tmp = el2;
    el2 = el3;
    el3 = tmp;
  }
  if (compare(el1, el4, data_levels, data_points, data_ids, data_weights)) {
    tmp = el1;
    el1 = el4;
    el4 = tmp;
  }
  if (compare(el3, el4, data_levels, data_points, data_ids, data_weights)) {
    tmp = el3;
    el3 = el4;
    el4 = tmp;
  }
  if (compare(el2, el5, data_levels, data_points, data_ids, data_weights)) {
    tmp = el2;
    el2 = el5;
    el5 = tmp;
  }
  if (compare(el2, el3, data_levels, data_points, data_ids, data_weights)) {
    tmp = el2;
    el2 = el3;
    el3 = tmp;
  }
  if (compare(el4, el5, data_levels, data_points, data_ids, data_weights)) {
    tmp = el4;
    el4 = el5;
    el5 = tmp;
  }

  var pivot1_level = data_levels[el2];
  var pivot1_x = data_points[2 * el2];
  var pivot1_y = data_points[2 * el2 + 1];
  var pivot1_id = data_ids[el2];
  var pivot1_weight = data_weights[el2];

  var pivot2_level = data_levels[el4];
  var pivot2_x = data_points[2 * el4];
  var pivot2_y = data_points[2 * el4 + 1];
  var pivot2_id = data_ids[el4];
  var pivot2_weight = data_weights[el4];

  var ptr0 = el1;
  var ptr2 = el3;
  var ptr4 = el5;
  var ptr5 = index1;
  var ptr6 = index3;
  var ptr7 = index5;

  var level_x = data_levels[ptr0];
  var level_y = data_levels[ptr2];
  var level_z = data_levels[ptr4];
  data_levels[ptr5] = level_x;
  data_levels[ptr6] = level_y;
  data_levels[ptr7] = level_z;

  for (var i1 = 0; i1 < 2; ++i1) {
    var x = data_points[2 * ptr0 + i1];
    var y = data_points[2 * ptr2 + i1];
    var z = data_points[2 * ptr4 + i1];
    data_points[2 * ptr5 + i1] = x;
    data_points[2 * ptr6 + i1] = y;
    data_points[2 * ptr7 + i1] = z;
  }

  var id_x = data_ids[ptr0];
  var id_y = data_ids[ptr2];
  var id_z = data_ids[ptr4];
  data_ids[ptr5] = id_x;
  data_ids[ptr6] = id_y;
  data_ids[ptr7] = id_z;

  var weight_x = data_weights[ptr0];
  var weight_y = data_weights[ptr2];
  var weight_z = data_weights[ptr4];
  data_weights[ptr5] = weight_x;
  data_weights[ptr6] = weight_y;
  data_weights[ptr7] = weight_z;

  move(index2, left, data_levels, data_points, data_ids, data_weights);
  move(index4, right, data_levels, data_points, data_ids, data_weights);
  for (var k = less; k <= great; ++k) {
    if (comparePivot(k, pivot1_level, pivot1_x, pivot1_y, pivot1_id, data_levels, data_points, data_ids)) {
      if (k !== less) {
        swap(k, less, data_levels, data_points, data_ids, data_weights);
      }
      ++less;
    } else {
      if (!comparePivot(k, pivot2_level, pivot2_x, pivot2_y, pivot2_id, data_levels, data_points, data_ids)) {
        while (true) {
          if (!comparePivot(great, pivot2_level, pivot2_x, pivot2_y, pivot2_id, data_levels, data_points, data_ids)) {
            if (--great < k) {
              break;
            }
            continue;
          } else {
            if (comparePivot(great, pivot1_level, pivot1_x, pivot1_y, pivot1_id, data_levels, data_points, data_ids)) {
              rotate(k, less, great, data_levels, data_points, data_ids, data_weights);
              ++less;
              --great;
            } else {
              swap(k, great, data_levels, data_points, data_ids, data_weights);
              --great;
            }
            break;
          }
        }
      }
    }
  }
  shufflePivot(left, less - 1, pivot1_level, pivot1_x, pivot1_y, pivot1_id, pivot1_weight, data_levels, data_points, data_ids, data_weights);
  shufflePivot(right, great + 1, pivot2_level, pivot2_x, pivot2_y, pivot2_id, pivot2_weight, data_levels, data_points, data_ids, data_weights);
  if (less - 2 - left <= INSERT_SORT_CUTOFF) {
    insertionSort(left, less - 2, data_levels, data_points, data_ids, data_weights);
  } else {
    quickSort(left, less - 2, data_levels, data_points, data_ids, data_weights);
  }
  if (right - (great + 2) <= INSERT_SORT_CUTOFF) {
    insertionSort(great + 2, right, data_levels, data_points, data_ids, data_weights);
  } else {
    quickSort(great + 2, right, data_levels, data_points, data_ids, data_weights);
  }
  if (great - less <= INSERT_SORT_CUTOFF) {
    insertionSort(less, great, data_levels, data_points, data_ids, data_weights);
  } else {
    quickSort(less, great, data_levels, data_points, data_ids, data_weights);
  }
}

},{}],151:[function(require,module,exports){
'use strict';

var pool = require('typedarray-pool');

var sortLevels = require('./lib/sort');

module.exports = snapPoints;

function partition(points, ids, start, end, lox, loy, hix, hiy) {
  var mid = start;
  for (var i = start; i < end; ++i) {
    var x = points[2 * i];
    var y = points[2 * i + 1];
    var s = ids[i];
    if (lox <= x && x <= hix && loy <= y && y <= hiy) {
      if (i === mid) {
        mid += 1;
      } else {
        points[2 * i] = points[2 * mid];
        points[2 * i + 1] = points[2 * mid + 1];
        ids[i] = ids[mid];
        points[2 * mid] = x;
        points[2 * mid + 1] = y;
        ids[mid] = s;
        mid += 1;
      }
    }
  }
  return mid;
}

function SnapInterval(pixelSize, offset, count) {
  this.pixelSize = pixelSize;
  this.offset = offset;
  this.count = count;
}

function snapPoints(points, ids, weights, bounds) {
  var n = points.length >>> 1;
  if (n < 1) {
    return [];
  }

  var lox = Infinity,
      loy = Infinity;
  var hix = -Infinity,
      hiy = -Infinity;
  for (var i = 0; i < n; ++i) {
    var x = points[2 * i];
    var y = points[2 * i + 1];
    lox = Math.min(lox, x);
    hix = Math.max(hix, x);
    loy = Math.min(loy, y);
    hiy = Math.max(hiy, y);
    ids[i] = i;
  }

  if (lox === hix) {
    hix += 1 + Math.abs(hix);
  }
  if (loy === hiy) {
    hiy += 1 + Math.abs(hix);
  }

  //Calculate diameter
  var scaleX = 1.0 / (hix - lox);
  var scaleY = 1.0 / (hiy - loy);
  var diam = Math.max(hix - lox, hiy - loy);

  bounds = bounds || [0, 0, 0, 0];

  bounds[0] = lox;
  bounds[1] = loy;
  bounds[2] = hix;
  bounds[3] = hiy;

  var levels = pool.mallocInt32(n);
  var ptr = 0;

  function snapRec(x, y, diam, start, end, level) {
    var diam_2 = diam * 0.5;
    var offset = start + 1;
    var count = end - start;
    weights[ptr] = count;
    levels[ptr++] = level;
    for (var i = 0; i < 2; ++i) {
      for (var j = 0; j < 2; ++j) {
        var nx = x + i * diam_2;
        var ny = y + j * diam_2;
        var nextOffset = partition(points, ids, offset, end, nx, ny, nx + diam_2, ny + diam_2);
        if (nextOffset === offset) {
          continue;
        }
        if (nextOffset - offset >= Math.max(0.9 * count, 32)) {
          var mid = end + start >>> 1;
          snapRec(nx, ny, diam_2, offset, mid, level + 1);
          offset = mid;
        }
        snapRec(nx, ny, diam_2, offset, nextOffset, level + 1);
        offset = nextOffset;
      }
    }
  }
  snapRec(lox, loy, diam, 0, n, 0);
  sortLevels(levels, points, ids, weights, n);

  var lod = [];
  var lastLevel = 0;
  var prevOffset = n;
  for (var ptr = n - 1; ptr >= 0; --ptr) {
    points[2 * ptr] = (points[2 * ptr] - lox) * scaleX;
    points[2 * ptr + 1] = (points[2 * ptr + 1] - loy) * scaleY;

    var level = levels[ptr];
    if (level === lastLevel) {
      continue;
    }

    lod.push(new SnapInterval(diam * Math.pow(0.5, level), ptr + 1, prevOffset - (ptr + 1)));
    prevOffset = ptr + 1;

    lastLevel = level;
  }

  lod.push(new SnapInterval(diam * Math.pow(0.5, level + 1), 0, prevOffset));
  pool.free(levels);

  return lod;
}

},{"./lib/sort":150,"typedarray-pool":162}],152:[function(require,module,exports){
/* global window, exports, define */

!function () {
    'use strict';

    var re = {
        not_string: /[^s]/,
        not_bool: /[^t]/,
        not_type: /[^T]/,
        not_primitive: /[^v]/,
        number: /[diefg]/,
        numeric_arg: /[bcdiefguxX]/,
        json: /[j]/,
        not_json: /[^j]/,
        text: /^[^\x25]+/,
        modulo: /^\x25{2}/,
        placeholder: /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,
        key: /^([a-z_][a-z_\d]*)/i,
        key_access: /^\.([a-z_][a-z_\d]*)/i,
        index_access: /^\[(\d+)\]/,
        sign: /^[\+\-]/
    };

    function sprintf(key) {
        // `arguments` is not an array, but should be fine for this call
        return sprintf_format(sprintf_parse(key), arguments);
    }

    function vsprintf(fmt, argv) {
        return sprintf.apply(null, [fmt].concat(argv || []));
    }

    function sprintf_format(parse_tree, argv) {
        var cursor = 1,
            tree_length = parse_tree.length,
            arg,
            output = '',
            i,
            k,
            match,
            pad,
            pad_character,
            pad_length,
            is_positive,
            sign;
        for (i = 0; i < tree_length; i++) {
            if (typeof parse_tree[i] === 'string') {
                output += parse_tree[i];
            } else if (Array.isArray(parse_tree[i])) {
                match = parse_tree[i]; // convenience purposes only
                if (match[2]) {
                    // keyword argument
                    arg = argv[cursor];
                    for (k = 0; k < match[2].length; k++) {
                        if (!arg.hasOwnProperty(match[2][k])) {
                            throw new Error(sprintf('[sprintf] property "%s" does not exist', match[2][k]));
                        }
                        arg = arg[match[2][k]];
                    }
                } else if (match[1]) {
                    // positional argument (explicit)
                    arg = argv[match[1]];
                } else {
                    // positional argument (implicit)
                    arg = argv[cursor++];
                }

                if (re.not_type.test(match[8]) && re.not_primitive.test(match[8]) && arg instanceof Function) {
                    arg = arg();
                }

                if (re.numeric_arg.test(match[8]) && typeof arg !== 'number' && isNaN(arg)) {
                    throw new TypeError(sprintf('[sprintf] expecting number but found %T', arg));
                }

                if (re.number.test(match[8])) {
                    is_positive = arg >= 0;
                }

                switch (match[8]) {
                    case 'b':
                        arg = parseInt(arg, 10).toString(2);
                        break;
                    case 'c':
                        arg = String.fromCharCode(parseInt(arg, 10));
                        break;
                    case 'd':
                    case 'i':
                        arg = parseInt(arg, 10);
                        break;
                    case 'j':
                        arg = JSON.stringify(arg, null, match[6] ? parseInt(match[6]) : 0);
                        break;
                    case 'e':
                        arg = match[7] ? parseFloat(arg).toExponential(match[7]) : parseFloat(arg).toExponential();
                        break;
                    case 'f':
                        arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg);
                        break;
                    case 'g':
                        arg = match[7] ? String(Number(arg.toPrecision(match[7]))) : parseFloat(arg);
                        break;
                    case 'o':
                        arg = (parseInt(arg, 10) >>> 0).toString(8);
                        break;
                    case 's':
                        arg = String(arg);
                        arg = match[7] ? arg.substring(0, match[7]) : arg;
                        break;
                    case 't':
                        arg = String(!!arg);
                        arg = match[7] ? arg.substring(0, match[7]) : arg;
                        break;
                    case 'T':
                        arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase();
                        arg = match[7] ? arg.substring(0, match[7]) : arg;
                        break;
                    case 'u':
                        arg = parseInt(arg, 10) >>> 0;
                        break;
                    case 'v':
                        arg = arg.valueOf();
                        arg = match[7] ? arg.substring(0, match[7]) : arg;
                        break;
                    case 'x':
                        arg = (parseInt(arg, 10) >>> 0).toString(16);
                        break;
                    case 'X':
                        arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase();
                        break;
                }
                if (re.json.test(match[8])) {
                    output += arg;
                } else {
                    if (re.number.test(match[8]) && (!is_positive || match[3])) {
                        sign = is_positive ? '+' : '-';
                        arg = arg.toString().replace(re.sign, '');
                    } else {
                        sign = '';
                    }
                    pad_character = match[4] ? match[4] === '0' ? '0' : match[4].charAt(1) : ' ';
                    pad_length = match[6] - (sign + arg).length;
                    pad = match[6] ? pad_length > 0 ? pad_character.repeat(pad_length) : '' : '';
                    output += match[5] ? sign + arg + pad : pad_character === '0' ? sign + pad + arg : pad + sign + arg;
                }
            }
        }
        return output;
    }

    var sprintf_cache = Object.create(null);

    function sprintf_parse(fmt) {
        if (sprintf_cache[fmt]) {
            return sprintf_cache[fmt];
        }

        var _fmt = fmt,
            match,
            parse_tree = [],
            arg_names = 0;
        while (_fmt) {
            if ((match = re.text.exec(_fmt)) !== null) {
                parse_tree.push(match[0]);
            } else if ((match = re.modulo.exec(_fmt)) !== null) {
                parse_tree.push('%');
            } else if ((match = re.placeholder.exec(_fmt)) !== null) {
                if (match[2]) {
                    arg_names |= 1;
                    var field_list = [],
                        replacement_field = match[2],
                        field_match = [];
                    if ((field_match = re.key.exec(replacement_field)) !== null) {
                        field_list.push(field_match[1]);
                        while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
                            if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                                field_list.push(field_match[1]);
                            } else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                                field_list.push(field_match[1]);
                            } else {
                                throw new SyntaxError('[sprintf] failed to parse named argument key');
                            }
                        }
                    } else {
                        throw new SyntaxError('[sprintf] failed to parse named argument key');
                    }
                    match[2] = field_list;
                } else {
                    arg_names |= 2;
                }
                if (arg_names === 3) {
                    throw new Error('[sprintf] mixing positional and named placeholders is not (yet) supported');
                }
                parse_tree.push(match);
            } else {
                throw new SyntaxError('[sprintf] unexpected placeholder');
            }
            _fmt = _fmt.substring(match[0].length);
        }
        return sprintf_cache[fmt] = parse_tree;
    }

    /**
     * export to either browser or node.js
     */
    /* eslint-disable quote-props */
    if (typeof exports !== 'undefined') {
        exports['sprintf'] = sprintf;
        exports['vsprintf'] = vsprintf;
    }
    if (typeof window !== 'undefined') {
        window['sprintf'] = sprintf;
        window['vsprintf'] = vsprintf;

        if (typeof define === 'function' && define['amd']) {
            define(function () {
                return {
                    'sprintf': sprintf,
                    'vsprintf': vsprintf
                };
            });
        }
    }
    /* eslint-enable quote-props */
}();

},{}],153:[function(require,module,exports){
"use strict";

module.exports = surfaceNets;

var generateContourExtractor = require("ndarray-extract-contour");
var triangulateCube = require("triangulate-hypercube");
var zeroCrossings = require("zero-crossings");

function buildSurfaceNets(order, dtype) {
  var dimension = order.length;
  var code = ["'use strict';"];
  var funcName = "surfaceNets" + order.join("_") + "d" + dtype;

  //Contour extraction function
  code.push("var contour=genContour({", "order:[", order.join(), "],", "scalarArguments: 3,", "phase:function phaseFunc(p,a,b,c) { return (p > c)|0 },");
  if (dtype === "generic") {
    code.push("getters:[0],");
  }

  //Generate vertex function
  var cubeArgs = [];
  var extraArgs = [];
  for (var i = 0; i < dimension; ++i) {
    cubeArgs.push("d" + i);
    extraArgs.push("d" + i);
  }
  for (var i = 0; i < 1 << dimension; ++i) {
    cubeArgs.push("v" + i);
    extraArgs.push("v" + i);
  }
  for (var i = 0; i < 1 << dimension; ++i) {
    cubeArgs.push("p" + i);
    extraArgs.push("p" + i);
  }
  cubeArgs.push("a", "b", "c");
  extraArgs.push("a", "c");
  code.push("vertex:function vertexFunc(", cubeArgs.join(), "){"
  //Mask args together
  );var maskStr = [];
  for (var i = 0; i < 1 << dimension; ++i) {
    maskStr.push("(p" + i + "<<" + i + ")");
  }
  //Generate variables and giganto switch statement
  code.push("var m=(", maskStr.join("+"), ")|0;if(m===0||m===", (1 << (1 << dimension)) - 1, "){return}");
  var extraFuncs = [];
  var currentFunc = [];
  if (1 << (1 << dimension) <= 128) {
    code.push("switch(m){");
    currentFunc = code;
  } else {
    code.push("switch(m>>>7){");
  }
  for (var i = 0; i < 1 << (1 << dimension); ++i) {
    if (1 << (1 << dimension) > 128) {
      if (i % 128 === 0) {
        if (extraFuncs.length > 0) {
          currentFunc.push("}}");
        }
        var efName = "vExtra" + extraFuncs.length;
        code.push("case ", i >>> 7, ":", efName, "(m&0x7f,", extraArgs.join(), ");break;");
        currentFunc = ["function ", efName, "(m,", extraArgs.join(), "){switch(m){"];
        extraFuncs.push(currentFunc);
      }
    }
    currentFunc.push("case ", i & 0x7f, ":");
    var crossings = new Array(dimension);
    var denoms = new Array(dimension);
    var crossingCount = new Array(dimension);
    var bias = new Array(dimension);
    var totalCrossings = 0;
    for (var j = 0; j < dimension; ++j) {
      crossings[j] = [];
      denoms[j] = [];
      crossingCount[j] = 0;
      bias[j] = 0;
    }
    for (var j = 0; j < 1 << dimension; ++j) {
      for (var k = 0; k < dimension; ++k) {
        var u = j ^ 1 << k;
        if (u > j) {
          continue;
        }
        if (!(i & 1 << u) !== !(i & 1 << j)) {
          var sign = 1;
          if (i & 1 << u) {
            denoms[k].push("v" + u + "-v" + j);
          } else {
            denoms[k].push("v" + j + "-v" + u);
            sign = -sign;
          }
          if (sign < 0) {
            crossings[k].push("-v" + j + "-v" + u);
            crossingCount[k] += 2;
          } else {
            crossings[k].push("v" + j + "+v" + u);
            crossingCount[k] -= 2;
          }
          totalCrossings += 1;
          for (var l = 0; l < dimension; ++l) {
            if (l === k) {
              continue;
            }
            if (u & 1 << l) {
              bias[l] += 1;
            } else {
              bias[l] -= 1;
            }
          }
        }
      }
    }
    var vertexStr = [];
    for (var k = 0; k < dimension; ++k) {
      if (crossings[k].length === 0) {
        vertexStr.push("d" + k + "-0.5");
      } else {
        var cStr = "";
        if (crossingCount[k] < 0) {
          cStr = crossingCount[k] + "*c";
        } else if (crossingCount[k] > 0) {
          cStr = "+" + crossingCount[k] + "*c";
        }
        var weight = 0.5 * (crossings[k].length / totalCrossings);
        var shift = 0.5 + 0.5 * (bias[k] / totalCrossings);
        vertexStr.push("d" + k + "-" + shift + "-" + weight + "*(" + crossings[k].join("+") + cStr + ")/(" + denoms[k].join("+") + ")");
      }
    }
    currentFunc.push("a.push([", vertexStr.join(), "]);", "break;");
  }
  code.push("}},");
  if (extraFuncs.length > 0) {
    currentFunc.push("}}");
  }

  //Create face function
  var faceArgs = [];
  for (var i = 0; i < 1 << dimension - 1; ++i) {
    faceArgs.push("v" + i);
  }
  faceArgs.push("c0", "c1", "p0", "p1", "a", "b", "c");
  code.push("cell:function cellFunc(", faceArgs.join(), "){");

  var facets = triangulateCube(dimension - 1);
  code.push("if(p0){b.push(", facets.map(function (f) {
    return "[" + f.map(function (v) {
      return "v" + v;
    }) + "]";
  }).join(), ")}else{b.push(", facets.map(function (f) {
    var e = f.slice();
    e.reverse();
    return "[" + e.map(function (v) {
      return "v" + v;
    }) + "]";
  }).join(), ")}}});function ", funcName, "(array,level){var verts=[],cells=[];contour(array,verts,cells,level);return {positions:verts,cells:cells};} return ", funcName, ";");

  for (var i = 0; i < extraFuncs.length; ++i) {
    code.push(extraFuncs[i].join(""));
  }

  //Compile and link
  var proc = new Function("genContour", code.join(""));
  return proc(generateContourExtractor);
}

//1D case: Need to handle specially
function mesh1D(array, level) {
  var zc = zeroCrossings(array, level);
  var n = zc.length;
  var npos = new Array(n);
  var ncel = new Array(n);
  for (var i = 0; i < n; ++i) {
    npos[i] = [zc[i]];
    ncel[i] = [i];
  }
  return {
    positions: npos,
    cells: ncel
  };
}

var CACHE = {};

function surfaceNets(array, level) {
  if (array.dimension <= 0) {
    return { positions: [], cells: [] };
  } else if (array.dimension === 1) {
    return mesh1D(array, level);
  }
  var typesig = array.order.join() + "-" + array.dtype;
  var proc = CACHE[typesig];
  var level = +level || 0.0;
  if (!proc) {
    proc = CACHE[typesig] = buildSurfaceNets(array.order, array.dtype);
  }
  return proc(array, level);
}

},{"ndarray-extract-contour":112,"triangulate-hypercube":158,"zero-crossings":171}],154:[function(require,module,exports){
(function (process){
'use strict';

module.exports = textGet;

var vectorizeText = require('vectorize-text');

var globals = window || process.global || {};
var __TEXT_CACHE = globals.__TEXT_CACHE || {};
globals.__TEXT_CACHE = {};

function unwrap(mesh) {
  var cells = mesh.cells;
  var positions = mesh.positions;
  var data = new Float32Array(cells.length * 6);
  var ptr = 0;
  var shapeX = 0;
  for (var i = 0; i < cells.length; ++i) {
    var tri = cells[i];
    for (var j = 0; j < 3; ++j) {
      var point = positions[tri[j]];
      data[ptr++] = point[0];
      data[ptr++] = point[1] + 1.4;
      shapeX = Math.max(point[0], shapeX);
    }
  }
  return {
    data: data,
    shape: shapeX
  };
}

function textGet(font, text, opts) {
  var opts = opts || {};
  var fontcache = __TEXT_CACHE[font];
  if (!fontcache) {
    fontcache = __TEXT_CACHE[font] = {
      ' ': {
        data: new Float32Array(0),
        shape: 0.2
      }
    };
  }
  var mesh = fontcache[text];
  if (!mesh) {
    if (text.length <= 1 || !/\d/.test(text)) {
      mesh = fontcache[text] = unwrap(vectorizeText(text, {
        triangles: true,
        font: font,
        textAlign: opts.textAlign || 'left',
        textBaseline: 'alphabetic'
      }));
    } else {
      var parts = text.split(/(\d|\s)/);
      var buffer = new Array(parts.length);
      var bufferSize = 0;
      var shapeX = 0;
      for (var i = 0; i < parts.length; ++i) {
        buffer[i] = textGet(font, parts[i]);
        bufferSize += buffer[i].data.length;
        shapeX += buffer[i].shape;
        if (i > 0) {
          shapeX += 0.02;
        }
      }

      var data = new Float32Array(bufferSize);
      var ptr = 0;
      var xOffset = -0.5 * shapeX;
      for (var i = 0; i < buffer.length; ++i) {
        var bdata = buffer[i].data;
        for (var j = 0; j < bdata.length; j += 2) {
          data[ptr++] = bdata[j] + xOffset;
          data[ptr++] = bdata[j + 1];
        }
        xOffset += buffer[i].shape + 0.02;
      }

      mesh = fontcache[text] = {
        data: data,
        shape: shapeX
      };
    }
  }

  return mesh;
}

}).call(this,require('_process'))
},{"_process":127,"vectorize-text":165}],155:[function(require,module,exports){
'use strict';

module.exports = TinySDF;

var INF = 1e20;

function TinySDF(fontSize, buffer, radius, cutoff, fontFamily) {
    this.fontSize = fontSize || 24;
    this.buffer = buffer === undefined ? 3 : buffer;
    this.cutoff = cutoff || 0.25;
    this.fontFamily = fontFamily || 'sans-serif';
    this.radius = radius || 8;
    var size = this.size = this.fontSize + this.buffer * 2;

    this.canvas = document.createElement('canvas');
    this.canvas.width = this.canvas.height = size;

    this.ctx = this.canvas.getContext('2d');
    this.ctx.font = fontSize + 'px ' + this.fontFamily;
    this.ctx.textBaseline = 'middle';
    this.ctx.fillStyle = 'black';

    // temporary arrays for the distance transform
    this.gridOuter = new Float64Array(size * size);
    this.gridInner = new Float64Array(size * size);
    this.f = new Float64Array(size);
    this.d = new Float64Array(size);
    this.z = new Float64Array(size + 1);
    this.v = new Int16Array(size);

    // hack around https://bugzilla.mozilla.org/show_bug.cgi?id=737852
    this.middle = Math.round(size / 2 * (navigator.userAgent.indexOf('Gecko/') >= 0 ? 1.2 : 1));
}

TinySDF.prototype.draw = function (char) {
    this.ctx.clearRect(0, 0, this.size, this.size);
    this.ctx.fillText(char, this.buffer, this.middle);

    var imgData = this.ctx.getImageData(0, 0, this.size, this.size);
    var data = imgData.data;

    for (var i = 0; i < this.size * this.size; i++) {
        var a = data[i * 4 + 3] / 255; // alpha value
        this.gridOuter[i] = a === 1 ? 0 : a === 0 ? INF : Math.pow(Math.max(0, 0.5 - a), 2);
        this.gridInner[i] = a === 1 ? INF : a === 0 ? 0 : Math.pow(Math.max(0, a - 0.5), 2);
    }

    edt(this.gridOuter, this.size, this.size, this.f, this.d, this.v, this.z);
    edt(this.gridInner, this.size, this.size, this.f, this.d, this.v, this.z);

    for (i = 0; i < this.size * this.size; i++) {
        var d = this.gridOuter[i] - this.gridInner[i];
        var c = Math.max(0, Math.min(255, Math.round(255 - 255 * (d / this.radius + this.cutoff))));
        data[4 * i + 0] = c;
        data[4 * i + 1] = c;
        data[4 * i + 2] = c;
        data[4 * i + 3] = 255;
    }

    return imgData;
};

// 2D Euclidean distance transform by Felzenszwalb & Huttenlocher https://cs.brown.edu/~pff/dt/
function edt(data, width, height, f, d, v, z) {
    for (var x = 0; x < width; x++) {
        for (var y = 0; y < height; y++) {
            f[y] = data[y * width + x];
        }
        edt1d(f, d, v, z, height);
        for (y = 0; y < height; y++) {
            data[y * width + x] = d[y];
        }
    }
    for (y = 0; y < height; y++) {
        for (x = 0; x < width; x++) {
            f[x] = data[y * width + x];
        }
        edt1d(f, d, v, z, width);
        for (x = 0; x < width; x++) {
            data[y * width + x] = Math.sqrt(d[x]);
        }
    }
}

// 1D squared distance transform
function edt1d(f, d, v, z, n) {
    v[0] = 0;
    z[0] = -INF;
    z[1] = +INF;

    for (var q = 1, k = 0; q < n; q++) {
        var s = (f[q] + q * q - (f[v[k]] + v[k] * v[k])) / (2 * q - 2 * v[k]);
        while (s <= z[k]) {
            k--;
            s = (f[q] + q * q - (f[v[k]] + v[k] * v[k])) / (2 * q - 2 * v[k]);
        }
        k++;
        v[k] = q;
        z[k] = s;
        z[k + 1] = +INF;
    }

    for (q = 0, k = 0; q < n; q++) {
        while (z[k + 1] < q) k++;
        d[q] = (q - v[k]) * (q - v[k]) + f[v[k]];
    }
}

},{}],156:[function(require,module,exports){
'use strict';

var repeatString = require('repeat-string');
var objectAssign = require('object-assign');
var arrify = require('arrify');

module.exports = function toCss(object, opts) {
	opts = objectAssign({
		indent: '',
		property: identity,
		value: identity,
		selector: identity
	}, opts);

	if (typeof opts.indent === 'number') {
		opts.indent = repeatString(' ', opts.indent);
	}

	function props(prop, val) {
		return arrify(prop).reduce(function (props, p) {
			return props.concat(opts.property(p, val));
		}, []);
	}

	function values(val, prop) {
		return arrify(val).reduce(function (vals, v) {
			return vals.concat(opts.value(v, prop));
		}, []);
	}

	function selectors(sel, value) {
		return arrify(sel).reduce(function (sels, s) {
			return sels.concat(opts.selector(s, value));
		}, []);
	}

	function _toCss(obj, level) {
		var str = '';
		Object.keys(obj).forEach(function (sel) {
			var value = obj[sel];
			if (isLastLevel(value)) {
				str += rule(props(sel, value), values(value, sel), opts.indent, level - 1);
				return;
			} else if (Array.isArray(value)) {
				value.forEach(function (val) {
					str += _toCss(nest(sel, val), level);
				});
				return;
			}
			selectors(sel, value).forEach(function (selector) {
				str += start(selector, opts.indent, level);
				Object.keys(value).forEach(function (prop) {
					var value = obj[sel][prop];
					if (oneMoreLevelExists(value)) {
						str += _toCss(nest(prop, value), level + 1);
					} else {
						str += rule(props(prop, value), values(value, prop), opts.indent, level);
					}
				});
				str += end(opts.indent, level);
			});
		});
		return str;
	}

	return arrify(object).map(function (o) {
		return _toCss(o, 0);
	}).join(lineEnd(opts.indent));
};

function nest(prop, val) {
	var tmp = {};
	tmp[prop] = val;
	return tmp;
}

function isLastLevel(val) {
	return typeof val === 'string' || Array.isArray(val) && val.length && typeof val[0] !== 'object';
}

function oneMoreLevelExists(val) {
	return typeof val === 'object' && !Array.isArray(val);
}

function identity(v) {
	return v;
}

function lineStart(indent, level) {
	return indent ? repeatString(indent, level) : '';
}

function space(indent) {
	return indent ? ' ' : '';
}

function lineEnd(indent) {
	return indent ? '\n' : '';
}

function start(sel, indent, level) {
	return lineStart(indent, level) + sel + space(indent) + '{' + lineEnd(indent);
}

function end(indent, level) {
	return lineStart(indent, level) + '}' + lineEnd(indent);
}

function rule(props, values, indent, level) {
	var linestart = lineStart(indent, level + 1);
	var lineend = lineEnd(indent);
	var s = space(indent);

	var str = '';

	for (var i = 0, propLength = props.length; i < propLength; i++) {
		for (var j = 0, valueLength = values.length; j < valueLength; j++) {
			str += linestart + props[i] + (isAtRule(props[i]) ? ' ' : ':') + s + values[j] + ';' + lineend;
		}
	}

	return str;
}

function isAtRule(prop) {
	return prop.indexOf('@') === 0;
}

},{"arrify":7,"object-assign":116,"repeat-string":134}],157:[function(require,module,exports){
'use strict';

var parseUnit = require('parse-unit');

module.exports = toPX;

var PIXELS_PER_INCH = 96;

function getPropertyInPX(element, prop) {
  var parts = parseUnit(getComputedStyle(element).getPropertyValue(prop));
  return parts[0] * toPX(parts[1], element);
}

//This brutal hack is needed
function getSizeBrutal(unit, element) {
  var testDIV = document.createElement('div');
  testDIV.style['font-size'] = '128' + unit;
  element.appendChild(testDIV);
  var size = getPropertyInPX(testDIV, 'font-size') / 128;
  element.removeChild(testDIV);
  return size;
}

function toPX(str, element) {
  element = element || document.body;
  str = (str || 'px').trim().toLowerCase();
  if (element === window || element === document) {
    element = document.body;
  }
  switch (str) {
    case '%':
      //Ambiguous, not sure if we should use width or height
      return element.clientHeight / 100.0;
    case 'ch':
    case 'ex':
      return getSizeBrutal(str, element);
    case 'em':
      return getPropertyInPX(element, 'font-size');
    case 'rem':
      return getPropertyInPX(document.body, 'font-size');
    case 'vw':
      return window.innerWidth / 100;
    case 'vh':
      return window.innerHeight / 100;
    case 'vmin':
      return Math.min(window.innerWidth, window.innerHeight) / 100;
    case 'vmax':
      return Math.max(window.innerWidth, window.innerHeight) / 100;
    case 'in':
      return PIXELS_PER_INCH;
    case 'cm':
      return PIXELS_PER_INCH / 2.54;
    case 'mm':
      return PIXELS_PER_INCH / 25.4;
    case 'pt':
      return PIXELS_PER_INCH / 72;
    case 'pc':
      return PIXELS_PER_INCH / 6;
  }
  return 1;
}

},{"parse-unit":118}],158:[function(require,module,exports){
"use strict";

module.exports = triangulateCube;

var perm = require("permutation-rank");
var sgn = require("permutation-parity");
var gamma = require("gamma");

function triangulateCube(dimension) {
  if (dimension < 0) {
    return [];
  }
  if (dimension === 0) {
    return [[0]];
  }
  var dfactorial = Math.round(gamma(dimension + 1)) | 0;
  var result = [];
  for (var i = 0; i < dfactorial; ++i) {
    var p = perm.unrank(dimension, i);
    var cell = [0];
    var v = 0;
    for (var j = 0; j < p.length; ++j) {
      v += 1 << p[j];
      cell.push(v);
    }
    if (sgn(p) < 1) {
      cell[0] = v;
      cell[dimension] = 0;
    }
    result.push(cell);
  }
  return result;
}

},{"gamma":67,"permutation-parity":120,"permutation-rank":121}],159:[function(require,module,exports){
"use strict";

module.exports = twoProduct;

var SPLITTER = +(Math.pow(2, 27) + 1.0);

function twoProduct(a, b, result) {
  var x = a * b;

  var c = SPLITTER * a;
  var abig = c - a;
  var ahi = c - abig;
  var alo = a - ahi;

  var d = SPLITTER * b;
  var bbig = d - b;
  var bhi = d - bbig;
  var blo = b - bhi;

  var err1 = x - ahi * bhi;
  var err2 = err1 - alo * bhi;
  var err3 = err2 - ahi * blo;

  var y = alo * blo - err3;

  if (result) {
    result[0] = y;
    result[1] = x;
    return result;
  }

  return [y, x];
}

},{}],160:[function(require,module,exports){
"use strict";

module.exports = fastTwoSum;

function fastTwoSum(a, b, result) {
	var x = a + b;
	var bv = x - a;
	var av = x - bv;
	var br = b - bv;
	var ar = a - av;
	if (result) {
		result[0] = ar + br;
		result[1] = x;
		return result;
	}
	return [ar + br, x];
}

},{}],161:[function(require,module,exports){

/**
 * @module typedarray-polyfill
 */

var methods = ['values', 'sort', 'some', 'slice', 'reverse', 'reduceRight', 'reduce', 'map', 'keys', 'lastIndexOf', 'join', 'indexOf', 'includes', 'forEach', 'find', 'findIndex', 'copyWithin', 'filter', 'entries', 'every', 'fill'];

if (typeof Int8Array !== 'undefined') {
    for (var i = methods.length; i--;) {
        var method = methods[i];
        if (!Int8Array.prototype[method]) Int8Array.prototype[method] = Array.prototype[method];
    }
}
if (typeof Uint8Array !== 'undefined') {
    for (var i = methods.length; i--;) {
        var method = methods[i];
        if (!Uint8Array.prototype[method]) Uint8Array.prototype[method] = Array.prototype[method];
    }
}
if (typeof Uint8ClampedArray !== 'undefined') {
    for (var i = methods.length; i--;) {
        var method = methods[i];
        if (!Uint8ClampedArray.prototype[method]) Uint8ClampedArray.prototype[method] = Array.prototype[method];
    }
}
if (typeof Int16Array !== 'undefined') {
    for (var i = methods.length; i--;) {
        var method = methods[i];
        if (!Int16Array.prototype[method]) Int16Array.prototype[method] = Array.prototype[method];
    }
}
if (typeof Uint16Array !== 'undefined') {
    for (var i = methods.length; i--;) {
        var method = methods[i];
        if (!Uint16Array.prototype[method]) Uint16Array.prototype[method] = Array.prototype[method];
    }
}
if (typeof Int32Array !== 'undefined') {
    for (var i = methods.length; i--;) {
        var method = methods[i];
        if (!Int32Array.prototype[method]) Int32Array.prototype[method] = Array.prototype[method];
    }
}
if (typeof Uint32Array !== 'undefined') {
    for (var i = methods.length; i--;) {
        var method = methods[i];
        if (!Uint32Array.prototype[method]) Uint32Array.prototype[method] = Array.prototype[method];
    }
}
if (typeof Float32Array !== 'undefined') {
    for (var i = methods.length; i--;) {
        var method = methods[i];
        if (!Float32Array.prototype[method]) Float32Array.prototype[method] = Array.prototype[method];
    }
}
if (typeof Float64Array !== 'undefined') {
    for (var i = methods.length; i--;) {
        var method = methods[i];
        if (!Float64Array.prototype[method]) Float64Array.prototype[method] = Array.prototype[method];
    }
}
if (typeof TypedArray !== 'undefined') {
    for (var i = methods.length; i--;) {
        var method = methods[i];
        if (!TypedArray.prototype[method]) TypedArray.prototype[method] = Array.prototype[method];
    }
}

},{}],162:[function(require,module,exports){
(function (global,Buffer){
'use strict';

var bits = require('bit-twiddle');
var dup = require('dup'

//Legacy pool support
);if (!global.__TYPEDARRAY_POOL) {
  global.__TYPEDARRAY_POOL = {
    UINT8: dup([32, 0]),
    UINT16: dup([32, 0]),
    UINT32: dup([32, 0]),
    INT8: dup([32, 0]),
    INT16: dup([32, 0]),
    INT32: dup([32, 0]),
    FLOAT: dup([32, 0]),
    DOUBLE: dup([32, 0]),
    DATA: dup([32, 0]),
    UINT8C: dup([32, 0]),
    BUFFER: dup([32, 0])
  };
}

var hasUint8C = typeof Uint8ClampedArray !== 'undefined';
var POOL = global.__TYPEDARRAY_POOL;

//Upgrade pool
if (!POOL.UINT8C) {
  POOL.UINT8C = dup([32, 0]);
}
if (!POOL.BUFFER) {
  POOL.BUFFER = dup([32, 0]);
}

//New technique: Only allocate from ArrayBufferView and Buffer
var DATA = POOL.DATA,
    BUFFER = POOL.BUFFER;

exports.free = function free(array) {
  if (Buffer.isBuffer(array)) {
    BUFFER[bits.log2(array.length)].push(array);
  } else {
    if (Object.prototype.toString.call(array) !== '[object ArrayBuffer]') {
      array = array.buffer;
    }
    if (!array) {
      return;
    }
    var n = array.length || array.byteLength;
    var log_n = bits.log2(n) | 0;
    DATA[log_n].push(array);
  }
};

function freeArrayBuffer(buffer) {
  if (!buffer) {
    return;
  }
  var n = buffer.length || buffer.byteLength;
  var log_n = bits.log2(n);
  DATA[log_n].push(buffer);
}

function freeTypedArray(array) {
  freeArrayBuffer(array.buffer);
}

exports.freeUint8 = exports.freeUint16 = exports.freeUint32 = exports.freeInt8 = exports.freeInt16 = exports.freeInt32 = exports.freeFloat32 = exports.freeFloat = exports.freeFloat64 = exports.freeDouble = exports.freeUint8Clamped = exports.freeDataView = freeTypedArray;

exports.freeArrayBuffer = freeArrayBuffer;

exports.freeBuffer = function freeBuffer(array) {
  BUFFER[bits.log2(array.length)].push(array);
};

exports.malloc = function malloc(n, dtype) {
  if (dtype === undefined || dtype === 'arraybuffer') {
    return mallocArrayBuffer(n);
  } else {
    switch (dtype) {
      case 'uint8':
        return mallocUint8(n);
      case 'uint16':
        return mallocUint16(n);
      case 'uint32':
        return mallocUint32(n);
      case 'int8':
        return mallocInt8(n);
      case 'int16':
        return mallocInt16(n);
      case 'int32':
        return mallocInt32(n);
      case 'float':
      case 'float32':
        return mallocFloat(n);
      case 'double':
      case 'float64':
        return mallocDouble(n);
      case 'uint8_clamped':
        return mallocUint8Clamped(n);
      case 'buffer':
        return mallocBuffer(n);
      case 'data':
      case 'dataview':
        return mallocDataView(n);

      default:
        return null;
    }
  }
  return null;
};

function mallocArrayBuffer(n) {
  var n = bits.nextPow2(n);
  var log_n = bits.log2(n);
  var d = DATA[log_n];
  if (d.length > 0) {
    return d.pop();
  }
  return new ArrayBuffer(n);
}
exports.mallocArrayBuffer = mallocArrayBuffer;

function mallocUint8(n) {
  return new Uint8Array(mallocArrayBuffer(n), 0, n);
}
exports.mallocUint8 = mallocUint8;

function mallocUint16(n) {
  return new Uint16Array(mallocArrayBuffer(2 * n), 0, n);
}
exports.mallocUint16 = mallocUint16;

function mallocUint32(n) {
  return new Uint32Array(mallocArrayBuffer(4 * n), 0, n);
}
exports.mallocUint32 = mallocUint32;

function mallocInt8(n) {
  return new Int8Array(mallocArrayBuffer(n), 0, n);
}
exports.mallocInt8 = mallocInt8;

function mallocInt16(n) {
  return new Int16Array(mallocArrayBuffer(2 * n), 0, n);
}
exports.mallocInt16 = mallocInt16;

function mallocInt32(n) {
  return new Int32Array(mallocArrayBuffer(4 * n), 0, n);
}
exports.mallocInt32 = mallocInt32;

function mallocFloat(n) {
  return new Float32Array(mallocArrayBuffer(4 * n), 0, n);
}
exports.mallocFloat32 = exports.mallocFloat = mallocFloat;

function mallocDouble(n) {
  return new Float64Array(mallocArrayBuffer(8 * n), 0, n);
}
exports.mallocFloat64 = exports.mallocDouble = mallocDouble;

function mallocUint8Clamped(n) {
  if (hasUint8C) {
    return new Uint8ClampedArray(mallocArrayBuffer(n), 0, n);
  } else {
    return mallocUint8(n);
  }
}
exports.mallocUint8Clamped = mallocUint8Clamped;

function mallocDataView(n) {
  return new DataView(mallocArrayBuffer(n), 0, n);
}
exports.mallocDataView = mallocDataView;

function mallocBuffer(n) {
  n = bits.nextPow2(n);
  var log_n = bits.log2(n);
  var cache = BUFFER[log_n];
  if (cache.length > 0) {
    return cache.pop();
  }
  return new Buffer(n);
}
exports.mallocBuffer = mallocBuffer;

exports.clearCache = function clearCache() {
  for (var i = 0; i < 32; ++i) {
    POOL.UINT8[i].length = 0;
    POOL.UINT16[i].length = 0;
    POOL.UINT32[i].length = 0;
    POOL.INT8[i].length = 0;
    POOL.INT16[i].length = 0;
    POOL.INT32[i].length = 0;
    POOL.FLOAT[i].length = 0;
    POOL.DOUBLE[i].length = 0;
    POOL.UINT8C[i].length = 0;
    DATA[i].length = 0;
    BUFFER[i].length = 0;
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)
},{"bit-twiddle":27,"buffer":36,"dup":59}],163:[function(require,module,exports){
"use strict";"use restrict";

module.exports = UnionFind;

function UnionFind(count) {
  this.roots = new Array(count);
  this.ranks = new Array(count);

  for (var i = 0; i < count; ++i) {
    this.roots[i] = i;
    this.ranks[i] = 0;
  }
}

var proto = UnionFind.prototype;

Object.defineProperty(proto, "length", {
  "get": function () {
    return this.roots.length;
  }
});

proto.makeSet = function () {
  var n = this.roots.length;
  this.roots.push(n);
  this.ranks.push(0);
  return n;
};

proto.find = function (x) {
  var x0 = x;
  var roots = this.roots;
  while (roots[x] !== x) {
    x = roots[x];
  }
  while (roots[x0] !== x) {
    var y = roots[x0];
    roots[x0] = x;
    x0 = y;
  }
  return x;
};

proto.link = function (x, y) {
  var xr = this.find(x),
      yr = this.find(y);
  if (xr === yr) {
    return;
  }
  var ranks = this.ranks,
      roots = this.roots,
      xd = ranks[xr],
      yd = ranks[yr];
  if (xd < yd) {
    roots[xr] = yr;
  } else if (yd < xd) {
    roots[yr] = xr;
  } else {
    roots[yr] = xr;
    ++ranks[xr];
  }
};

},{}],164:[function(require,module,exports){
"use strict";

function unique_pred(list, compare) {
  var ptr = 1,
      len = list.length,
      a = list[0],
      b = list[0];
  for (var i = 1; i < len; ++i) {
    b = a;
    a = list[i];
    if (compare(a, b)) {
      if (i === ptr) {
        ptr++;
        continue;
      }
      list[ptr++] = a;
    }
  }
  list.length = ptr;
  return list;
}

function unique_eq(list) {
  var ptr = 1,
      len = list.length,
      a = list[0],
      b = list[0];
  for (var i = 1; i < len; ++i, b = a) {
    b = a;
    a = list[i];
    if (a !== b) {
      if (i === ptr) {
        ptr++;
        continue;
      }
      list[ptr++] = a;
    }
  }
  list.length = ptr;
  return list;
}

function unique(list, compare, sorted) {
  if (list.length === 0) {
    return list;
  }
  if (compare) {
    if (!sorted) {
      list.sort(compare);
    }
    return unique_pred(list, compare);
  }
  if (!sorted) {
    list.sort();
  }
  return unique_eq(list);
}

module.exports = unique;

},{}],165:[function(require,module,exports){
"use strict";

module.exports = createText;

var vectorizeText = require("./lib/vtext");
var defaultCanvas = null;
var defaultContext = null;

if (typeof document !== 'undefined') {
  defaultCanvas = document.createElement('canvas');
  defaultCanvas.width = 8192;
  defaultCanvas.height = 1024;
  defaultContext = defaultCanvas.getContext("2d");
}

function createText(str, options) {
  if (typeof options !== "object" || options === null) {
    options = {};
  }
  return vectorizeText(str, options.canvas || defaultCanvas, options.context || defaultContext, options);
}

},{"./lib/vtext":166}],166:[function(require,module,exports){
"use strict";

module.exports = vectorizeText;
module.exports.processPixels = processPixels;

var surfaceNets = require('surface-nets');
var ndarray = require('ndarray');
var simplify = require('simplify-planar-graph');
var cleanPSLG = require('clean-pslg');
var cdt2d = require('cdt2d');
var toPolygonCrappy = require('planar-graph-to-polyline');

function transformPositions(positions, options, size) {
  var align = options.textAlign || "start";
  var baseline = options.textBaseline || "alphabetic";

  var lo = [1 << 30, 1 << 30];
  var hi = [0, 0];
  var n = positions.length;
  for (var i = 0; i < n; ++i) {
    var p = positions[i];
    for (var j = 0; j < 2; ++j) {
      lo[j] = Math.min(lo[j], p[j]) | 0;
      hi[j] = Math.max(hi[j], p[j]) | 0;
    }
  }

  var xShift = 0;
  switch (align) {
    case "center":
      xShift = -0.5 * (lo[0] + hi[0]);
      break;

    case "right":
    case "end":
      xShift = -hi[0];
      break;

    case "left":
    case "start":
      xShift = -lo[0];
      break;

    default:
      throw new Error("vectorize-text: Unrecognized textAlign: '" + align + "'");
  }

  var yShift = 0;
  switch (baseline) {
    case "hanging":
    case "top":
      yShift = -lo[1];
      break;

    case "middle":
      yShift = -0.5 * (lo[1] + hi[1]);
      break;

    case "alphabetic":
    case "ideographic":
      yShift = -3 * size;
      break;

    case "bottom":
      yShift = -hi[1];
      break;

    default:
      throw new Error("vectorize-text: Unrecoginized textBaseline: '" + baseline + "'");
  }

  var scale = 1.0 / size;
  if ("lineHeight" in options) {
    scale *= +options.lineHeight;
  } else if ("width" in options) {
    scale = options.width / (hi[0] - lo[0]);
  } else if ("height" in options) {
    scale = options.height / (hi[1] - lo[1]);
  }

  return positions.map(function (p) {
    return [scale * (p[0] + xShift), scale * (p[1] + yShift)];
  });
}

function getPixels(canvas, context, str, size) {
  var width = Math.ceil(context.measureText(str).width + 2 * size) | 0;
  if (width > 8192) {
    throw new Error("vectorize-text: String too long (sorry, this will get fixed later)");
  }
  var height = 3 * size;
  if (canvas.height < height) {
    canvas.height = height;
  }

  context.fillStyle = "#000";
  context.fillRect(0, 0, canvas.width, canvas.height);

  context.fillStyle = "#fff";
  context.fillText(str, size, 2 * size

  //Cut pixels from image
  );var pixelData = context.getImageData(0, 0, width, height);
  var pixels = ndarray(pixelData.data, [height, width, 4]);

  return pixels.pick(-1, -1, 0).transpose(1, 0);
}

function getContour(pixels, doSimplify) {
  var contour = surfaceNets(pixels, 128);
  if (doSimplify) {
    return simplify(contour.cells, contour.positions, 0.25);
  }
  return {
    edges: contour.cells,
    positions: contour.positions
  };
}

function processPixelsImpl(pixels, options, size, simplify) {
  //Extract contour
  var contour = getContour(pixels, simplify

  //Apply warp to positions
  );var positions = transformPositions(contour.positions, options, size);
  var edges = contour.edges;
  var flip = "ccw" === options.orientation;

  //Clean up the PSLG, resolve self intersections, etc.
  cleanPSLG(positions, edges

  //If triangulate flag passed, triangulate the result
  );if (options.polygons || options.polygon || options.polyline) {
    var result = toPolygonCrappy(edges, positions);
    var nresult = new Array(result.length);
    for (var i = 0; i < result.length; ++i) {
      var loops = result[i];
      var nloops = new Array(loops.length);
      for (var j = 0; j < loops.length; ++j) {
        var loop = loops[j];
        var nloop = new Array(loop.length);
        for (var k = 0; k < loop.length; ++k) {
          nloop[k] = positions[loop[k]].slice();
        }
        if (flip) {
          nloop.reverse();
        }
        nloops[j] = nloop;
      }
      nresult[i] = nloops;
    }
    return nresult;
  } else if (options.triangles || options.triangulate || options.triangle) {
    return {
      cells: cdt2d(positions, edges, {
        delaunay: false,
        exterior: false,
        interior: true
      }),
      positions: positions
    };
  } else {
    return {
      edges: edges,
      positions: positions
    };
  }
}

function processPixels(pixels, options, size) {
  try {
    return processPixelsImpl(pixels, options, size, true);
  } catch (e) {}
  try {
    return processPixelsImpl(pixels, options, size, false);
  } catch (e) {}
  if (options.polygons || options.polyline || options.polygon) {
    return [];
  }
  if (options.triangles || options.triangulate || options.triangle) {
    return {
      cells: [],
      positions: []
    };
  }
  return {
    edges: [],
    positions: []
  };
}

function vectorizeText(str, canvas, context, options) {
  var size = options.size || 64;
  var family = options.font || "normal";

  context.font = size + "px " + family;
  context.textAlign = "start";
  context.textBaseline = "alphabetic";
  context.direction = "ltr";

  var pixels = getPixels(canvas, context, str, size);

  return processPixels(pixels, options, size);
}

},{"cdt2d":38,"clean-pslg":44,"ndarray":114,"planar-graph-to-polyline":124,"simplify-planar-graph":146,"surface-nets":153}],167:[function(require,module,exports){
var hiddenStore = require('./hidden-store.js');

module.exports = createStore;

function createStore() {
    var key = {};

    return function (obj) {
        if ((typeof obj !== 'object' || obj === null) && typeof obj !== 'function') {
            throw new Error('Weakmap-shim: Key must be object');
        }

        var store = obj.valueOf(key);
        return store && store.identity === key ? store : hiddenStore(obj, key);
    };
}

},{"./hidden-store.js":168}],168:[function(require,module,exports){
module.exports = hiddenStore;

function hiddenStore(obj, key) {
    var store = { identity: key };
    var valueOf = obj.valueOf;

    Object.defineProperty(obj, "valueOf", {
        value: function (value) {
            return value !== key ? valueOf.apply(this, arguments) : store;
        },
        writable: true
    });

    return store;
}

},{}],169:[function(require,module,exports){
// Original - @Gozola.
// https://gist.github.com/Gozala/1269991
// This is a reimplemented version (with a few bug fixes).

var createStore = require('./create-store.js');

module.exports = weakMap;

function weakMap() {
    var privates = createStore();

    return {
        'get': function (key, fallback) {
            var store = privates(key);
            return store.hasOwnProperty('value') ? store.value : fallback;
        },
        'set': function (key, value) {
            privates(key).value = value;
            return this;
        },
        'has': function (key) {
            return 'value' in privates(key);
        },
        'delete': function (key) {
            return delete privates(key).value;
        }
    };
}

},{"./create-store.js":167}],170:[function(require,module,exports){
module.exports = require('cwise-compiler')({
    args: ['array', {
        offset: [1],
        array: 0
    }, 'scalar', 'scalar', 'index'],
    pre: {
        "body": "{}",
        "args": [],
        "thisVars": [],
        "localVars": []
    },
    post: {
        "body": "{}",
        "args": [],
        "thisVars": [],
        "localVars": []
    },
    body: {
        "body": "{\n        var _inline_1_da = _inline_1_arg0_ - _inline_1_arg3_\n        var _inline_1_db = _inline_1_arg1_ - _inline_1_arg3_\n        if((_inline_1_da >= 0) !== (_inline_1_db >= 0)) {\n          _inline_1_arg2_.push(_inline_1_arg4_[0] + 0.5 + 0.5 * (_inline_1_da + _inline_1_db) / (_inline_1_da - _inline_1_db))\n        }\n      }",
        "args": [{
            "name": "_inline_1_arg0_",
            "lvalue": false,
            "rvalue": true,
            "count": 1
        }, {
            "name": "_inline_1_arg1_",
            "lvalue": false,
            "rvalue": true,
            "count": 1
        }, {
            "name": "_inline_1_arg2_",
            "lvalue": false,
            "rvalue": true,
            "count": 1
        }, {
            "name": "_inline_1_arg3_",
            "lvalue": false,
            "rvalue": true,
            "count": 2
        }, {
            "name": "_inline_1_arg4_",
            "lvalue": false,
            "rvalue": true,
            "count": 1
        }],
        "thisVars": [],
        "localVars": ["_inline_1_da", "_inline_1_db"]
    },
    funcName: 'zeroCrossings'
});

},{"cwise-compiler":54}],171:[function(require,module,exports){
"use strict";

module.exports = findZeroCrossings;

var core = require("./lib/zc-core");

function findZeroCrossings(array, level) {
  var cross = [];
  level = +level || 0.0;
  core(array.hi(array.shape[0] - 1), cross, level);
  return cross;
}

},{"./lib/zc-core":170}]},{},[1]);
</script>
</html>
